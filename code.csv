vector structure,"#define data_type int
struct _array {
    size_t size;
    size_t capacity;
    data_type *data;
};
typedef struct _array array_t;
",/Users/mbp/workspace/sandbox/algo/array/array.c
array_t *init(size_t size) ,"array_t *init(size_t size) {
    array_t *cv = malloc(sizeof(array_t));
    size_t capacity = round2up(size);
    data_type *data = malloc(sizeof(data_type) * capacity);
    if (cv == NULL || data == NULL) {
        printf(""Out of memory"");
        exit(1);
    }
    cv->data = data;
    cv->size = size;
    cv->capacity = capacity;
    return cv;
}
size_t round2up(size_t size) {
    assert ((size << 1) >= size);  // check overflow (use `== size` for 0)
    size_t n = 1;
    while (n <= size)
        n <<= 1;
    return n;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"array_t *inits(size_t size, ...) ","array_t *inits(size_t size, ...) {
    array_t *a = init(size);
    va_list va;
    va_start(va, size);
    for (int i = 0; i < size; i++)
        a->data[i] = va_arg(va, data_type);
    va_end(va);
    return a;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"int indexAt(array_t *head, int index) ","int indexAt(array_t *head, int index) {
  // O(1)
  // Using a vector, you can access an element of it for a constant time.
  if (0 <= index && index < head->size)
    return head->data[index];
  printf(""Out of index"");
  exit(1);
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"int equal(array_t *a1, array_t *a2) ","int equal(array_t *a1, array_t *a2) {
    if (a1 == NULL && a2 == NULL)
        return 1;
    else if (a1 == NULL || a2 == NULL)
        return 0;
    else if (a1->size != a2->size)
        return 0;
    for (int i = 0; i < a1->size; i++) {
        if (a1->data[i] != a2->data[i])
            return 0;
    }
    return 1;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"void insertAt(array_t *a, int index, int value) ","void insertAt(array_t *a, int index, int value) {
    // O(n + 1) or O(2n) => listよりもinsertは時間がかかる処理
    // 以下の仕様はOSごとに確認 (拡張とコピーする？)
    // reallocは、古いメモリブロックにあったデータは可能な限り新しいメモリブロックにコピー
    // また、メモリの位置から拡張できるのであれば、そのアドレスから拡張
    // I think if realloc returns aother pinter, it means memcpy is executed so it needs O(n)
    if (a->size >= a->capacity) { // size == capacityの場合、もう容量がないということ
        a->capacity = round2up(a->size + 1);
        a->data = realloc(a->data, sizeof(data_type) * a->capacity); // copyされてることを前提
    }
    /* You need to move an element one by one from index. */
    for (int i = a->size - 1; i >= index; i--)
        a->data[i + 1] = a->data[i];
    a->data[index] = value;
    a->size++;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"void deleteAt(array_t *a, int index) ","void deleteAt(array_t *a, int index) {
  // O(n)
  // You need to move each item from index to the next
  // no need to resize memory
  int i = index;
  for (int i = index; i < a->size - 1; i++)
    a->data[i] = a->data[i + 1];
  // WARN: 最後要素 a->size-1は不要になるが、freeで解放してはいけない
  // free(a->data + (a->size - 1));
  a->size--; // index == a->size-1のときは、shiftするだけ
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"array_t* concat(array_t *a1, array_t *a2) ","array_t* concat(array_t *a1, array_t *a2) {
    // O(n + m) M(n + m)
    if (a1 == NULL || a2 == NULL) {
        printf(""Can't append"");
        exit(1);
    }
    // you need the size of a1 + a2 to get memory
    size_t a1_size = a1->size;
    size_t size = a1->size + a2->size;
    if (size >= a1->capacity) {
        a1->size = size;
        a1->capacity = round2up(size);
        a1->data = realloc(a1->data, sizeof(data_type) * a1->capacity); // copy前提
        if (a1->data == NULL)
            exit(1);
    }
    for (int i = a1_size; i < size; i++)
        a1->data[i] = a2->data[i - a1_size];
    return a1;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
"void pushBack(array_t *a, data_type data) ","void pushBack(array_t *a, data_type data) {
    if (a->size >= a->capacity) {
        a->capacity = round2up(a->size);
        a->data = realloc(a->data, sizeof(data_type) * a->capacity);
        if (a->data == NULL)
            exit(1);
    }
    a->data[a->size] = data;
    a->size++;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
data_type popBack(array_t *a) ,"data_type popBack(array_t *a) {
    if (a->size <= 0)
        exit(1);
    data_type data = a->data[a->size-1];
    a->size--;
    return data;
}
",/Users/mbp/workspace/sandbox/algo/array/array.c
ファイルへの書き込みが競合するコード,"func main() {
    // 一つのファイルに書き込みをする場合, processとthread safeを考慮する必要がある
    // process unsafe logging (アドバイザリロック => flockを使う)
    os.Remove(""/tmp/test.log"")
	f, err := os.OpenFile(""/tmp/test.log"", os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		log.Fatal(""error opening file :"", err.Error())
	}
    // 競合状態をわざと起こす
    wg := new(sync.WaitGroup)
    wg.Add(1000)
    writer := bufio.NewWriter(f)
	log.SetOutput(f)
	for i := 0; i < 1000; i++ {
		go func(x int) { // 直接iを渡さない!
			// log.Println(x) // logは排他制御できてるっぽい
            writer.WriteString(fmt.Sprintf(""%d\n"", i))
            writer.Flush()
            wg.Done()
		}(i)
	}
    wg.Wait()
    // ファイルの中身を確認
	f, _ = os.OpenFile(""/tmp/test.log"", os.O_RDONLY, 0644)
    lines, _ := ioutil.ReadAll(f)
    fmt.Println(string(lines))
}
",/Users/mbp/workspace/sandbox/algo/async/file-without-lock.go
更新処理が競合しないようにするためのコード,"var v1 int32 // 共有メモリ
var v2 int32 // 共有メモリ(atomicなし)
func main () {
    wg := new(sync.WaitGroup)
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            atomic.AddInt32(&v1, 1) // atomicを使い、共有メモリの更新にロック
            wg.Done()
        }()
    }
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            v2++
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Println(v1, v2) // 1000 855
}
",/Users/mbp/workspace/sandbox/algo/async/memory-atomic.go
AVL Insert,"func Insert(n *Node, v int) *Node {
    if n == nil {
        return New(v)
    } else if v ==  n.Value {
        return n // DO NOTHING
    } else if v < n.Value {
        n.Left = Insert(n.Left, v)
        if n.Left.Height() - n.Right.Height() >= 2 { // Leftに挿入=>Leftの高さが大きい
            if v < n.Left.Value {
                n = n.RotateR()
            } else {
                n.Left = n.Left.RotateL()
                n = n.RotateR()
            }
        }
    } else {
        n.Right = Insert(n.Right, v)
        if n.Right.Height() - n.Left.Height() >= 2 {
            if v > n.Right.Value {
                n = n.RotateL()
            } else {
                n.Right = n.Right.RotateR()
                n = n.RotateL()
            }
        }
    }
    n.UpdateHeight()
    return n
}
",/Users/mbp/workspace/sandbox/algo/balanced/avl.go
AVL IsBalanced,"func IsBalanced(n *Node) bool {
    if n == nil {
        return true
    }
    if abs(n.Left.Height() - n.Right.Height()) <= 1 {
        return IsBalanced(n.Left) && IsBalanced(n.Right)
    } else {
        return false
    }
}
",/Users/mbp/workspace/sandbox/algo/balanced/avl.go
red-black tree structure,"enum _color {
  BLACK = 1,
  RED = 2,
};
#define rbtree_data_type int
struct _rbtree {
  enum _color color;
  rbtree_data_type data;
  struct _rbtree *parent;
  struct _rbtree *left;
  struct _rbtree *right;
};
typedef struct _rbtree rbtree_t;
typedef enum _color color_e;
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.c
"void rbtree_balance(rbtree_t **root, rbtree_t *tree) ","void rbtree_balance(rbtree_t **root, rbtree_t *tree) {
  /*
   (制約)
   1. 赤が２つ続いてはいけない 
   2. 全ての経路において黒の数が等しい (経路数変わらないから、rootは常に黒で良い)
   もし、現在平衡状態として、赤を新しく加えると
   (1) grand parent is redの場合 その子供は黒でないとなので、平衡のまま
   (2) grand parent is blackの場合
   (2.1) 2 parents are blackの場合 平衡のまま
   (2.2) 2 parents are black and redの場合 黒に追加する場合は平衡のまま
   つまり、祖父が黒で親が(赤, 赤), (赤, 黒)の2通りについて考える
   (赤, 赤) => 親と叔父を黒にして、祖父を赤にすれば平衡状態. (ただし祖父で再帰必要) (これはまとめられる)
   */
  rbtree_t *p, *u;  // parent, uncle
  // この関数はtreeが赤であることを呼び出し元で保証されている
  while ((p = tree->parent) && p->color == RED && p->parent) {
    if (LEFT_CHILD(p))
      u = p->parent->right;
    else
      u = p->parent->left;
    if (u && u->color == RED) {
      p->parent->color = RED;
      p->color = u->color = BLACK;
      tree = tree->parent->parent;
    } else {
      if (LEFT_CHILD(p)) {
        if (RIGHT_CHILD(tree)) {
          // LR
          // after rotation, a tree's pointer is the same as LL
          tree = p;
          rotateL(root, tree);
          // 同じ色のUncle/Parentなので、黒の経路数変わらない
        }
        // LL
        // 左親は黒一つ減る状態になるので祖父を黒にする. 代わりに右親を赤くし黒の個数を平衡に (右親の子供２人は黒なので問題無い)
        tree->parent->color = BLACK;
        tree->parent->parent->color = RED;
        rotateR(root, tree->parent->parent);
      } else {
        if (LEFT_CHILD(tree)) {
          // RL
          tree = p;
          rotateR(root, tree);
        }
        // RR
        tree->parent->color = BLACK;
        tree->parent->parent->color = RED;
        rotateL(root, tree->parent->parent);
      }
    }
  }
}
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.c
"void rbtree_insert(rbtree_t **root, rbtree_data_type data) ","void rbtree_insert(rbtree_t **root, rbtree_data_type data) {
  rbtree_t *node = (rbtree_t *)malloc(sizeof(rbtree_t));
  if (node == NULL) {
    printf(""Out of memory"");
    exit(1);
  }
  node->color = RED;  // new data is always RED
  node->data = data;
  node->left = node->right = node->parent = NULL;
  if (*root == NULL) {
    *root = node;
  } else {
    rbtree_t *parent = NULL, *tree = *root;
    while (1) {
      if (tree->data >= data) {
        if (tree->left) {
          parent = tree->parent; // いらない?
          tree = tree->left;
        } else { // 挿入
          tree->left = node;
          node->parent = tree;
          break;
        }
      } else {
        if (tree->right) {
          parent = tree->parent;
          tree = tree->right;
        } else {
          tree->right = node;
          node->parent = tree;
          break;
        }
      }
    }
    rbtree_balance(root, node);
  }
  (*root)->color = BLACK;
}
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.c
Red-Black,"func Insert(n *Node, v int) *Node {
    new := n.Root().Insert(v)
    Balance(new)
    new.Root().Color = BLACK
    return new
}
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.go
func Balance(n *Node) ,"func Balance(n *Node) {
    for n.Parent != nil && n.Parent.Color == RED && n.Parent.Parent != nil {
        p := n.Parent
        if p.LeftChild() {
            if n.RightChild() {
                n = p
                n.RotateL()
            }
            n.Parent.Parent.RotateR()
        } else {
            if p.LeftChild() {
                n = p
                n.RotateR()
            }
            n.Parent.Parent.RotateL()
        }
        n.Color = BLACK
        n = p // 最終的に2つ上に移動
    }
}
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.go
func IsBalanced(n *Node) bool ,"func IsBalanced(n *Node) bool {
    if n == nil {
        return true
    }
    if n.Color == RED {
        if n.Left != nil && n.Left.Color == RED {
            return false
        }
        if n.Right != nil && n.Right.Color == RED {
            return false
        }
    }
    if BlackNumber(n.Left) != BlackNumber(n.Right) {
        return false
    }
    return IsBalanced(n.Left) && IsBalanced(n.Right)
}
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.go
func BlackNumber(n *Node) int ,"func BlackNumber(n *Node) int {
    if n == nil {
        return 1
    }
    c := 0
    if n.Color == BLACK {
        c = 1
    }
    l, r := BlackNumber(n.Left), BlackNumber(n.Right)
    if l < r {
        return c + r
    }
    return c + l
}
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.go
:Q:赤黒木のdata,"data Color = B | R deriving Show
data Hash k v = Leaf | Node Color (Hash k v) (k, v) (Hash k v) deriving Show
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.hs
insert' :: Ord k => k -> v -> Hash k v -> Hash k v,"insert' :: Ord k => k -> v -> Hash k v -> Hash k v
insert' k v Leaf = Node R Leaf (k, v) Leaf
insert' k v (Node c a (k', v') b) = case compare k k' of
  LT -> balance $ Node c (insert' k v a) (k', v') b
  GT -> balance $ Node c a (k', v') (insert' k v b)
  EQ -> Node c a (k, v) b
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.hs
balance :: Ord k => Hash k v -> Hash k v,"balance :: Ord k => Hash k v -> Hash k v
balance (Node B (Node R (Node R a x b) y c) z d) = (Node R (Node B a x b) y (Node B c z d))
balance (Node B (Node R a x (Node R b y c)) z d) = (Node R (Node B a x b) y (Node B c z d))
balance (Node B a x (Node R (Node R b y c) z d)) = (Node R (Node B a x b) y (Node B c z d))
balance (Node B a x (Node R b y (Node R d z c))) = (Node R (Node B a x b) y (Node B c z d))
balance x  = x
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.hs
"fromList :: Ord k => [(k, v)] -> Hash k v","fromList :: Ord k => [(k, v)] -> Hash k v
fromList = foldl insert Leaf
insert :: Ord k => Hash k v -> (k, v) -> Hash k v
insert x (k, v) = turnB $ insert' k v x
",/Users/mbp/workspace/sandbox/algo/balanced/red-black.hs
func Splay(n *Node) ,"func Splay(n *Node) {
    for n.Parent != nil {
        if n.Parent.Parent == nil {
            if n.LeftChild() {
                n.Parent.RotateR() // zig
            } else {
                n.Parent.RotateL()
            }
        } else {
            if n.Parent.LeftChild() {
                if n.LeftChild() {
                    n.Parent.Parent.RotateR() // zig zig (祖父が先)
                } else {
                    n.Parent.RotateL() // zig zag
                }
                n.Parent.RotateR()
            } else {
                if n.RightChild() {
                    n.Parent.Parent.RotateL()
                } else {
                    n.Parent.RotateR()
                }
                n.Parent.RotateL()
            }
        }
    }
}
",/Users/mbp/workspace/sandbox/algo/balanced/splay.go
"func Get(n *Node, v int) *Node ","func Get(n *Node, v int) *Node {
    leaf := n.Root().Get(v)
    if leaf != nil {
        Splay(leaf)
    }
    return leaf
}
",/Users/mbp/workspace/sandbox/algo/balanced/splay.go
"func Remove(n *Node, v int) ","func Remove(n *Node, v int) {
    // 左側を同じkeyでsplayする. (rootより左側にしかkeyはbst上こないので)
    node *z = find( key );
    if( !z ) return;
    splay( z );
    node *s = z->left;
    node *t = z->right;
    delete z;
    node *sMax = NULL;
    if(s) {
        s->parent = NULL;
        sMax = subtree_maximum(s);
        splay(sMax);
        root = sMax;
    }
    if(t) {
        if(s)
        sMax->right = t;
        else
        root = t;
        t->parent = sMax;
}
",/Users/mbp/workspace/sandbox/algo/balanced/splay.go
"func IsConected(g *Graph, src int, dst int) bool ","func IsConected(g *Graph, src int, dst int) bool {
	q := []int {src}
	visited := make([]bool, g.N)
	for len(q) != 0 {
		node := q[0]
		if node == dst {  // srcから始めて、dstに行ければtrue
			return true
		}
		visited[node] = true
		q = q[1:]
		for _, next := range g.E[node] {
			if ! visited[next] {
				q = append(q, next)
			}
		}
	}
	return false
}
",/Users/mbp/workspace/sandbox/algo/bfs/is_connected.go
深さDのノードで構築されたlinkedリストを作成 (各深さごとのリストが答え),"func LinkLists(n *Node) [][]*Node {
	// BFSでもdepth++で降りていく場合がよい例??? (ただしメモリがNode数だけ必要)
	depth := 0
	nodes := [][]*Node{{n}}
	for true {
		list := []*Node{}
		for _, n := range nodes[depth] {
			for _, i := range []*Node{n.Left, n.Right} {
				if i != nil {
					list = append(list, i)
				}
			}
		}
		if len(list) == 0 {
			break
		} else {
			nodes = append(nodes, list)
			depth++
		}
	}
	return nodes
}
",/Users/mbp/workspace/sandbox/algo/bfs/linked-lists.go
"func (g *Graph) Find(src, dst int) []int ","func (g *Graph) Find(src, dst int) []int {
	q := []int{src}
	visited := make([]bool, g.N)
	previous := make([]int, g.N)
	for i := 0; i < g.N; i++ {
		previous[i] = -1
	} // TODO: how to make values default
	for len(q) != 0 {
		node := q[0]
		if node == dst {
			paths := []int{node}
			for i := previous[node]; i != -1; i = previous[i] {
				paths = append(paths, i)
			}
			return paths
		}
		q = q[1:]
		visited[node] = true
		for _, next := range g.E[node] {
			if !visited[next] {
				q = append(q, next)
				previous[next] = node
			}
		}
	}
	return []int{}
}
",/Users/mbp/workspace/sandbox/algo/bfs/shortest_path.go
binary-search-tree structure,"// left <= parent <= right
// all the children of left are not larger than parent
// all the children of right are not smaller than parent
// 上記の不等式を満たす必要がないのがbinary-tree
struct _bst {
  data_type data;
  struct _bst *parent;
  struct _bst *left;
  struct _bst *right;
};
typedef struct _bst bst_t;
bst_t *bst_init(data_type data) {
  bst_t *tree = (bst_t *)malloc(sizeof(bst_t));
  if (tree == NULL) {
    printf(""Out of memory\n"");
    exit(1);
  }
  tree->data = data;
  tree->parent = NULL;
  tree->left = NULL;
  tree->right = NULL;
  return tree;
}
",/Users/mbp/workspace/sandbox/algo/binary-search/binary-search-tree.c
"void bst_insert(bst_t **bst, data_type data, bst_t *parent) ","void bst_insert(bst_t **bst, data_type data, bst_t *parent) {
  // O(log2n)
  // you don't need the arparent of parent as previous data
  // but it makes code more simple
  // WARN: it takes O(n) to insert a sorted list
  // if you insert range(0, 10), the height is 10
  bst_t *tree = *bst;
  if (tree == NULL) {
    tree = bst_init(data);
    tree->parent = parent;
    *bst = tree;
  } else if (tree->data >= data) {
    bst_insert(&(tree->left), data, tree);
  } else {
    bst_insert(&(tree->right), data, tree);
  }
}
",/Users/mbp/workspace/sandbox/algo/binary-search/binary-search-tree.c
"bst_t *bst_search(bst_t *tree, data_type data) ","bst_t *bst_search(bst_t *tree, data_type data) {
  // O(log2n)
  if (tree == NULL)
    return NULL;
  else if (tree->data == data)
    return tree;
  else if (tree->data >= data)
    return bst_search(tree->left, data);
  else
    return bst_search(tree->right, data);
}
",/Users/mbp/workspace/sandbox/algo/binary-search/binary-search-tree.c
"void bst_display(bst_t *tree, int depth) ","void bst_display(bst_t *tree, int depth) {
    if (tree) {
      for(int i = 0; i < depth; i++) printf("" "");
      // pre order (TODO: in-order)
      printf(""%d\n"", tree->data);
      bst_display(tree->left, depth+1);
      bst_display(tree->right, depth+1);
    }
}
",/Users/mbp/workspace/sandbox/algo/binary-search/binary-search-tree.c
長さlのソート配列に含まれるNの個数,"func countElem(A []int, k int) int {
    if len(A) == 0 || k < A[0] || A[len(A)-1] < k {
        return 0
    }
    min, max := -1, -1
    lo, hi := 0, len(A)-1
    for lo <= hi {
        mi := lo + (hi - lo) / 2
        if A[mi] <= k {
            lo = mi + 1
            max = mi
        } else {
            hi = mi - 1
        }
    }
    lo, hi = 0, len(A)-1
    for lo <= hi {
        mi := lo + (hi - lo) / 2
        if A[mi] >= k {
            hi = mi - 1
            min = mi
        } else {
            lo = mi + 1
        }
    }
	return max - min + 1
}
",/Users/mbp/workspace/sandbox/algo/binary-search/count-elem.go
長さlのソート配列に含まれるNの個数,"countElem xs n = (foldl f 0 bits) - (foldl g (2^32-1) bits) + 1 where -- 0から11111....を探索
  f acc x = if f2 (acc + x) then acc + x else acc
  g acc x = if g2 (acc - x) then acc - x else acc  -- (head xs) > n なら-1を返すべき. (head xs) < nの場合は(length xs)を返す
  f2 a = (length xs) > a && xs !! a <= n
  g2 a = (length xs) <= a || xs !! a >= n  -- 配列のサイズを超える場合は、indexが小さくなる方向へ
  bits = reverse [2^i | i<-[0..31]]
",/Users/mbp/workspace/sandbox/algo/binary-search/count-elem.hs
x^2>=15241578750190521を満たす最小のxを求める,"func findMin(N int) int {
	g := func(x int) bool {
		return x*x >= N
	}
	var hi int
	rv, lo, hi := -1, 0, 2<<30 // warn: math.Pow(2, 30) float64
	for lo <= hi {
		mi := (lo + hi) / 2
		if g(mi) {
			hi = mi - 1
			rv = mi
		} else {
			lo = mi + 1
		}
	}
	return rv
}
",/Users/mbp/workspace/sandbox/algo/binary-search/find-min-x.go
x^2>=15241578750190521を満たす最小のxを求める,"findMin :: Integer -> Integer
findMin n = foldl go (2^32) (reverse [2^i | i<-[0..32]]) where
  f x = x * x >= n
  go acc x = if f (acc - x) then acc - x else acc
",/Users/mbp/workspace/sandbox/algo/binary-search/find-min-x.hs
15241578750190521の平方根,"func findSqrt(n int) (int, bool) {
	f := func(x int) int {
        return x * x - n // max x st x^2 >= n
	}
	lo, hi := 0, 2<<31
	for lo <= hi {
		mi := lo + (hi-lo)/2
        rv := f(mi)
        if rv == 0 {
            return mi, true
        } else if rv > 0 {
            hi = mi - 1
        } else {
            lo = mi + 1
        }
	}
	return 0, false
}
",/Users/mbp/workspace/sandbox/algo/binary-search/find-sqrt-n.go
Longest Increasing Subsequence O(NlogN),"func lis(a []int) int {
	dp := []int{}
	for i := 0; i < len(a); i++ {
		if len(dp) == 0 || dp[len(dp)-1] < a[i] {
			dp = append(dp, a[i])
		} else {
			lo, rt, hi := 0, 0, len(dp)-1
			for lo <= hi {
				mi := lo + (hi-lo)/2
				if a[i] <= dp[mi] {
					hi = mi - 1
					rt = mi
				} else {
					lo = mi + 1
				}
			}
			dp[rt] = a[i]
		}
	}
	return len(dp)
}
",/Users/mbp/workspace/sandbox/algo/binary-search/lis.go
longest-increasing-subsequence O(n^2),"lis :: [Int] -> [Int]
lis = f where
 f [] = []
 f (x:xs) = x:(f2 $ map f $ filter f1 $ (scanr (:) []) $ xs) where
   f1 [] = False
   f1 (y:_) = (y > x)
   f2 [] = []
   f2 yss = maximumBy (\a b -> compare (length a) (length b)) yss
",/Users/mbp/workspace/sandbox/algo/binary-search/lis.hs
ある配列をK個に区分したときの、区分配列のうち最大和の最小値を求める(ただし要素がない配列も１つと数えることが可能),"func f(sum, K int, a []int) bool {
    // 最大和をsumとした時に、実際の和がsumにならない時は、それよりも小さいsumが存在するということ
    // 最大和が小さすぎると、K個に配列を分割できない場合は、それよりも大きなsumで探索する必要がある
	s, k := 0, 0
	for i := 0; i < len(a); i++ { // greedy
		if s+a[i] <= sum { // sumが緩くても大丈夫. trueを返し、それよりも小さなsumで探索を続ける
			s += a[i]
		} else {
			s = a[i]
			k++
		}
		if k == K {
			return false
		}
	}
	return true
}
",/Users/mbp/workspace/sandbox/algo/binary-search/minimize-sum-sequence.go
0が途中に混ざった場合のbinary search,"func find(a []int, target int) int {
	lo, hi := 0, len(a)-1 // 区間[low, high]となるため、-1を忘れない
	for lo <= hi {
		mi := lo + (hi-lo)/2
		for mi > lo && a[mi] == 0 { // mi >= lo だと mi < loになる可能性がある
			mi--
		}
		if a[mi] == target {
			return mi
		} else if target < a[mi] {
			hi = mi - 1
		} else {
			lo = mi + 1
		}
	}
	return -1 // NOT FOUND
}
",/Users/mbp/workspace/sandbox/algo/binary-search/zero.go
check the tree is balanced (balanced means any two leaf have the same length form root),"func isBalanced(n *Node) bool {
    // 最大と最小の深さが等しければ、balancedとみなす
	return maxDepth(n)-minDepth(n) == 0
}
func maxDepth(n *Node) int {
	if n == nil {
		return 0
	}
	return 1 + max(maxDepth(n.Left), maxDepth(n.Right))
}
func minDepth(n *Node) int {
	if n == nil {
		return 0
	}
	return 1 + min(maxDepth(n.Left), maxDepth(n.Right))
}
",/Users/mbp/workspace/sandbox/algo/binary-tree/is-balanced.go
Lowest Common Ancestor (Without Addtional Memory),"-- rootから順にa,bを持つかどうか調べる
-- ただしnodeの値はuniqueであることが条件
lca :: Ord a => Tree a -> Tree a -> Tree a -> Maybe (Tree a)
lca Leaf a b = Nothing
lca n@(Node c l r) a b
  | (hasNode l a) && (hasNode l b) = lca l a b
  | (hasNode r a) && (hasNode r b) = lca r a b
  | otherwise = Just n
-- 第二引数のNodeを保持していればTrue
hasNode :: Ord a => Tree a -> Tree a -> Bool
hasNode Leaf _ = False 
hasNode n1@(Node a1 l r) n2@(Node a2 _ _)
  | a1 == a2 = True
  | otherwise = (hasNode l n2) || (hasNode r n2)
",/Users/mbp/workspace/sandbox/algo/binary-tree/lca.hs
"func InOrderPrev (n, prev *Node) *Node ","func InOrderPrev (n, prev *Node) *Node {
// left -> parent -> right PREV で考えずに
// left <- parent <- right NEXT で考える
	if n == nil {
		return nil
	} else if prev == nil {
		if n.Left != nil {
			return InOrderPrev(n.Left, n)
        } else {
			return InOrderPrev(n.Parent, n)
		}
	} else {
        if n.Right == prev {
			return n
		} else if n.Left == prev {
			return InOrderPrev(n.Parent, n)
		} else { // n.Parent == prev
            if n.Left != nil { 
                return InOrderPrev(n.Right, n)
            } else {
                return n
            }
		}
	}
}
",/Users/mbp/workspace/sandbox/algo/binary-tree/order/inOrderPrev.go
木構造の移動方法,"- PRE:  parent -> left   -> right  (幅優先 上から下へ)
- POST: left   -> right  -> parent (深優先 下から上へ)
- IN:   left   -> parent -> right  (左優先 左から右へ)
逆順の時は、矢印の向きが逆になるだけ
",/Users/mbp/workspace/sandbox/algo/binary-tree/order/order.md
2分木における経路の和がK,"pathK :: (Eq a, Num a) => Tree a -> a -> [[a]]
pathK n k = go n [] where
  go Leaf _ = []
  go n@(Node p l r) path = a ++ b ++ c where
    a = go l (p:path)
    b = go r (p:path)
    c = filter ((k==).sum) (scanl (flip (:)) [] (p:path))
",/Users/mbp/workspace/sandbox/algo/binary-tree/path-k.hs
Return true If a sub tree is a part of the parent tree,"func subTree(tree, sub *Node) bool {
	if sub == nil { // 空集合は任意の集合の部分集合
		return true
	} else if tree == nil {
		return false
	} else if matchTree(tree, sub) {
		return true
	} else {
        // subはそのまま
		return subTree(tree.Left, sub) || subTree(tree.Right, sub)
	}
}
",/Users/mbp/workspace/sandbox/algo/binary-tree/sub-tree.go
"func matchTree(a, b *Node) bool ","func matchTree(a, b *Node) bool {
	if a == nil && b == nil {
		return true
	} else if a == nil || b == nil {
		return false 
    }
    // a, bはnilではない
	return a.Value == b.Value && matchTree(a.Left, b.Left) && matchTree(a.Right, b.Right)
}
",/Users/mbp/workspace/sandbox/algo/binary-tree/sub-tree.go
2分木におけるsub treeのnodeの和がK,"func sumK(n *Node, k int) {
	var dfs func(*Node) int
	dfs = func(n *Node) int {
		if n == nil {
			return 0
		}
        v := n.Value + dfs(n.Left) + dfs(n.Right)
        if v == k {
            fmt.Println(n)
        }
		return v
	}
	dfs(n)
}
",/Users/mbp/workspace/sandbox/algo/binary-tree/sum-k.go
異なるn個のn個以下の組み合わせ,"func allSubsets(A []int) [][]int {
	var dfs func(int) [][]int
	dfs = func(i int) [][]int {
		if i == len(A) {
			return [][]int{{}}
		} else {
			var a [][]int
			for _, b := range dfs(i + 1) {
				a = append(a, b)
				a = append(a, append([]int{A[i]}, b...))
			}
			return a
		}
	}
	return dfs(0)
}
",/Users/mbp/workspace/sandbox/algo/cases/all-subsets.go
異なるn個のn個以下の組み合わせ,"comb :: Num a => [a] -> [[a]]
comb = go where
  go [] = [[]]  -- WARN: go [] = []
  go (x:xs) = go xs ++ [x:ys|ys<-go xs]
",/Users/mbp/workspace/sandbox/algo/cases/all-subsets.hs
集合直積 (異なる要素を持つ集合から１つずつ選んだ場合の組み合わせ),"func cartesianProduct(A [][]int) [][]int {
	var dfs func(int) [][]int
	dfs = func(i int) [][]int {
		if i == len(A) {
			return [][]int{{}} // NO [][]int{}
		} else {
			var a [][]int
            for _, b := range A[i] {
                for _, c := range dfs(i+1) {
                    // a = append(a, append(c, b))
                    a = append(a, append([]int{b}, c...))
                }
            }
			return a
		}
	}
	return dfs(0)
}
",/Users/mbp/workspace/sandbox/algo/cases/cartesian-product.go
集合直積 (異なる要素を持つ集合から１つずつ選んだ場合の組み合わせ),"f :: [[Int]] -> [[Int]]
f = go where
 go [] = [[]]
 go (xs:xss) = [x:ys | x<-xs, ys<-go xss] 
",/Users/mbp/workspace/sandbox/algo/cases/cartesian-product.hs
異なるn個からr個取り出す組み合わせ(nCr),"func comb(A []int, N int) [][]int {
	var dfs func(int, int, []int) [][]int
	dfs = func(i, n int, acc []int) [][]int {
		if n == 0 {
			return [][]int{acc}
		} else if i == len(A) {
			return [][]int{}
		} else {
			var a [][]int // Cと違いheapに作られるので関数が終了しても参照可能
            // appendは局所的に破壊的な操作にならない
			a = append(a, dfs(i+1, n-1, append(acc, A[i]))...)
			a = append(a, dfs(i+1, n, acc)...)
			return a
		}
	}
	return dfs(0, N, []int{})
}
",/Users/mbp/workspace/sandbox/algo/cases/combination.go
異なるn個からr個取り出す組み合わせ(nCr),"comb :: (Num a) => [a] -> Int -> [[a]]
comb = go where
  go _ 0      = [[]]  -- 先頭に記述すること
  go [] _     = []
  go (x:xs) n = [x:ys | ys <- go xs (n-1)] ++ go xs n
",/Users/mbp/workspace/sandbox/algo/cases/combination.hs
異なるn個からr個取り出す組み合わせ(nCr),"func nCr(N, R int) int {
    dp := make([]int, N + 1)
    for n := 0; n <= N; n++ {
        for r := N; r > 0; r-- {  // 逆順にするとr-1が上書きされない!
            dp[r] += dp[r-1] // be careful of overflow
        }
        dp[0] = 1
    }
    return dp[R]
}
",/Users/mbp/workspace/sandbox/algo/cases/nCr.go
nCr,"comb :: (Integral a) => a -> a -> a
comb n r
  | r == 0 || n == r = 1
  | 0 <= r && r <= n = comb (n-1) r + comb (n-1) (r-1)
",/Users/mbp/workspace/sandbox/algo/cases/nCr.hs
repeated Combination (nHr),"h = go where
  go xs 0 = [[]]
  go [] _ = []  -- fail
  go (x:xs) n = [x:ys | ys <- go (x:xs) (n-1)]  ++ go xs n
",/Users/mbp/workspace/sandbox/algo/cases/nHr.hs
repeated Permutation 重複順列 (nPIr),"p :: (Num a) => [a] -> Int -> [[a]]
p = go where
  go xs 0 = [[]]
  go xs n = [x:ys | x <- xs, ys <- go xs (n-1)]
",/Users/mbp/workspace/sandbox/algo/cases/nPIr.hs
異なるn個の中からr個並べる場合の数(nPr),"func nPr(A []int, r int) [][]int {
	a := [][]int{}
	var dfs func(n int)
	dfs = func(n int) {
		if n == r {
			b := make([]int, len(A))  // copyではサイズを前もって指定
			copy(b, A)
			a = append(a, b)
		} else {
			// n=0なら、左端に全ての要素をswap移動. n=1はそれ以外を移動...
			for i := n; i < len(A); i++ {
				// swapは破壊的 <=> appendは破壊的でない. ゆえに並列化しづらい???
				A[i], A[n] = A[n], A[i]
				dfs(n + 1)
				A[i], A[n] = A[n], A[i]
			}
		}
	}
	dfs(0)
	return a
}
",/Users/mbp/workspace/sandbox/algo/cases/nPr.go
異なるn個の中から、r個並べる場合の数(nPr),"permutation :: (Num a, Eq a) => [a] -> Int -> [[a]]
permutation = go [] where
  go acc _ 0  = [acc]
  go acc [] _ = []  -- fail
  go acc xs n = concatMap (\(y, ys) -> go (y:acc) ys (n-1)) $ split xs
-- 何を今までに使用したか判別するのが、多分難しい
-- [1,2,3] => [(1, [2,3]), (2, [1,3]), (3, [1,2])] のように分割
split :: [a] -> [(a, [a])]
split = go [] where
  go acc []     = []
  go acc (x:xs) = [(x, acc++xs)] ++ go (x:acc) xs
",/Users/mbp/workspace/sandbox/algo/cases/nPr.hs
func (n *Node) Root() *Node ,"func (n *Node) Root() *Node {
	if n.Parent == nil {
		return n
	}
	return n.Parent.Root()
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) String() string ,"func (n *Node) String() string {
	v := ""("" + fmt.Sprintf(""%d[%d]"", n.Value, n.height)
	if n.Left != nil {
		v += "" "" + n.Left.String()
	} else {
        v += "" L""
    }
	if n.Right != nil {
		v += "" "" + n.Right.String()
	} else {
        v += "" R""
    }
	v += "")""
	return v
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Height() int { // accept null,"func (n *Node) Height() int { // accept null
    if n != nil {
        return n.height
    }
    return 0
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Min() int ,"func (n *Node) Min() int {
    // n = n.Root()
    for n.Left != nil {
        n = n.Left
    }
    return n.Value
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Max() int ,"func (n *Node) Max() int {
    // n = n.Root()
    for n.Right != nil {
        n = n.Right
    }
    return n.Value
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) LeftChild() bool ,"func (n *Node) LeftChild() bool {
	return n.Parent != nil && n == n.Parent.Left
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) RightChild() bool ,"func (n *Node) RightChild() bool {
	return n.Parent != nil && n == n.Parent.Right
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func FromSlice(slice []int) *Node ,"func FromSlice(slice []int) *Node {
	return fromSlice(slice, 0, nil)
}
func fromSlice(slice []int, i int, p *Node) *Node {
	if i >= len(slice) {
		return nil
	}
	n := &Node{Value: slice[i]}
	n.Parent = p
	n.Left = fromSlice(slice, i*2+1, n)  // 0(p) -> 1(c)
	n.Right = fromSlice(slice, i*2+2, n) // 0(p) -> 2(c)
	return n
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Get(v int) *Node ,"func (n *Node) Get(v int) *Node {
    if n == nil {
        return nil
    } else if v ==  n.Value {
        return n
    } else if v < n.Value {
        return n.Left.Get(v)
    } else {
        return n.Right.Get(v)
    }      
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Insert(v int) *Node ,"func (n *Node) Insert(v int) *Node {
    var p *Node
    for n != nil {
        p = n
        if v < n.Value {
            n = n.Left
        } else if v > n.Value {
            n = n.Right
        } else {
            return n
        }
    }
    new := New(v)
    new.Parent = p
    if p != nil {
        if v < p.Value {
            p.Left = new
        } else {
            p.Right = new
        }
    }
    return new
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Remove(v int) ,"func (n *Node) Remove(v int) {
    n = n.Get(v)
    if n == nil {
        return
    } else if n.Left == nil {
        if n.Right == nil {
            if n.Parent == nil {
                fmt.Println(""hogeeeeeeeeee"")
            } else if n.LeftChild() {
                n.Parent.Left = nil
            } else {
                n.Parent.Right = nil
            }
        } else {
            n.Swap(n.Right)
        }
    } else if n.Right == nil {
        n.Swap(n.Left)
    } else {
        next := n.Right.Min()
        n.Value = next
        n.Right.Remove(next)
    }
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) UpdateHeight() ,"func (n *Node) UpdateHeight() {
	n.height = max(n.Left.Height(), n.Right.Height()) + 1
}
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) Swap(c *Node) { // child,"func (n *Node) Swap(c *Node) { // child
    if n.Parent != nil {
        if n.LeftChild() {
            n.Parent.Left = c
        } else {
            n.Parent.Right = c
        }
        c.Parent = n.Parent
        n.Parent = nil // memory leak???
    } else {
        c.Parent = nil
        n.Parent = c
    }
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) AppendLeft(x *Node) ,"func (n *Node) AppendLeft(x *Node) {
    n.Left = x
    if x != nil {
        x.Parent = n
    }
}
func (n *Node) AppendRight(x *Node) {
    n.Right = x
    if x != nil {
        x.Parent = n
    }
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) RotateR() *Node ,"func (n *Node) RotateR() *Node {
    // a < x < b < y c < z < d
    // ((a x b) y (c z d)) => ((_ a _) x (b y (c z d)))
    // ((a R2 b) R1 c) => (a R2 (b R1 c)) の場合、黒の経路数変わらず
    // ((a R b) B c) => (a R (b B c)) の場合、aの経路においてBが一つ減る
    // => (a B (b R c)) と入れ替えることで、a側1つ増え, c側そのまま, bも変わらず
	if n != nil && n.Left != nil {
		l := n.Left
		lr := l.Right
        n.Swap(l)
        l.AppendRight(n)
        n.AppendLeft(lr)
        n.UpdateHeight()
        l.UpdateHeight()
		return l
	}
	return nil
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
func (n *Node) RotateL() *Node ,"func (n *Node) RotateL() *Node {
    // a < x < b < y c < z < d
    // ((a x b) y (c z d)) => (((a x b) y c) z (_ d _))
	if n != nil && n.Right != nil {
		r := n.Right
		rl := r.Left
        n.Swap(r)
        r.AppendLeft(n)
        n.AppendRight(rl)
        n.UpdateHeight()
        r.UpdateHeight()
		return r
	}
	return nil
}
",/Users/mbp/workspace/sandbox/algo/common/btree.go
type Graph struct ,"type Graph struct {
	N int
	E [][]int
}
// matrix / list / class のうちの listパターン
func NewGrash(x []int, y []int, N int) *Graph {
	E := make([][]int, N)
	for i := 0; i < len(x); i++ {
		E[x[i]] = append(E[x[i]], y[i])
	}
	return &Graph{N: N, E: E}
}
",/Users/mbp/workspace/sandbox/algo/common/graph.go
type MatrixGraph struct ,"type MatrixGraph struct {
	N int
	W [][]int
    MaxWeight int
}
func NewWeighGraph(x, y, w []int, N int) *MatrixGraph {
    // 疎行列には向かないデータ構造
	W := make([][]int, N)
	for i := 0; i < N; i++ {
		W[i] = make([]int, N) // もっと良い方法は?
        for j := 0; j < N; j++ {
            W[i][j] = math.MaxInt32 // 移動不可
        }
	}
    for i := 0; i < len(x); i++ {
        W[x[i]][y[i]] = w[i]
        // W[y[i]][x[i]] = w[i]
    }
	return &MatrixGraph{N: N, W: W, MaxWeight: math.MaxInt32}
}
func NewWeighGraphFromMatrix(w [][]int) *MatrixGraph {
	return &MatrixGraph{N: len(w), W: w, MaxWeight: math.MaxInt32}
}
func (g *MatrixGraph) Neighbor(node int) []int {
    n := []int{}
    for i := 0; i < g.N; i++ {
        if w := g.W[node][i]; w != g.MaxWeight {
            n = append(n, i)
        }
    }
    return n
}
",/Users/mbp/workspace/sandbox/algo/common/graph.go
お釣りの問題(最小となる支払い方法),"func changeMoney(coins []int, sum int) int {
	dp := make([]int, sum+1) // dp[s]は、sまで行くのに必要なコインの最小枚数(各コインのスナップショット)
    for i := 0; i < sum+1; i++ {
        dp[i] = math.MaxInt32
    }
    dp[0] = 0
	for i := len(coins) - 1; i >= 0; i-- {
		for s := sum; s > 0; s-- {
            // knapsackとは異なり、失敗する場合がある(==なので条件が厳しい)
            for n := 1; ; n++ { // コインの枚数
                prev := s - coins[i]*n
                if prev < 0 {
                    break
                }
                if prev >= 0 && dp[prev] != math.MaxInt32 { // 手前のコインから遷移できる条件
                    if m := dp[prev] + n; dp[s] > m {
                        dp[s] = m
                    }
                }
            }
		}
        // fmt.Println(dp)
	}
    return dp[sum]
}
",/Users/mbp/workspace/sandbox/algo/dp/change-money.go
お釣りの問題(支払い方法全て),"solve :: [Int] -> Int -> [[Int]]
solve [] sum = [[]]
-- coinsは降順ソート
solve (c:coins) csum = concatMap (g . f) [0 .. (div csum c)]
  where
    -- xは、cにおける使用するコインの枚数
    -- fは、c:coinsにおける使用するコインのリストを返す
    f x = map ((take x (repeat c)) ++) (solve coins (csum - c * x))
    g = filter (\a-> sum a == csum)
",/Users/mbp/workspace/sandbox/algo/dp/change-money.hs
circusTower (身長、体重) がそれぞれ下にいる人よりも小さくなることを制限として、最も長い人タワーを作る時の組み合わせ,"type Pair struct {
	height int
	width  int
}
func circusTower(A []Pair) []Pair {
	sort.Slice(A, func(i, j int) bool {
        if A[i].height < A[j].height {
            return true
        } else if A[i].height == A[j].height {
            return A[i].width < A[j].width
        } else {
            return false
        }
    })
	var dfs func(int) []Pair
	dfs = func(i int) []Pair {
		if i == len(A) {
			return []Pair{}
		} else {
			var humans []Pair
			h1, w1 := A[i].height, A[i].width
			for j := i + 1; j < len(A); j++ {
				h2, w2 := A[j].height, A[j].width
				if h1 < h2 && w1 < w2 {
					if h := dfs(j); len(humans) < len(h) {
						humans = h
					}
				}
			}
			humans = append(humans, A[i])
			return humans
		}
	}
	return dfs(0)
}
",/Users/mbp/workspace/sandbox/algo/dp/circus-tower.go
"func solve(sizes, prices []int, capacity int) int ","func solve(sizes, prices []int, capacity int) int {
	dp := make([]int, capacity + 1)
    // (price, size) = (0, 無限) でどこからでも一つ前から移動できることが前提
	for s := 0; s < len(sizes); s++ {
		for c := capacity; c >= sizes[s]; c-- { // 再利用ができるのは、i=>i+1へ単純に値を渡している場合.
            // c-size[s]とcより小さい値を使っているので逆順の必要あり
			dp[c] = max(dp[c], dp[c-sizes[s]] + prices[s]) // sを使う使わないの2通り
		}
	}
	return dp[capacity]
}
",/Users/mbp/workspace/sandbox/algo/dp/knapsack.go
"knapsack :: (Ord a, Num a) => [(a, a)] -> a -> a","knapsack :: (Ord a, Num a) => [(a, a)] -> a -> a
-- pairs = [(size, price)] (逆方向)
knapsack pairs size = go pairs size where
    go [] size = 0
    go ((s,p):sps) size =
      let
        ssize = size - s
        cap1 = go sps size  -- 現在の(s, p)を使わない
        cap2 = if ssize >= 0 then p + go sps ssize else 0
      in maximum [cap1, cap2]
main = print $ knapsack [(x, 6-x) |x <- [1..5]] 6
",/Users/mbp/workspace/sandbox/algo/dp/knapsack.hs
繰り返し二乗法(bottom up),"func pow(a, n int) int {
    // 下位ビットから、x^iを掛ける/掛けないをすることでも行き先を決めることができる！
    // 2^6 = (2^2 * 2^2) * (2^1 * 2^1) (正しい遷移)
    // この考え方に釣られると、pow(x, n) = pow(x * x, n / 2) * x
    // 2^6 = (2^3 * 2^3) * 2^1  (再帰的ではあるが、この場合は間違った遷移となる)
    x := 1
    for n > 0 {
        if (n & 1 == 1) {
            x *= a
        }
        // 以下のように増加(2進数と対応付け) 9 = 8 + 1なので 2^9 == a^8 * a
        // a^16 a^8 a^4 a^2 a
        a = a * a
        n = n >> 1
    }
    return x
}
",/Users/mbp/workspace/sandbox/algo/dp/pow.go
,"pow' :: Int -> Int -> Int
pow' a 0 = 1
pow' a n = case n `mod` 2 of
  0 -> let x = pow' a (n `div` 2) in x * x
  _ -> let x = pow' a ((n-1) `div` 2) in x * x * a
",/Users/mbp/workspace/sandbox/algo/dp/pow.hs
"func AddEachDigitOf2Lists(list1, list2 []int) []int","func AddEachDigitOf2Lists(list1, list2 []int) []int{
	carry := 0
	length := max(len(list1), len(list2))
	out := make([]int, length)
	for i := 0; i < length; i++ {
		a, b := 0, 0
		if (i < len(list1)) {
			a = list1[i]
		}
		if (i < len(list2)) {
			b = list2[i]
		}
		sum := a + b + carry
        out[i] = sum % 10
		// next state
		carry = 0
		if sum >= 10 {
			carry = 1
		}
	}
	if (carry == 1) {
		out = append(out, 1)
	}
	return out
}
",/Users/mbp/workspace/sandbox/algo/famous/AddEachDigitOf2Lists.go
type Bit struct ,"type Bit struct {
	data []int
	size int
}
func NewBit(size int) *Bit {
	b := &Bit{size:size}
	b.data = make([]int, size)
	return b
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
func (b *Bit) read (idx int) int ,"func (b *Bit) read (idx int) int {
	sum := 0
	for idx > 0 {
		sum += (*b).data[idx]
		idx -= idx & -idx
	}
	return sum
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
"func (b *Bit) update (idx, value int) ","func (b *Bit) update (idx, value int) {
    /*
     * idx == 0の場合は1のbitがないので
     * 常に0のままになる
     * そのため、idx >= 1が条件
     */
	if idx == 0 { return }
	for idx <= (*b).size {
		(*b).data[idx] += value
		idx += idx & -idx
	}
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
BIT(Binary Indexed Tree)とは,"a1からanまでの総和をlog(n)で求めることができるデータ構造
```
____________1000____________
________0100
____0010        ____0110
0001    0011    0101    0111
```
",/Users/mbp/workspace/sandbox/algo/famous/bit.md,,
func findConsecutiveSegments(s []int) string ,"func findConsecutiveSegments(s []int) string {
    return loop(s, nil, nil)
}
func loop(s []int, start, prev *int) string {
    format := func () string {
        if start == nil || prev == nil {
            return """"
        } else if *start == *prev {
			return fmt.Sprintf(""%d"", *start)
		} else {
			return fmt.Sprintf(""%d-%d"", *start, *prev)
		}
    }
	if len(s) == 0 {
		return format() + ""\n""
    } else if prev == nil {
        return loop(s[1:], &s[0], &s[0])
    } else if s[0] - 1 == *prev { // nextだとs[0] + 1 == s[1]であるが、上手くいかないっぽい
        return loop(s[1:], start, &s[0])
    } else {
		return format() + "", "" + loop(s[1:], &s[0], &s[0])
	}
}
",/Users/mbp/workspace/sandbox/algo/famous/findConsecutiveSegments.go
"def f(lines, pattern, N):","def f(lines, pattern, N):
 queue = []
 n = 0
 for line in lines:    
  if pattern in line:
   while queue:
    print(queue.pop(0))
   print(line)
   n = N
  elif n > 0:
   print(line)
   n -= 1
  else:
   queue.append(line)
   if len(queue) > N:
    queue.pop(0)
f(""1 p 3 2 1 4 3 3 4"".split(), ""3"", 1); print("""")
f(""1 p 3 2 1 4 3 3 4"".split(), ""3"", 2); print("""")
f(""1 p 3 2 1 4 3 3 4"".split(), ""2"", 2); print("""")
",/Users/mbp/workspace/sandbox/algo/famous/grep.py
"func hanoi(n int, src, buf, dst *Hanoi) ","func hanoi(n int, src, buf, dst *Hanoi) {
	/*
	   前提: 合計は、常にN個の要素
	   3つのオブジェクトを同時に操作(参照を共有して破壊的操作を行う)
	   n個のsrcをbufを用いてdstに移動させる(interface)
	   引数に渡すオブジェクトは、それぞれ大小関係を満たしているものとする
	   全てにおいてハノイの大小関係を全ての操作で満たす必要あり
	*/
	if n > src.Size() {
		panic(""you can not move"")
	}
	if n > 0 {
		hanoi(n-1, src, dst, buf) // この関数が返ると、bufにn-1個移したことになる
		dst.Push(src.Pop())       // src = src[:len(src)-1]は不可. 呼び出し元の変数の値を更新
		fmt.Println(n, src, buf, dst)
		hanoi(n-1, buf, src, dst)
	}
}
// 実体を書き換えないといけない
type Hanoi struct {
	data []int
}
",/Users/mbp/workspace/sandbox/algo/famous/hanoi.go
"paging :: Int -> Int -> Int -> (Int, Int)","paging :: Int -> Int -> Int -> (Int, Int)
-- 幅(width) (ページ数は常に一定) == 2 * diff + 1 == 右端 - 左端 + 1  (右端>左端)
paging = go 0 where
  go first diff cur last
        | not $ (first <= cur) && (cur <= last) = error ""bad args""
        | (last - first + 1) <= 2 * diff + 1 = (first, last)  -- 幅が十分大きい場合
        | cur - diff < first = (first, first + 2 * diff)
        | last < cur + diff  = (last - 2 * diff, last)
        | otherwise = (cur - diff, cur + diff)  -- [現在-幅, 現在+幅]  -- それぞれの端が[first, last]をはみ出ないのが条件
paging2 = paging 2  -- diff == 2
main = do
  mapM_ (\x -> (putStr . show) x >> (print $ paging2 x 10)) [0..10]
",/Users/mbp/workspace/sandbox/algo/famous/paging.hs
solve :: Int -> [[Int]],"solve :: Int -> [[Int]]
solve boardSize = go [] where
  go queens = if length queens == boardSize
              then [queens]
              else concatMap (go . flip (:) queens) $ filter f [0 .. (boardSize - 1)]
    where
      f x = not $ elem x queens || canAttack x queens
canAttack :: Int -> [Int] -> Bool
canAttack x queens = go queens 0 where
  go [] _ = False
  go (q:queens) n = q == x + (n + 1) || q == x - (n + 1) || go queens (n + 1)
",/Users/mbp/workspace/sandbox/algo/famous/queen.hs
Queen,"# 全ての駒を斜め上(左右両方)に移動させる。枠から出てもよい
from itertools import permutations
n = 4
queens = range(n)
for pos in permutations(queens):
    if (n == len(set(pos[i] + i for i in queens))
          == len(set(pos[i] - i for i in queens))):
        print pos
",/Users/mbp/workspace/sandbox/algo/famous/queen.py
人に見やすいフォーマットに変換,"func showHuman(n int) string {
	if n < 0 {
		return ""-"" + showHuman(-1*n)
	}
	toSting := func(unit int, label string) string {
		return fmt.Sprintf(""%.2f%sB"", float64(n)/float64(unit), label)
	}
	for i, label := range []string{"""", ""K"", ""M"", ""G"", ""T"", ""P"", ""Z""} {
		start := pow(10, (3 * i))
		end := pow(10, (3 * (i + 1))) // end = start * (10 ** 3)
		if start <= n && n < end {
			return toSting(start, label)
		}
	}
	return toSting(1, """")
}
",/Users/mbp/workspace/sandbox/algo/famous/show-human.go
curry,"((a,b) -> c) -> a -> b -> c 
f (x, y) = curry f x y

",/Users/mbp/workspace/sandbox/algo/fp/README.md,,
uncurry,"(a -> b -> c) -> (a, b) -> c
f x y = uncurry f (x, y)

",/Users/mbp/workspace/sandbox/algo/fp/README.md,,
(define (choose choices),"(define (choose choices)
  (if (null? choices)
      (try-again)
      (call/cc
       (lambda (cc)
         (set! *alternatives*
               (cons
                (lambda ()
                  (cc (choose (cdr choices))))
                *alternatives*))
                  (car choices)))))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
(define try-again #f),"(define try-again #f)
(define *alternatives* '())
(call/cc
 (lambda (cc)
   (set! try-again
         (lambda ()
           (if (null? *alternatives*)
               (cc '(there are no more values))
               (let ((next (car *alternatives*)))
                 (set! *alternatives* (cdr *alternatives*))
                 (next)))))))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:amb,"(define (amb . choices)
    (choose choices))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:try-againのサンプル,";; (test*
;;  ""try-again * 3""
;;  '(3 a)
;;  (begin
;;    (let ((x (amb 1 2 3))
;;          (y (amb 'a 'b)))
;;      (list x y))
;;    (try-again)
;;    (try-again)
;;    (try-again)
;;    )
;; )
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:require,"(define (require p)
  (if (not p) (amb)))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:requireのサンプルコード,"(test*
 ""triangle""
 '(3 4 5)
 (let ((x (amb 1 2 3 4 5))
       (y (amb 1 2 3 4 5))
       (z (amb 1 2 3 4 5)))
   (require (= (+ (* x x) (* y y)) (* z z)))
   (list x y z))
 )
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
"[1,2,3] => [[1,2,3],[2,3],[3],[]]","  print $ (scanr (:) []) [1..3]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[1,2,3] => [[1,2,3],[2,3],[3],[]]","  print $ reverse $ (scanl (flip (:)) []) (reverse [1..3])
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[1,2,3] => [[1,2,3],[2,3],[3]]","  print $ scanr1 (++) $ map (:[]) [1..3] -- scanr1は各要素と戻り値の型が同一でないと使えない
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[1..10]=>[2,4,6,8,10,1,3,5,7,9]","  print $ (uncurry (++) . partition even) [1..10]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[-5..5]=>[0,1,2,3,4,5,-5,-4,-3,-2,-1]","  print $ (uncurry (flip (++)) . break (>=0)) [-5..5]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
[1..10]=>偶数だけ取り出す=>1加算=>Sum,"  -- (.)は、引数が一つだけの関数を連結するときに使用できる
  print $ (foldl (+) 0 . map (+1) . filter even) [1..10]  -- 35
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[Left1,Right2,Left3]=>[1,3]","  print $ [x | (Left x) <- [Left 1, Right 2, Left 3]]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[1..3]=>[Just1,Just2,Just3]","  print $ map Just [1..3]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
"[1..5]=>[[1..5],[2..5],[3,4,5],[4,5],[5],[]]","  print $ let xs = [1..5] in map (flip drop xs) [0..length xs]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
[a]==[a](uncurry使う),"  -- uncurryは、２タプルの１結果を２引数の関数に適用するのに使う
  print $ uncurry (++) (splitAt 1 [1..5])
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
:Q:チャーチ数0,"; 0 := λ f x . x
(define zero (lambda(f) (lambda(x) x)))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
:Q:チャーチ数1,"; 1 := λ f x . f x
(define one  (lambda(f) (lambda(x) (f x))))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
:Q:チャーチ数2,"; 2 := λ f x . f f x
(define two  (lambda(f) (lambda(x) (f (f x)))))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
:Q:チャーチ数から整数への変換する関数,"; 関数 toInt は数字を表現する関数を受け取り、0 を引数として1を加算する関数を渡します。
; 数字を表現する関数がその数字の回数だけ1を加算します
(define toInt (lambda(n) ((n (lambda(x)(+ x 1))) 0)))
(test* ""zero"" 0 (toInt zero))
(test* ""one""  1 (toInt one))
(test* ""two""  2 (toInt two))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
(define (fact/cps n cont),"(define (fact/cps n cont)
; mは(fact (- n 1))の結果が来る
; (cont XXX)とするとXXXが(fact/cps n cont)の戻り値となる.
  (if (= n 1)
      (cont 1)
      (fact/cps (- n 1) (lambda (m) (cont (* n m))))))
(test* ""(fact/cps 1)""  1   (fact/cps 1 values))
(test* ""(fact/cps 10)"" 120 (fact/cps 5 values))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (fib/cps n k),"(define (fib/cps n k)
  (cond ((= n 0) (k 0))
        ((= n 1) (k 1))
        (else
         (fib/cps (- n 1)
                  (lambda (r1)
                    (fib/cps (- n 2) (lambda (r2)
                                       (k (+ r1 r2)))))))))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (flatten/cps tree k),"(define (flatten/cps tree k)
  (cond ((null? tree) (k '()))
        ((pair? tree)
         (flatten/cps (car tree)
                      (lambda (r1)
                        (flatten/cps
                         (cdr tree)
                         (lambda (r2) (k (append r1 r2)))))))
        (else (k (list tree)))))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (leaf-count/cps tree k),"(define (leaf-count/cps tree k)
  (if (pair? tree)
      (leaf-count/cps (car tree) (lambda (n)
                        (leaf-count/cps (cdr tree) (lambda (m) (k (+ n m))))))
      (k 1)))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (even-odd? x),"(define (even-odd? x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n) (if (= n 0) #t (od? ev? od? (- n 1))))
   (lambda (ev? od? n) (if (= n 0) #f (ev? ev? od? (- n 1))))))
(print (even-odd? 10))  ; #t
(print (even-odd? 11))  ; #f
",/Users/mbp/workspace/sandbox/algo/fp/y/even-odd.scm
:Q:不動点とは,"; fixed point combinator f(x)=xを満たすxの事
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
:Q:fact-Y-combinator,"(define fact
  (lambda (f)
    (lambda (n)
      (if (= n 0) 1 (* n (f (- n 1)))))))
(define Y
  (lambda (f)
    ((lambda (x) (f x x))
     (lambda (x) (f x x)))))
;; (define Y
;;   (lambda (f)
;;     ((lambda (x) (x x))
;;      (lambda (x) (f (lambda (y) ((x x) y)))))))
(define factorial (Y fact))
(print (factorial 5))  ; 120
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
:Q:(Lx.(x+1))1の意味,"; xは引数で、(x+1)は戻り値、1は実引数でx=1
; (Lx.x+1)1=>(1+1)=>2 (実引数を適用するとLも除外)
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
:Q:FixedPointCombinators,"; Y = Lf.(Lx.f(x x)) (Lx.f(x x)) とおくと
; Y g = (Lf.(Lx.f(x x)) (Lx.f(x x))) g
; = (Lx.g(x x)) (Lx.g(x x))  ; これが繰り返し現れる
; = g((Lx.g(x x)) (Lx.g(x x)))
; = g (Y g)
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
ZCombinator,"; λf.(λx.f(λy.xxy))(λx.f(λy.xxy))
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
; inner関数がなくても、lambdaで内部関数定義できる,"; inner関数がなくても、lambdaで内部関数定義できる
(define fib
  (lambda (n)
    ((lambda (f) (f f n))
     (lambda (self a)
       (cond ((= a 0) 0)
             ((= a 1) 1)
             (else (+ (self self (- a 1))
                      (self self (- a 2)))))))))
(print (fib 10))  ; 55
",/Users/mbp/workspace/sandbox/algo/fp/y/fib.scm
graph for a star,"type Graph struct {
    N int
    Nodes [][]*Node
}
type Node struct {
    graph *Graph
    p Point
    parent *Node // the previous path from this Node
    cost int // total cost from start to this node (暫定)
    score int // cost[current] + weight(current, next) + h(next, goal) (暫定)
    visited bool // Close (List)
",/Users/mbp/workspace/sandbox/algo/graph/a-star.go
Neighbor for a star,"func (n *Node) Neighbor() []*Node {
    N := n.graph.N
    ns := []*Node{}
    for _, d := range [][]int{{1,0}, {0,1},{-1, 0},{0, -1}}{
        dx, dy := d[0], d[1]
        x, y := n.p.x + dx, n.p.y + dy
        if 0 <= x && x < N && 0 <= y && y < N {
            if next := n.graph.Nodes[x][y]; !next.isWall {
                ns = append(ns, next)
            }
        }
    }
    return ns
}
func (n *Node) Cost(to *Node) int {
    return 1
}
type Point struct {
    x int
    y int
}
",/Users/mbp/workspace/sandbox/algo/graph/a-star.go
"func aStar(g *Graph, start, goal *Node) int ","func aStar(g *Graph, start, goal *Node) int {
    // 現在のnodeから隣接ノードのコストを計算. 最小コストを次の現在のnodeにする (dijkstra)
    // ただしこのコストは、そのノードからゴールまでの見積もりも含めたもの (= score)
    h := func (p1, p2 Point) int { // ゴールまでのコストを暫定的に見積もる関数
        return abs(p1.x - p2.x) + abs(p1.y - p2.y)
    }
    start.cost = 0
    pq := &Heap{start} // Open List
    heap.Init(pq)
    for pq.Len() != 0 {
        p := heap.Remove(pq, 0).(*Node)
        p.visited = true
        if p == goal {
            return goal.cost
        }
        for _, next := range p.Neighbor() {
            c := p.Cost(next) + p.cost
            s := c + h(next.p, goal.p)
            if !next.visited && s < next.score {
                next.parent = p
                next.score = s
                next.cost = c
                heap.Push(pq, next)
            }
        }
    }
    return -1
}
",/Users/mbp/workspace/sandbox/algo/graph/a-star.go
func BellmanFord(start int) ,"func BellmanFord(start int) {
    N := 10
    // d[j] = min { d[i] + cost(i,j) | e(i,j) in E}
    // 負の閉回路があるならば、閉回路を無限に通過することで、最短距離は存在しない.
    d := make([]int, N)
    for i := 0; i < N; N++ {
        d[i] = 1 << 30
    }
    d[start] = 0
    for 
}
",/Users/mbp/workspace/sandbox/algo/graph/bellman–ford.go
dijkstraとは?,"// 全てのエッジのコストが 0 以上であること
// 現在のnodeから隣接ノードのコストを計算. 最小コストを次の現在のnodeにする
",/Users/mbp/workspace/sandbox/algo/graph/dijkstra.go
"func dijkstra(g *MatrixGraph, start int) []int ","func dijkstra(g *MatrixGraph, start int) []int {
	pq := &Heap{&item{index: start, cost: 0}}
	heap.Init(pq)
	visited := make([]bool, g.N)
	costs := make([]int, g.N) // total costs from start to each node
	for i := 0; i < g.N; i++ {
		costs[i] = g.MaxWeight
	}
	costs[start] = 0
	for pq.Len() != 0 {
		itm := heap.Remove(pq, 0).(*item)
        n := itm.index
		visited[n] = true
		for _, next := range g.Neighbor(n) {
			c := costs[n] + g.W[n][next]
			if !visited[next] && c < costs[next] {
				costs[next] = c
				heap.Push(pq, &item{index: next, cost: c}) // 存在確認した方が良い?
			}
		}
	}
	return costs
}
",/Users/mbp/workspace/sandbox/algo/graph/dijkstra.go
:Q:wfloydの特徴,"マイナスを含んだ重み付き有向グラフの全ペアの最短経路問題
",/Users/mbp/workspace/sandbox/algo/graph/floyd.go
"func floyd(N int, x, y, z []int) [][]int ","func floyd(N int, x, y, z []int) [][]int {
	a := make([][]int, N) // 0とINFの初期化必須
	for i := 0; i < N; i++ {
		a[i] = make([]int, N)
		for j := 0; j < N; j++ {
			if i == j {
				a[i][j] = 0
			} else {
                // 1 << 30にすると配列の計算でoverflowするので多少小さい値にすること
				a[i][j] = 1 << 20
			}
		}
	}
	for i := 0; i < len(x); i++ {
		a[x[i]][y[i]] = z[i]
	}
	for k := 0; k < N; k++ {
		for i := 0; i < N; i++ {
			for j := 0; j < N; j++ {
				if a[i][j] > a[i][k] + a[k][j] {
					a[i][j] = a[i][k] + a[k][j]
				} 
			}
		}
	}
	return a
}
",/Users/mbp/workspace/sandbox/algo/graph/floyd.go
"func Kruskal(edges []*Edge, N int) int ","func Kruskal(edges []*Edge, N int) int {
    // グラフのノード数がNなら、全域木の辺の数はN-1本
    // 最小全域木は、全域木を構成する辺のコストの総和が最小(Treeなので閉回路にならない)
    // グラフの辺をコストが小さい順に閉路を作らないよう貪欲に選択
    uf := NewUnionFind(N)
    sort.Slice(edges, func(i, j int) bool {
        return edges[i].cost < edges[j].cost
    })
    sum := 0
    for _, e := range edges {
        if !uf.IsSame(e.from, e.to) {
            fmt.Println(e.from, "" => "", e.to)
            sum += e.cost
            uf.Union(e.from, e.to)
        }
    }
    return sum
}
",/Users/mbp/workspace/sandbox/algo/graph/kruskal.go
"func prim(g *MatrixGraph, start int) int ","func prim(g *MatrixGraph, start int) int {
    // 現在のMST(Minimum spanning tree)に含まれないノードのうち、最小枝を持つものをMSTに加える (貪欲)
	pq := &Heap{node{parent: start, index: start, cost: 0}}
	heap.Init(pq)
	visited := make([]bool, g.N)
	costs := make([]int, g.N) // MSTに含まれていないノードとの距離
	for i := 0; i < g.N; i++ {
		costs[i] = g.MaxWeight
	}
    sum := 0
	for pq.Len() != 0 {
		n := heap.Remove(pq, 0).(node)
		visited[n.index] = true
        sum += n.cost
		for _, next := range g.Neighbor(n.index) {
			c := g.W[n.index][next]
			if !visited[next] && c < costs[next] {
                fmt.Println(n.index, "" => "", next)
				costs[next] = c
				heap.Push(pq, node{parent: n.index, index: next, cost: c}) // 上書きすべき
			}
		}
	}
    return sum
}
",/Users/mbp/workspace/sandbox/algo/graph/prim.go
func (g *Graph) TopologicalSort() []int ,"func (g *Graph) TopologicalSort() []int {
    // DFSを実行し、行き先がなくなったものから順に、リストに格納
    // you can't sort a cyclic graph!!!
	var dfs func(n int)  // 宣言必須!
	sorted := []int {}
	visited := make([]bool, g.N)
	dfs = func (n int) {
		visited[n] = true
		for _, next := range g.E[n] {
			if ! visited[next] {
				dfs(next)
			}
		}
		sorted = append(sorted, n)
	}
	for node := 0; node < g.N; node++ {
		dfs(node)
	}
	return sorted
}
",/Users/mbp/workspace/sandbox/algo/graph/topological-sort.go
"if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X) AND if A[K] = N + 1 then operation K is max counter.","func maxCounters(A []int, N int) []int {
	c := make([]int, N)
	ma, base := 0, 0
	for i := 0; i < len(A); i++ {
		a := A[i] - 1
		if a == N {
			base = ma
		} else {
			b := c[a]
			if b < base {
				c[a] = base + 1
			} else {
				c[a] = b + 1
			}
			if ma < c[a] {
				ma = c[a] // maxは逐一更新
			}
		}
	}
	for i := 0; i < N; i++ {
		if c[i] < base {
			c[i] = base
		}
	}
	return c
}
",/Users/mbp/workspace/sandbox/algo/greedy/maxCounters.go
各一定区間内に極大値をもつよう区分,"func maxNumberGroupOfLocalMaximuns(groups int, S []bool) bool {
    N := len(S)
    if N % groups != 0 {
        panic(""N % groups == 0"")
    }
    interval := N / groups
    for cnt := 0; cnt < groups; cnt++ {
		for i := 0; i < N; i += interval {
			var last int // [i, last)で右端は含めない
			for last = i + interval; i < last; i++ {
				if S[i] {
					break
				}
			}
			if i == last {
				return false
			}
		}
	}
    return true
}
",/Users/mbp/workspace/sandbox/algo/greedy/maxNumberGroupOfLocalMaximuns.go
struct _entry ,"struct _entry {
  char *key;
  data_type data;
  struct _entry *next;
};
struct _hash_table {
  int size;
  struct _entry **table;
};
typedef struct _entry entry_t;
typedef struct _hash_table hash_table_t;
",/Users/mbp/workspace/sandbox/algo/hash/hash.c
"int get_hash(hash_table_t *table, char *key) ","int get_hash(hash_table_t *table, char *key) {
  // hash must unsigned because it is used by an index of an array
  unsigned int v = 0;
  char *p = key;
  while (*p) {
    v += *p++;
  }
  return v % table->size;
}
",/Users/mbp/workspace/sandbox/algo/hash/hash.c
"entry_t *make_entry(char *key, data_type data) ","entry_t *make_entry(char *key, data_type data) {
  entry_t *n = (entry_t *)malloc(sizeof(entry_t));
  char *k = strdup(key);
  if (n == NULL || k == NULL) {
    printf(""Out of memory"");
    exit(1);
  }
  n->key = k;
  n->data = data;
  n->next = NULL;
  return n;
}
",/Users/mbp/workspace/sandbox/algo/hash/hash.c
"entry_t *ht_search(hash_table_t *ht, char *key) {  // O(n/size * key) ()","entry_t *ht_search(hash_table_t *ht, char *key) {  // O(n/size * key) ()
  int hashvalue = get_hash(ht, key);
  for (entry_t *e = ht->table[hashvalue]; e; e=e->next) {
    // it is better to take an action here not on the callee side
    // a key can't be hashed because collision should not occur here
    // so if you use a long key, it takes a long time to compare
    if (strcmp(e->key, key) == 0)
      return e;
  }
  return NULL;
}
",/Users/mbp/workspace/sandbox/algo/hash/hash.c
"void ht_insert(hash_table_t *ht, char *key, data_type data) {  // O(n/size + key)","void ht_insert(hash_table_t *ht, char *key, data_type data) {  // O(n/size + key)
  entry_t *e = ht_search(ht, key);
  if (e == NULL) {
    // create
    int hashvalue = get_hash(ht, key);
    entry_t *n = make_entry(key, data);
    // insert at the head
    n->next = ht->table[hashvalue];
    ht->table[hashvalue] = n;
  } else {
    // update
    e->data = data;
  }
}
",/Users/mbp/workspace/sandbox/algo/hash/hash.c
"void ht_delete(hash_table_t *ht, char *key) {  // O(n/size + key)","void ht_delete(hash_table_t *ht, char *key) {  // O(n/size + key)
  entry_t *e = ht_search(ht, key);
  if (e) {
    int hashvalue = get_hash(ht, key);
    // should move this code into ht_search
    for (entry_t *e = ht->table[hashvalue], *p = NULL; e; p=e, e=e->next) {
      if (strcmp(e->key, key) == 0) {
        if (p == NULL)
          ht->table[hashvalue] = e->next;
        else
          p->next = e->next;
        free(e);
      }
    }
  } else {
    printf(""Not found key"");
    exit(1);
  }
}
",/Users/mbp/workspace/sandbox/algo/hash/hash.c
list構造,"struct _list {
  int value;
  struct _list *next;
};
typedef struct _list list_t;
list_t* init(int value){
  list_t* newNode = (list_t*) malloc(sizeof(list_t));
  if (newNode == NULL) {
    exit(1);
  }
  newNode->value = value;
  newNode->next = NULL;
  return newNode;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
void display(list_t* head),"void display(list_t* head){
  printf(""<list> "");
  if (head == NULL) {
    printf(""\n"");
    return;
  }
  list_t* n;
  for(n = head; n->next; n = n->next) // nでなくn->nextとするのがポイント
    printf(""%d,"", n->value);
  printf(""%d\n"", n->value);
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
"void append(list_t** head, int value)","void append(list_t** head, int value){
  // add an item to the last of a list O(n)
  list_t* n = init(value);
  if (*head == NULL) {
    *head = n;
  } else {
    list_t* last = *head;
    while(last->next)
      last = last->next;
    last->next = n;
  }
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
"void append1(list_t** start, list_t** end, int value)","void append1(list_t** start, list_t** end, int value){
  // add an item to the last of a list O(1)
  list_t* n = init(value);
  if (*start == NULL) {
    *start = n;
    *end = n;
  } else {
    (*end)->next = n;
    *end = n;
  }
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
"list_t* inits(int argc, ...) ","list_t* inits(int argc, ...) {
  // with append1, O(n)
  // if you use append, the complexity is O(n^2)
  if (argc <= 0)
    return NULL;
  va_list list;
  va_start(list, argc);
  // WARN: you need NULL, or sometimes it's initilized by the other value
  // NULL needs including stdio.h header
  list_t* head = NULL;
  list_t* tail = NULL;
  for (int i = 0; i < argc; i++)
    append1(&head, &tail, va_arg(list, int)); // append1関数より後に記述
  va_end(list);
  return head;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
"int elem(int value, list_t* head) ","int elem(int value, list_t* head) {
  list_t *current = head;
  while (current) {
    if (current->value == value)
      return 1;
    current = current->next;
  }
  return 0;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
list_t* unique(list_t* head) ,"list_t* unique(list_t* head) {
  list_t* current = head;
  while (current) {
    list_t* next = current->next;
    list_t* prev = current;
    while (next) {
      if (next->value == current->value) {
        prev->next = next->next;
        free(next);
        next = prev->next;
      } else {
        prev = next;
        next = next->next;
      }
    }
    current = current->next;
  }
  return head;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
// Delete the node of the argument,"// Delete the node of the argument
void deleteThis(list_t* node) {
  if (node == NULL)
    return;
  else if (node->next == NULL) {
    // the last item;
    // you need previous node to set null the next node
    // free(prev);
    // prev->next = null;  // I can't do here!
    printf(""Can't delete the last item"");
    exit(1);
  } else {
    list_t *tmp = node->next;
    node->data = tmp->data;
    node->next = tmp->next;
    free(tmp);  // Don't forget!
  }
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
"list_t* search(list_t *head, int value) {  // O(n)","list_t* search(list_t *head, int value) {  // O(n)
  while (head) {
    if (head->value == value)
      return head;
    head = head->next;
  }
  return NULL;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
int removeThis(list_t* node) ,"int removeThis(list_t* node) {
  if (node == NULL || node->next == NULL)
    return 0;
  list_t* tmp = node->next;
  node->value = node->next->value;
  node->next = node->next->next;
  free(tmp);
  return 1;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
list_t* removeAllDups(list_t* head) ,"list_t* removeAllDups(list_t* head) {
  // 同じものがあれば、全て削除する(uniqueではない)
  list_t *f = NULL, *l = NULL, *current = head;
  while (current) {
    int found = 0;
    list_t* next = current->next;
    list_t* prev = current;
    while (next) {  // ここはuniqueと同じ
      if (next->value == current->value) {
        found = 1;
        prev->next = next->next;
        free(next);
        next = prev->next;
      } else {
        prev = next;
        next = next->next;
      }
    }
    if (found) {  // 自分自身も削除
      list_t* tmp = current; 
      current = current->next;
      free(tmp);
    } else {
      if (f == NULL && l == NULL) {
        f = l = current;
      } else {
        l->next = current;
        l = l->next;
      }
      current = current->next;
      l->next = NULL;
    }
  }
  return f;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
"list_t* lastButK(list_t* node, int k) ","list_t* lastButK(list_t* node, int k) {
  // 配列の長さ-k-1で要素を取得するでもよいが、kだけ先読みしたpointerを1つ用意することで高速化可能
  if (k < 0)
    return NULL;
  list_t *s, *e;
  s = e = node;
  for (int i = 0; i < k; i++) {
    if (e == NULL)
      return NULL;
    e = e->next;
  }
  while (e) {  // s <= eが成立
    s = s->next;
    e = e->next;
  }
  return s;  // k=0の時NULL
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
length' :: [a] -> Int,"length' :: [a] -> Int
length' = foldr (const (+1)) 0
-- (const (+1)) 2 3 == 4
-- (+1) ((const) 2 3)
-- const 2 3 == 2
-- Error ((+1) . const) 2 3
",/Users/mbp/workspace/sandbox/algo/list/list.hs
reverse' :: [a] -> [a],"reverse' :: [a] -> [a]
reverse' = foldl (flip (:)) []
",/Users/mbp/workspace/sandbox/algo/list/list.hs
elem' :: (Eq a) => a -> [a] -> Bool  -- O(n),"elem' :: (Eq a) => a -> [a] -> Bool  -- O(n)
elem' a [] = False
elem' a (x:xs) = a == x || elem' a xs -- (n-1)の結果を使うものは、共有メモリで計算できると思った
",/Users/mbp/workspace/sandbox/algo/list/list.hs
unique' :: (Eq a) => [a] -> [a] -- O(n^2),"unique' :: (Eq a) => [a] -> [a] -- O(n^2)
unique' [] = []
unique' (x:xs) = let ys = unique' xs in if elem' x ys then ys else x:ys
",/Users/mbp/workspace/sandbox/algo/list/list.hs
foldl' :: (b -> a -> b) -> b -> [a] -> b,"foldl' :: (b -> a -> b) -> b -> [a] -> b
-- a0 + a1 + ... an = (((a0 + a1) + ... ) + an-1) + an)
-- foldl f a0 Sn = f (foldl a0 Sn-1) an
foldl' f acc [] = acc
foldl' f acc (x:xs) = foldl' f (f acc x) xs  -- 末尾再帰
",/Users/mbp/workspace/sandbox/algo/list/list.hs
foldr' :: (a -> b -> b) -> b -> [a] -> b,"foldr' :: (a -> b -> b) -> b -> [a] -> b
-- a1 + ... an + a0 = (a1 + ... + (an-1 + (an + a0)))
-- foldr f a0 Sn = f (foldr a0 Sn-1) an
foldr' f init [] = init
foldr' f init (x:xs) = f x (foldr' f init xs)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
:Q:foldlとfoldrの違い,"-- foldlは左の要素から計算(+) かつ、(acc X x)
-- foldrは右の要素から計算(cons) かつ、 (x X acc)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
scanl' :: (b -> a -> b) -> b -> [a] -> [b],"scanl' :: (b -> a -> b) -> b -> [a] -> [b]
-- scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
scanl' _ acc [] = [acc]
scanl' f acc (x:xs) = acc: scanl' f (f acc x) xs
",/Users/mbp/workspace/sandbox/algo/list/list.hs
scanr' :: (a -> b -> b) -> b -> [a] -> [b],"scanr' :: (a -> b -> b) -> b -> [a] -> [b]
scanr' _ init [] = [init]
scanr' f init (x:xs) = let yss@(y:_) = scanr' f init xs in (f x y) : yss
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"span' :: (a -> Bool) -> [a] -> ([a], [a])","span' :: (a -> Bool) -> [a] -> ([a], [a])
-- 条件に合致し続けるまでの要素, それ以外
span' f [] = ([], [])
span' f (x:xs)
  | f x = let (ys, zs) = span' f xs in (x:ys, zs)
  | otherwise =  ([], x:xs)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"break' :: (a -> Bool) -> [a] -> ([a], [a])","break' :: (a -> Bool) -> [a] -> ([a], [a])
-- 条件に合致し続したところで終了
break' p = span (not . p)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
groupBy' :: (a -> a -> Bool) -> [a] -> [[a]],"groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]
-- A sorted list is required
groupBy' p [] = []
groupBy' p (x:xs) = (x:ys):(groupBy' p zs) where
  (ys, zs) = span (p x) xs
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"zip' :: [a] -> [b] -> [(a,b)]","zip' :: [a] -> [b] -> [(a,b)]
-- ２つの配列のうち、要素数の少ない方に要素数を合わせる
zip' [] y = []
zip' x [] = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
",/Users/mbp/workspace/sandbox/algo/list/list.hs
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c],"zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' f xs ys = map (uncurry f) (zip xs ys)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
deleteBy' :: Eq a => (a -> Bool) -> [a] -> [a],"deleteBy' :: Eq a => (a -> Bool) -> [a] -> [a]
deleteBy' eq [] = []
deleteBy' eq (x:xs) = let ys = deleteBy' eq xs in if eq x then ys else x:ys
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"unstableSplit :: [a] -> ([a], [a])","unstableSplit :: [a] -> ([a], [a])
-- リストの先頭の要素を2つ取り出して、双方に渡す
unstableSplit (x:y:zs) = (x:xs, y:ys) where (xs, ys) = unstableSplit zs
unstableSplit xs = (xs, [])
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"stableSplit :: [a] -> ([a], [a])","stableSplit :: [a] -> ([a], [a])
-- xsは1つ消費, ysは2つ消費. zsが0 or 1になるところでちょうどxsは半分消費したことになるので、そこで半分に分割
stableSplit xs = go xs xs where
  go (x:xs) (_:_:ys) = (x:us, vs) where (us, vs) = go xs ys
  go xs _ = ([], xs)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"; f(123, 0) = f(12, 3) = f(1, 32) = f(0, 321)","; f(123, 0) = f(12, 3) = f(1, 32) = f(0, 321)
(define (reverseInt-tail num)
  (let loop ((n num) (acc 0))
    (if (= n 0)
        acc
        (loop (div n 10) (+ (* acc 10) (mod n 10))))))
",/Users/mbp/workspace/sandbox/algo/list/reverseInt-tail.scm
"struct node* reverse(struct node* head, int k) ","struct node* reverse(struct node* head, int k) {
  int flag, count;
  struct node *n, *first, *last, *bf, *bl;
  flag = 1;
  count = 0;
  n = head;
  bf = bl = first = last = NULL;
  while (n) {
    if (count == k) {
      if (first == NULL && last == NULL) {
        first = bf;
        last = bl;
      } else {
        last->next = bf;
        last = bl;
      }
      flag = flag ? 0 : 1;
      bf = bl = NULL;
      count = 0;
    } else {
      struct node* next = n->next;  // 上書きされる前に次をあらかじめ保持しておく
      if (bf == NULL && bl == NULL) {
        n->next = NULL;
        bf = bl = n;
      } else if (flag) {
        n->next = bf;
        bf = n;
      } else {
        bl->next = n;
        bl = n;
      }
      count++;
      n = next;
    }
  }
  if (bf)
    last->next = bf;
  return first;
}
",/Users/mbp/workspace/sandbox/algo/list/reverseK.c
reverseK :: Int -> [Int] -> [Int],"reverseK :: Int -> [Int] -> [Int]
reverseK k xs = go xs where
  go xs
    | length xs <= k     = a1
    | length xs <= 2 * k = a1 ++ a2
    | otherwise          = a1 ++ a2 ++ go a3
    where
      a1 = reverse $ take k xs
      a2 = take k $ drop k xs
      a3 = drop (2 * k) xs
",/Users/mbp/workspace/sandbox/algo/list/reverseK.hs
fibを行列で表現,"
a(n+2)=1*a(n+1)+1*a(n)
a(n+1)=1*a(n+1)+0*a(n)
",/Users/mbp/workspace/sandbox/algo/math/eq.tex
:Q:Lx=yを求める式,"# y[i] = sum A[i,k] x[k] = A[i,1] x[1] + ... + A[i,i-1] x[i-1] + 1 * x[i] + 0 ...
# x[i] = y[i] - sum (1<=k<=i-1) A[i,k] x[k]
",/Users/mbp/workspace/sandbox/algo/math/eq.tex
:Q:Rx=zを求める式,"# z[i] = sum A[i,k] x[k] = A[i,i] x[i] + ... + A[i,n] x[n]  # i-1以下は0
# z[i] = sum (n>=k>=i) A[i,k] x[k]
# A[i,i] x[i] = z[i] - sum (n>=k>=i+1) A[i,k] x[k]  # 最後にA[i,i]で割る
",/Users/mbp/workspace/sandbox/algo/math/eq.tex
":Q:r[i,j]を求める式","# i<=j の時
# lr[i,j] = sum l[i,k]r[k,j] = l[i,1]r[1,j] + ... + l[i,i-1]r[i-1,j] + l[i,i]r[i,j]
# l[i,i] = 1より
# r[i,j] = lr[i,j] - sum(1<=k<=i-1) l[i,k]r[k,j] (i>=2)
# r[1,j] = lr[i,j] (i=1)  # 一番上の行は何もしない
",/Users/mbp/workspace/sandbox/algo/math/eq.tex
":Q:l[i,j]を求める式","# j<i の時
# lr[i,j] = sum l[i,k]r[k,j] = l[i,1]r[1,j] + ... + l[i,j-1]r[j-1,j] + l[i,j]r[j,j]
# l[i,j] = {lr[i,j] - sum(1<=k<=j-1) l[i,k]r[k,j]} / r[j,j] (j>=2)
# l[i,1] = lr[i,1] / r[1,1] (j=1)  # i>=2以上についてr[1,1]で割る
# なお、 sum(1<=k<=0)=0とすれば、一つの式で表せる
",/Users/mbp/workspace/sandbox/algo/math/eq.tex
def transpose(A):,"def transpose(A):
    m, n = len(A), len(A[0])
    B = [[None] * m for _ in range(n)]
    for i in range(m):
        for j in range(n):
            B[j][i] = A[i][j]
    return B
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
decompose Without Pivot (lu_k loop),"def decompose2(A):
    m, n = len(A), len(A[0])
    for k in range(max(m, n)):
        for i in range(k + 1, m):
            A[i][k] /= float(A[k][k])
        for i in range(k + 1, m):
            for j in range(k + 1, n):
                A[i][j] -= float(A[i][k] * A[k][j])
    return A
# i,jを固定した場合、kの範囲は0<=k<min(i,j)となる
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
decompose Without Pivot,"def decompose(A):
    m, n = len(A), len(A[0])
    for i in range(m):
        for j in range(n):
            for k in range(min(i, j)):
                A[i][j] -= float(A[i][k] * A[k][j])
            if i > j:
                A[i][j] /= float(A[j][j])
    return A
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
"decompose With Pivot (A = PLU, ただしPは置換行列の積)","# =0と判定するのは数値計算ではナンセンス. 最大を毎回行頭にするのが良い工夫
def decompose3(A):
    pass
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
Ax=yを解くプログラム,"def solve(A, y, do_decompose=True):
    # Ax=y => LUx=y => Lz=y => Ux=zの順に求める(y=>z=>xの順に解を上書き)
    n = len(A)  # 連立方程式は正方行列の必要あり
    if do_decompose:
        decompose(A)
    for i in range(n):
        for k in range(i):
            y[i] -= A[i][k] * y[k]  # k<i, y[k]=z[k]
    for i in reversed(range(n)):
        for k in range(i + 1, n):
            y[i] -= A[i][k] * y[k]  # i<k, y[k]=x[k]
        y[i] /= float(A[i][i])
    return y
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
AX=Eの逆行列を求める,"def inv(A):
    n = len(A)  # 逆行列は正則である必要あり
    decompose(A)  # LU分解は一度だけ行う
    X = []
    for i in range(n):
        e = [1 if i == j else 0 for j in range(n)]
        X.append(solve(A, e, do_decompose=False))
    return transpose(X)
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
"func multiple(A, B [][]int) [][]int ","func multiple(A, B [][]int) [][]int {
    // 各配列の長さが同長であることを仮定
	if len(A) == 0 || len(B) == 0 {
		panic(""must have a list"")
	} else if len(A[0]) != len(B) {
		panic(""Can not multiple"")
	}
	l, m, n := len(A), len(A[0]), len(B[0])
	C := make([][]int, l)
	for i := 0; i < l; i++ {
		C[i] = make([]int, n)
		for j := 0; j < n; j++ {
			for k := 0; k < m; k++ {
				C[i][j] += A[i][k] * B[k][j]
			}
		}
	}
	return C
}
",/Users/mbp/workspace/sandbox/algo/math/matrix/fib.go
行列演算を利用してfib(n)を求める,"func fib(n int) int {
	A := [][]int{{1, 1}, {1, 0}}
	x := [][]int{{1, 0}, {0, 1}} // E
	for n > 0 {
		if n&1 == 1 {
			x = multiple(x, A)
		}
		A = multiple(A, A)
		n = n >> 1
	}
    // 2*2 x 2*1 => 2*1 size
	return multiple(x, [][]int{{1}, {0}})[1][0] // A^n [a1, a0]
}
func main() {
	fmt.Println(fib(10))
}
",/Users/mbp/workspace/sandbox/algo/math/matrix/fib.go
整数を文字列に変換,"func int2str(x int) string {
	if x == 0 {
		return ""0""
	} else if x < 0 {
		return ""-"" + int2str(-x)
	}
	rs := []rune{}
	for d := x; d > 0; d /= 10 { // >= 0だと無限ループ
		r := d%10 + '0'
		rs = append(rs, rune(r))
	}
	return string(reverse(rs))
}
",/Users/mbp/workspace/sandbox/algo/misc/int2str.go
"配列[x,y]にtrueの要素がいくつあるか?","def f(A, x, y):
    N = len(A)
    if not (0 <= x <= y < N):
        return None
    elif x == y:
        return A[x]  # this is not needed
    S = [0] * N
    S[0] = A[0]
    for i in range(1, N):
        a = 1 if A[i] else 0
        S[i] = S[i - 1] + a
    if x == 0:
        return S[y]
    else:
        return S[y] - S[x - 1]
",/Users/mbp/workspace/sandbox/algo/prefix-sum/count-true-in-list.py
"数列a_nの要素が、少なくとも一つ[x, y]に含まれているか? 全体の範囲は[0,M)","func elementInRange(A []int, x, y, M int) bool {
    a := make([]int, M)
    for _, e := range A {
        a[e] = 1
    }
    s := make([]int, M)
    for i := 1; i < M; i++ {
        s[i] = s[i-1] + a[i]
    }
    if x == 0 {
        return s[y] > 0
    }
    return s[y] - s[x-1] > 0
}
",/Users/mbp/workspace/sandbox/algo/prefix-sum/element-in-range.go
:Q:配列を三等分する時の最大和(max(A[j:i]+A[i+k])),"func MaxDoubleSliceSum(A []int) int {
	K1 := make([]int, len(A)) // [0,i)までの最大和
	K2 := make([]int, len(A)) // (i,len(A)-1]までの最大和
	for i := 1; i < len(A)-1; i++ {
		K1[i] = max(K1[i-1] + A[i], 0)
	}
	for i := len(A)-2; i > 0; i-- {
		K2[i] = max(K2[i+1]+A[i], 0)
	}
	m := 0
	for i := 1; i < len(A)-1; i++ {
		m = max(m, K1[i-1]+K2[i+1])  // i番目を確定させておけば、後はどこかで区切れていればOK
	}
	return m
}
",/Users/mbp/workspace/sandbox/algo/seq/MaxDoubleSliceSum.go
:Q:0からN-1まで1~6ずつ進む中で、合計値が最大のもの,"func NumberSolitaire(A []int) int {
	var dfs func(int) int
	var min int = -1 << 30
	var memo = make([]int, len(A))
	for i := range memo { memo[i] = min }
	dfs = func(d int) int {
		if d == len(A)-1 {
			return A[d]  // 必ず解があると仮定して良い
		}
		if memo[d] != min {
			return memo[d]
		}
		max := min
		for i := 1; i <= 6; i++ {  // i<Nのパターンもあるね
			if i + d >= len(A) { continue }
			if t := dfs(i + d); t > max {
				max = t
			}
		}
		memo[d] = max + A[d]
		return memo[d]
	}
	return dfs(0)
}
",/Users/mbp/workspace/sandbox/algo/seq/NumberSolitaire.go
:Q:一次元を二次元に変換,"func OneToTwo(N, x int) int {
	if x >= N*N {
		panic(""x is huge"")
	}
	a := make([][]int, N)
	for i := 0; i < N; i++ {
		a[i] = make([]int, N)
		for j := 0; j < N; j++ {
			a[i][j] = i*N + j
		}
	}
    // OneToTwo(5, 23) = a[4][3] = 23
    return a[x/N][x%N]
}
",/Users/mbp/workspace/sandbox/algo/seq/OneToTwo.go
:Q:互いに通り過ぎる車の組み合わせ,"// 0=>, <=1に進むとして、1側を固定し0がいくつ通過するか数える
func solve(a []int) int {
	s := make([]int, len(a))
	s[len(a)-1] = 0
	for i := len(a)-1; i >= 1; i-- {
		s[i-1] += s[i] + a[i]
	}
	ans := 0
	for i := 0; i < len(a); i++ {
		if a[i] == 0 {
			ans += s[i]
		}
	}
	return ans
}
",/Users/mbp/workspace/sandbox/algo/seq/PassingCars.go
:Q:数列Snを２分割した数列の差の最小値,"func solve(a []int) int {
	sum := 0
	for i := 0; i < len(a); i++ { sum += a[i] }
	ms := abs(sum)
	for i := 0; i < len(a); i++ {
		sum -= 2*a[i]
		if ms > abs(sum) {
			ms = sum
		}
	}
	return ms
}
",/Users/mbp/workspace/sandbox/algo/seq/TapeEquilibrium.go
"int anagram(char* p, char* q) ","int anagram(char* p, char* q) {
  // anagramは、ある文字列の文字の順番を入れ替えて作成した別の文字列を作る
  // Statue of Liberty = built to stay free
  char counter[256] = {0};  // 256文字までと仮定
  int pl, ql;
  pl = ql = 0;
  // pにおけるそれぞれの文字数をカウント
  for (char* it = p; *it; it++) {
    char c = *it - 'a';
    counter[c]++;
    pl++;
  }
  // qで上で取得したカウンタを減算
  for (char* it = q; *it; it++) {
    char c = *it - 'a';
    counter[c]--;
    ql++;
    if (counter[c] < 0)  // 不足した時点で終了
      return 0;
  }
  if (pl == ql)
    return 1;  // p, qの長さが等しいも満たす必要あり(q側に余計な文字がないことの保証)
  return 0;
}
",/Users/mbp/workspace/sandbox/algo/seq/anagram.c
anagram,"anagram p q = (sort p) == (sort q)
",/Users/mbp/workspace/sandbox/algo/seq/anagram.hs
:Q:配列の要素が、少なくとも1回ずつ出現する数列のうち、最小のもの,"func atLeastOne(S []int, I int) int {
	buff := make([]int, len(S))
	sum := 0
	for i := 0; i < len(S); i++ {
		a := S[i]
		// if (a > I) continue;
		buff[a]++
		if buff[a] == 1 {
			sum++  // first found
		}
		if (sum == I+1) {  // [0, I]
			return i
		}
	}
	return -1;
}
func main() {
	fmt.Println(atLeastOne([]int{4,4,1,2,0,5,5,3,1,2}, 5))  // 7
}
",/Users/mbp/workspace/sandbox/algo/seq/atLeastOne.go
func continuousSubseq(a []int) int ,"func continuousSubseq(a []int) int {
	if (len(a) == 0) {
		return 0
	}
	var m, s int
	m = s = a[0]
	for i := 1; i < len(a); i++ { 
		s = max(s + a[i], a[i])
		m = max(m, s)
	}
	return m
}
",/Users/mbp/workspace/sandbox/algo/seq/continuousSubseq/continuousSubseq.go
:Q:ある数列の連続した部分数列の和の最大値,"c a b = compare (sum a) (sum b)
s [x] = [x]
s (x:xs) = maximumBy c [[x], (x:(s xs))]  -- xから新しくカウントし直す
m [x] = [x]  -- [-10]と[]を比べるため
m (x:xs) = maximumBy c [(m xs), (s(x:xs))]  -- 一つ手前と今
",/Users/mbp/workspace/sandbox/algo/seq/continuousSubseq/continuousSubseq.hs
func dominant(a []int) *int ,"func dominant(a []int) *int {
	if len(a) == 0 {
		return nil
	}
	stack := 1
	cnt := 1
	var c *int = &a[0]
	for i := 1; i < len(a); i++ {
		if a[i] == *c {
			stack++
			cnt++
		} else if stack > 0 {  // c is definitely not dominant
			stack--
		} else {
			stack = 1
			cnt = 1
			c = &a[i]
		}
	}
	if len(a) < 2*cnt {
		return c
	}
	return nil
}
",/Users/mbp/workspace/sandbox/algo/seq/dominant/dominant.go
"func equileader(A []int, x int) int ","func equileader(A []int, x int) int {
	// xが超過する場合の数を返す
	num := 0
	for i := 0; i < len(A); i++ {
		if A[i] == x {
			num++
		}
	}
	s, n := 0, 0  // nは、i番目までにおけるxの要素数
	for i := 0; i < len(A); i++ {
		if A[i] == x {
			n += 1
		}
		// 区間[0, i]にて、    xが半分超過すること (要素数i+1!)
		// 区間[i+1, n-1]にて、xが半分超過すること
		if 2 * n > i + 1 && 2 * (num - n) > len(A) - (i + 1) {
			s += 1
		}
	}
	return s
}
",/Users/mbp/workspace/sandbox/algo/seq/equileader.go
"func exp(a, n int) int ","func exp(a, n int) int {
	if (n == 0) {
		return 1;
	} else if (n % 2 == 0) {
		x := exp(a, n / 2)
		return x * x
	} else {
		x := exp(a, (n - 1) / 2)
		return x * x * a
	}
}
",/Users/mbp/workspace/sandbox/algo/seq/exp/exp.go
fib n,"fib n
  | n == 0 || n == 1 = n
  | otherwise        = fib(n - 1) + fib(n - 2)
",/Users/mbp/workspace/sandbox/algo/seq/fib/fib.hs
list_t* find(list_t* node) ,"list_t* find(list_t* node) {
  if (node == NULL)
    return NULL;
  list_t *fast, *slow;
  fast = slow = node;
  // find a point where both of two meet
  while (fast->next) {
    slow = slow->next;
    fast = fast->next->next;
    if (slow == fast)
      break;
  }
  // node is not cycled
  if (fast->next == NULL)
    return NULL;
  slow = node;
  while (slow != fast) {
    slow = slow->next;
    fast = fast->next;
  }
  return slow;
}
",/Users/mbp/workspace/sandbox/algo/seq/floyd-cycle-finding.c
":Q:gcd(44,12)のプロセス","; 44 12 => 12 8 => 8 4 => 4 0 (ans = 4)
",/Users/mbp/workspace/sandbox/algo/seq/gcd/gcd.scm
(define (gcd m n),"(define (gcd m n)
  (cond ((< m n) (gcd n m))
        ((= n 0) m)
        (else (gcd n (mod m n)))))
",/Users/mbp/workspace/sandbox/algo/seq/gcd/gcd.scm
共通約数のみ存在する場合はTrue,"f :: Int -> Int -> Bool
f a b = g a where
  g x = let y = gcd x b in
    if y == 1 then x == 1 else g (div x y)
main = do
  print $ f 75 15  -- {3 5}
  print $ f 15 75
  print $ f 8 15
",/Users/mbp/workspace/sandbox/algo/seq/has-other-divisor/has-other-divisor.hs
f(x) = sum an * x^n,"func Horner(a []int, x int) int {
    // 
	if len(a) == 0 { panic(""ERROR"") }
	s := a[0]
	for i := 1; i < len(a); i++ {
		s = s * x + a[i]
	}
	return s
}
func main () {
	fmt.Println(Horner([]int{3,2,1}, 2))  // f(x=2)=3x^2 + 2x + 1 = 17
}
",/Users/mbp/workspace/sandbox/algo/seq/horner.go
Least Common Multiple (最小公倍数),"-- ab = lcm(a,b) * gcd(a,b)の関係式より
lcm' a b = div (a * b) (gcd a b)
",/Users/mbp/workspace/sandbox/algo/seq/lcm.hs
"func f(a, b string) string ","func f(a, b string) string {
	dp := make([][]string, len(a) + 1)
	for i := 0 ; i < len(dp); i++ { dp[i] = make([]string, len(b) + 1)}
	for x := 0; x < len(a); x++ {
		for y := 0; y < len(b); y++ {
			if a[x] == b[y] {
				dp[x+1][y+1] = dp[x][y] + string(a[x])
			} else {
				s1 := dp[x][y+1]
				s2 := dp[x+1][y]
				if len(s1) > len(s2) {
					dp[x+1][y+1] = s1
				} else {
					dp[x+1][y+1] = s2
				}
			}
		}
	}
	return dp[len(a)][len(b)]
}
",/Users/mbp/workspace/sandbox/algo/seq/lcs/lcs.go
:Q:LongestCommonSequence,"c a b = compare (length a) (length b)
f = g where
 g xss@(x:xs) yss@(y:ys)
  | x == y    = x : g xs ys
  | otherwise = maximumBy c [(g xss ys), (g xs yss)]
 g _ _ = """"
{-
f(x, y)
 =  0 (x = 0 or y = 0)
 = f(x-1, y-1) + 1 (x = y)
 = $max ${f(x-1,y), f(x, y-1) $} (else)
-}
",/Users/mbp/workspace/sandbox/algo/seq/lcs/lcs.hs
func localMaximum(x []int) []bool ,"func localMaximum(x []int) []bool {
	bs := make([]bool, len(x))
	for i := 1; i < len(x)-1; i++ {
		if x[i-1] < x[i] && x[i] > x[i+1] {
			bs[i] = true
		}
	}
	return bs
}
  
",/Users/mbp/workspace/sandbox/algo/seq/localMaximum.go
:Q:Kadane'sAlgorithm,"-- 株価の儲けの最大を求める
f (x:y:xs) = g (x-y) (x-y) (y:xs) where
  g s m (x:y:xs) = g ns nm (y:xs) where
    d  = x - y
    ns = max d (s + d)
    nm = max m ns  -- 暫定最大値
  g s m x = max m (-1)
main = do
  print $ f $ reverse [4,1,2,5,3]  -- 4 (2-1+5-2) 
  print $ f $ reverse [5,4,3,2,1]  -- -1 (失敗)
  print $ f $ reverse [4,1,2,5,3,4] -- 4
",/Users/mbp/workspace/sandbox/algo/seq/maxProfix.hs
x^2=n(newton),"// x(n+1) = xn - f(xn)/f'(xn)
func f(n, x1, e float64) float64 {
	for {
		x2 := x1 - (x1 * x1 - n) / (2 * x1)
		if (abs(x2-x1) < e) { return x2 }
		x1 = x2
	}
}
",/Users/mbp/workspace/sandbox/algo/seq/newton.go
:Q:polland,"; mod nとした乱数生成関数fとし、x,yの2数を生成させ、対象の整数の因数を求める。(x=yとなった場合は失敗)
(define (polland n)
 (define rlist (shuffle (iota n)))
 (let1 f (^x (ref rlist x))
       (let loop ((x 2) (y 2))
         (let* ((x (f x))
                (y (f (f y)))
                (d (gcd (abs (- x y)) n)))
           (cond ((= d 1) (loop x y))
                 ((= d n) -1)
                 (else d))))))
(define (main args)
  (print (polland 108))  ; 9
  (print (polland 3))  ; -1
  0)
",/Users/mbp/workspace/sandbox/algo/seq/polland/pollanrd-rho.scm
:Q:２つの素数の積の集合(同じものを含む),"def f(N):
 p = [True] * (N+1)
 p[0] = p[1] = False
 i = 2
 while i*i <= N:
  if p[i]:
   for j in range(i*i, N+1, i):
    p[j] = False
  i += 1
 s = [False] * (N+1)
 for i in range(N+1):
  if p[i]:
   j = i
   while j*i <= N:
    if p[j]:
     s[j*i] = True
    j += 1
 return [i for i in range(N+1) if s[i]]
print(f(4))  # [4]
print(f(100))  # [4, 6, 9, 10, 14, 15, 21, 22, 25, 26, 33, 34, 35, 38, 39, 46, 49, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95]
",/Users/mbp/workspace/sandbox/algo/seq/semi-prime/semi-prime.py
vector<bool> make_prime_table(int size),"vector<bool> make_prime_table(int size){
  vector<bool>isPrime(size, true);
  isPrime[0] = isPrime[1] = false;  // 0, 1は素数でないので2から始める
  for (int i = 2; i * i < size; i++) {  // (size-1)まで参照
    if (isPrime[i]) {
      // jは、iより小さい数からスタートしなくてよい(i=3なら、6でもなく9からでOK)
      for (int j = i; i * j < size; j++)
        isPrime[i * j] = false;
    }
  }
  return isPrime;
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.cpp
func generate() chan int ,"func generate() chan int {
	ch := make(chan int)
	go func() {
		for i := 2; ; i++ {
			ch <- i
		}
	}()
	return ch
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.go
"func filter(in chan int, prime int) chan int ","func filter(in chan int, prime int) chan int {
	out := make(chan int)
	go func() {
		for {
			if i := <- in; i % prime != 0 {
				out <- i
			}
		}
	}()
	return out
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.go
func sieve() chan int ,"func sieve() chan int {
	out := make(chan int)
	go func () {
		ch := generate()
		for {
			prime := <- ch
			out <- prime
			ch = filter(ch, prime)
		}
	}()
	return out
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.go
:Q:prime,"-- p*p以上の整数を篩にかける(残ったものが素数)
primes = f [2..] where
  f (p:xs) = p:f [x | x <- xs, (mod x p) /= 0]
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.hs
:Q:yates-shuffle,"// 末尾と取り替えるインデックスを決めて、それと末尾を入れ替え
func shuffle(a []int) {
	for i := len(a) - 1; i >= 1; i-- {
		j := rand.Int() % (i + 1)
		if ! (0 <= j && j <= i) { panic(""invalid"") }
		a[i], a[j] = a[j], a[i]
 }
}
",/Users/mbp/workspace/sandbox/algo/seq/yates/yates.go
:Q:anagram同士が隣同士になるようソート(CI9.2),"sort' :: [String] -> [String]
sort' = Data.List.sortBy (\a b -> compare (sort a) (sort b))
",/Users/mbp/workspace/sandbox/algo/sort/anagram-sort.hs
"func binSort(A []int, max int) []int ","func binSort(A []int, max int) []int {
	// 特徴: 重複した要素は扱えない
	bucket := make([]bool, max+1)
	for i := 0; i < len(A); i++ {
		bucket[A[i]] = true
	}
	j := 0
	for i := 0; i < max; i++ {
		if bucket[i] {
			A[j] = i
			j++
		}
	}
    return A[:j]
}
",/Users/mbp/workspace/sandbox/algo/sort/bin-sort.go
"void bsort(int *a, int *buff, int size, int range) ","void bsort(int *a, int *buff, int size, int range) {
  int counter[range], offset[range];
  for (int i = 0; i < range; i++) counter[i] = offset[i] = 0;
  for (int i = 0; i < size; i++) counter[a[i]]++;
  offset[0] = 0;
  for (int i = 0; i < range - 1; i++) offset[i + 1] = offset[i] + counter[i];
  for (int i = 0; i < size; i++) {
    int v = a[i];
    buff[offset[v]++] = v;  // 加えたら同じ値のoffsetは更新
  }
}
",/Users/mbp/workspace/sandbox/algo/sort/bucket-sort.c
"bucketsortBy :: (a -> Int) -> (Int, Int) -> [a] -> [a]","bucketsortBy :: (a -> Int) -> (Int, Int) -> [a] -> [a]
bucketsortBy getkey dom = concatMap reverse . filter (not . null)
    . elems . accumArray (flip (:)) [] dom . map (\x -> (getkey x, x))
",/Users/mbp/workspace/sandbox/algo/sort/bucket-sort.hs
bucketsort' :: [Int] -> [Int] -> [Int],"bucketsort' :: [Int] -> [Int] -> [Int]
bucketsort' keys xs = [x| k <- keys, x <- xs, x == k]
",/Users/mbp/workspace/sandbox/algo/sort/bucket-sort.hs
"int find(int *a, int left, int right, int pos) ","int find(int *a, int left, int right, int pos) {
  int k = left;
  int pivot = a[left];
  for (int i = left + 1; i <= right; i++)
    if (a[i] < pivot) swap(&a[i], &a[++k]);
  swap(&a[left], &a[k]);
  if (k == pos) return a[k];
  else if (pos < k) return find(a, left, k-1, pos);
  else return find(a, k+1, right, pos);
}
",/Users/mbp/workspace/sandbox/algo/sort/find-kth-smallest.c
"data_type maxChild(data_type *a, int parent, int size) ","data_type maxChild(data_type *a, int parent, int size) {
  // binary heap
  int left, right;
  if ((left = LEFT(parent)) >= size)
    return 0;
  else if ((right = RIGHT(parent)) == size) {
    return left;
  } else if (a[left] < a[right])
    return right;
  else
    return left;
}
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.c
"void downHeap(data_type *a, int size) ","void downHeap(data_type *a, int size) {
  int parent = 0;
  while (1) {
    int child = maxChild(a, parent, size);
    if (child > 0 && a[parent] < a[child]) {
      swap(a, parent, child);
      parent = child;
    } else
      break;
  }
}
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.c
"data_type *heapSort(data_type *array, int size) ","data_type *heapSort(data_type *array, int size) {
  for (int i = 0; i < size; i++)
    upHeap(array, i);
  for (int i = size - 1; i >= 0; i--) {
    // swapではiは有効, downHeapではiは無効
    swap(array, 0, i);  // sort from last to first
    downHeap(array, i); 
  }
  return array;
}
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.c
data Heap a = Leaf | Node a [Heap a],"data Heap a = Leaf | Node a [Heap a]
  deriving Show
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
unify :: Ord a => [Heap a] -> Heap a,"unify :: Ord a => [Heap a] -> Heap a
unify [] = Leaf
unify [x] = x
unify (x:y:zs) = merge (merge x y) (unify zs)
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
merge :: Ord a => Heap a -> Heap a -> Heap a,"merge :: Ord a => Heap a -> Heap a -> Heap a
merge Leaf h = h
merge h Leaf = h
merge lhs@(Node l lh) rhs@(Node r rh)
  | compare l r == LT = Node l (rhs:lh)
  | otherwise         = Node r (lhs:rh)
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
fromList :: Ord a => [a] -> Heap a,"fromList :: Ord a => [a] -> Heap a
fromList = unify . map (\x -> (Node x []))
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
toList :: Ord a => Heap a -> [a],"toList :: Ord a => Heap a -> [a]
toList Leaf = []
toList (Node x xs) = x : toList (unify xs)
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
sort :: Ord a => [a] -> [a],"sort :: Ord a => [a] -> [a]
sort [] = []
sort (x:xs) = insert x $ sort xs where
  insert y [] = [y]
  insert y (x:xs)
    | x < y = x:insert y xs
    | otherwise = y:x:xs
",/Users/mbp/workspace/sandbox/algo/sort/insert-sort.hs
data structure for kway-merge-sort,"type Heap []item
func (h Heap) Len() int           { return len(h) }
func (h Heap) Less(i, j int) bool { return h[i].get() < h[j].get() } // for max heap to use > instead
func (h Heap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *Heap) Push(x interface{}) {
	*h = append(*h, x.(item))
}
func (h *Heap) Pop() interface{} {
	l := len(*h) - 1
	x := (*h)[l] // out of indexは呼び出し側の責務
	*h = (*h)[:l]
	return x
}
func (h *Heap) First() interface{} {
	return &(*h)[0]
}
type item struct {
	i    int
	data []int
}
func (i *item) get() int { return (*i).data[(*i).i] }
func (i *item) next() bool {
	if (*i).i < len((*i).data)-1 { // -1の時点で次はないのでPop
		(*i).i++
		return true
	}
	return false
}
",/Users/mbp/workspace/sandbox/algo/sort/kway-merge-sort.go
func MergeKArrays(ss [][]int) []int ,"func MergeKArrays(ss [][]int) []int {
	// k個のソート済み配列を用意し、heapを利用して次どの配列から取得するか決める
    // heapを使わないnaive場合、各配列の先頭要素のうち最小を見つけるのにlen(ss)かかる
	h := &Heap{}
	cnt := 0 // 全配列の総和
	for _, s := range ss {
		if len(s) > 0 {
            *h = append(*h, item{0, s})
            cnt += len(s)
		}
	}
	heap.Init(h)
	out := make([]int, cnt)
	for i := 0; i < cnt; i++ {
		f := h.First().(*item) // cntの制約があるので要素が必ずある
		out[i] = f.get()
		if f.next() {
			heap.Fix(h, 0) // down heap
		} else {
			heap.Pop(h) // 全て捜査したので不要
		}
	}
	return out
}
",/Users/mbp/workspace/sandbox/algo/sort/kway-merge-sort.go
"void msort(int *a, int left, int right) ","void msort(int *a, int left, int right) {
  if (left >= right)
    return;
  int mid = left + (right - left) / 2;
  msort(a, left, mid);
  msort(a, mid + 1, right);
  int l = left, r = mid + 1, k = 0;
  int len = right - left + 1;
  int buff[len];  // O(n)のスペースが必要(VLA)
  while (l <= mid && r <= right) {  // どちらか一方の配列を全て使い切るまでloop
    if (a[l] < a[r])
      buff[k++] = a[l++];
    else
      buff[k++] = a[r++];
  }
  while (l <= mid)   buff[k++] = a[l++];  // 残りの一方の配列をappend
  while (r <= right) buff[k++] = a[r++];
  memcpy(a + left, buff,  sizeof(int) * len);  // sizeof忘れ、offsetのleft忘れ
  /* for (int i = 0; i < len; i++) a[left + i] = buff[i]; */
}
",/Users/mbp/workspace/sandbox/algo/sort/merge-sort.c
sort :: Ord a => [a] -> [a],"sort :: Ord a => [a] -> [a]
sort [] = []
sort [x] = [x]
sort xs = merge (sort ys) (sort zs) where
  (ys, zs) = split xs
merge :: Ord a => [a] -> [a] -> [a]
merge xs [] = xs
merge [] ys = ys
merge xxs@(x:xs) yys@(y:ys)
  | x < y     = x:merge xs yys
  | otherwise = y:merge xxs ys
",/Users/mbp/workspace/sandbox/algo/sort/merge-sort.hs
"split :: [a] -> ([a], [a])  -- this is not stable","split :: [a] -> ([a], [a])  -- this is not stable
split (x:y:zs) = (x:xs, y:ys) where (xs, ys) = split zs
split xs = (xs, [])  -- after match
-- split []  = ([] , [])
-- split [x] = ([x], [])
",/Users/mbp/workspace/sandbox/algo/sort/merge-sort.hs
"void swap (int *x, int *y) ","void swap (int *x, int *y) {
  int t = *x;
  *x = *y;
  *y = t;
}
",/Users/mbp/workspace/sandbox/algo/sort/quick-sort.c
"void qsort (int *a, int left, int right) ","void qsort (int *a, int left, int right) {
  if (left >= right)
    return;
  int pivot = a[left];
  int l = left;
  int r = right;
  while (1) {  // l <= r可能?
    while (a[l] < pivot) l++;
    while (a[r] > pivot) r--;
    if (l <= r) {
      swap(&a[l], &a[r]);
      l++;
      r--;
    } else
      break;
  }
  qsort(a, left, r);
  qsort(a, l, right);
}
",/Users/mbp/workspace/sandbox/algo/sort/quick-sort.c
"func QuickSort(a []int, left, right int) ","func QuickSort(a []int, left, right int) {
	if !(left < right) {
		return
	}
	// pivotは左右を含むし、どこでもいいはず、なら左端に決め打つ
	var k, pivot int
	k, pivot = left, a[left]
	for i := left + 1; i <= right; i++ {
		if a[i] < pivot {
			k++ // kは前の最後の保存場所
			a[i], a[k] = a[k], a[i]
		}
	}
	// pivotを(全体の)k番目にする (覚えておくと組み立てやすい)
	a[left], a[k] = a[k], a[left]
	// pivotを境にソートされているので、kを含まなくて良い
	QuickSort(a, left, k-1)
	QuickSort(a, k+1, right)
}
",/Users/mbp/workspace/sandbox/algo/sort/quick-sort.go
positiveLsdSort :: (Bits a) => [a] -> [a],"positiveLsdSort :: (Bits a) => [a] -> [a]
positiveLsdSort = flip (foldl f) [0..bitSize (0 :: Int)] where
  f acc x = uncurry (++) $ partition (not . flip testBit x) acc
",/Users/mbp/workspace/sandbox/algo/sort/radix-sort.hs
先頭からpos番目までをソートした配列を返す,"func SortUntil(a []int, left, right, pos int) {
	if !(left < right) {
		return
	}
    // QuickSortではpivotがk番目にあることを求めることができる.
    // それを利用して、先頭だけが欲しい場合は、[0, k-1]までをソートすれば済む
    k, pivot := left, a[left]
    for i := left + 1; i <= right; i++ {
        if (a[i] < pivot) {
            k++
            a[i], a[k] = a[k], a[i]
        }
    }
    a[left], a[k] = a[k], a[left]
    SortUntil(a, left, k-1, pos)
    if pos > k { // posが小さい時は、log(len(a))と高速化
        SortUntil(a, k+1, right, pos)
    }
}
",/Users/mbp/workspace/sandbox/algo/sort/sort-until.go
"func hasArrayTwoCandidates(arr []int, sum int) bool ","func hasArrayTwoCandidates(arr []int, sum int) bool {
    // 配列がソートされている場合に限り
    // 2つの要素の和があるsumになる場合を探すのはO(n)
	left := 0
	right := len(arr) - 1
	for left < right {
		s := arr[left] + arr[right]
		if s == sum {
			return true
		} else if s < sum {
			left++
		} else {
			right--
		}
	}
	return false
}
",/Users/mbp/workspace/sandbox/algo/sorted/hasArrayTwoCandidates.go
return True If Sorted Array Has Ttriangle,"-- 三角形の長辺は、これに異なる２辺の長さの和より小さい
f a = any id [a!!i + a!!i+1 > a!!i+2 | i<-[0..length a-2]]
",/Users/mbp/workspace/sandbox/algo/sorted/triangle-exists.hs
ソート配列の３つの積の最大値は?,"def f(data):
    s = sorted(data)
    m1 = s[-1] * s[-2] * s[3]
    m2 = s[0] * s[1] * s[-1]
    return max(m1, m2)
",/Users/mbp/workspace/sandbox/algo/sorted/triple-product.py
:Q:最小値をO(1)で取得できるstack.push()(ただし重複した値をpushしない),"func (s *Stack) Push(v Node) {
	s.stack = append(s.stack, v)
	if len(s.cache) == 0 || s.Min().value > v.value {
		s.cache = append(s.cache, v)
	}
}
",/Users/mbp/workspace/sandbox/algo/stack/minium-stack.go
:Q:最小値をO(1)で取得できるstack.pop()(ただし重複した値をpushしない),"func (s *Stack) Pop() *Node {
	if s.Empty() {
		return nil
	}
	x := s.stack[len(s.stack)-1]
	s.stack = s.stack[:len(s.stack)-1]
	if len(s.cache) != 0 && s.Min().value == x.value {
		s.cache = s.cache[:len(s.cache)-1]
	}
	return &x
}
",/Users/mbp/workspace/sandbox/algo/stack/minium-stack.go
class SetOfStacks ,"class SetOfStacks {
private:
  int threshold;
  list<stack<int>> stacks;
public:
  SetOfStacks(int threshold) {
    this->threshold = threshold;
  }
  void push(int value) {
    if (!stacks.empty()){
      stack<int>& last = stacks.back();
      if (last.size() < threshold)
        return last.push(value);
    }
    stack<int> s;
    s.push(value);
    stacks.push_back(s);
  }
  int pop() {
    if (empty())
      throw ""Empty stack can't pop\n"";
    stack<int>& last = stacks.back();
    if (last.empty()) {  // 因みに{}内でlastの上書きするとエラーみたい?
      stacks.pop_back();
      return pop();
    }
    int top = last.top();
    last.pop();
    return top;
  }
  bool empty() {
    if (stacks.empty())
      return true;
    stack<int>& last = stacks.back();
    if (stacks.size() == 1 && last.empty())
      return true;
    return false;
  }
};
",/Users/mbp/workspace/sandbox/algo/stack/setOfStack.cpp
"void push(node_t** head, int value)","void push(node_t** head, int value){
  // stackはリストの先頭に要素を加えていくことでO(1)を実現
  node_t* new = init(value);
  if (*head == NULL) {
    *head = new;
    return;
  }
  node_t* first = *head;
  new->next = first;
  *head = new;
}
",/Users/mbp/workspace/sandbox/algo/stack/stack.c
void pop(node_t** head),"void pop(node_t** head){
  node_t* first = *head;
  if (first == NULL) {
    exit(1); // error
  }
  int value = first->value;
  *head = first->next;
  free(first);
}
",/Users/mbp/workspace/sandbox/algo/stack/stack.c
:Q:2つのqueueでstackを実装,"type Queue struct {
	s1 Stack
	s2 Stack
}
func (q *Queue) Push(x int) {
	q.s1 = append(q.s1, x)
}
// FILOを2回繰り返せばFIFOになる
func (q *Queue) Pop() int {
	if !q.s2.Empty() {
		return q.s2.Pop()
	}
	for !q.s1.Empty() { // s1は全てからにする!
		q.s2.Push(q.s1.Pop())
	}
	if !q.s2.Empty() {
		return q.s2.Pop()
	}
	panic(""Queue is empty"")
}
func (q *Queue) Empty() bool {
	return q.s1.Empty() && q.s2.Empty()
}
",/Users/mbp/workspace/sandbox/algo/stack/stackQueue.go
fibの級数表記をzipWidthで表現,"fib = 0:1:zipWith (+) fib (tail fib)
fib'@(_ : tf) = 0:1:zipWith (+) fib' tf
{-
fib = 0 1 1 2 3 5 8 13 21 34
(+)       0 1 1 2 3 5  8  13 21 34
          1 1 2 3 5 8  13 21 34
-}
",/Users/mbp/workspace/sandbox/algo/stream/fib.hs
:Q:等比数列2^(n-1),"a = 1: map (*2) a
{-
a = 1 2   4 8 ...
a =   2(1 2 4 ...
-}
",/Users/mbp/workspace/sandbox/algo/stream/geometric.hs
整数の級数表記をzipWidthで表現,"integer = 1: zipWith (+) (repeat 1) integer
",/Users/mbp/workspace/sandbox/algo/stream/int.hs
"1, 1, 1...の級数","one = 1:one
",/Users/mbp/workspace/sandbox/algo/stream/one.hs
"int isRotation(char* p, char* q) ","int isRotation(char* p, char* q) {
  // (ex) apple == pleap => true
  // ２回、文字列を並べることで、全てのローテーションのパターンが作られる(最後のdは不要だけれども)
  int pl = strlen(p);
  int ql = strlen(q);
  if (pl != ql)
    return 0;
  // pのメモリが静的の場合もあるので動的にメモリを確保する
  int len = pl * 2 + 1;
  char* pp = malloc(sizeof(char) * len);
  strcat(pp, p);
  // pl=1のとき、pが1文字なので'\0'はpp+1に存在
  strcat(pp + pl, p);
  int result = strstr(pp, q) > 0;
  free(pp);  // 結果がわかれば領域は用済み
  return result;
}
",/Users/mbp/workspace/sandbox/algo/string/is-rotation.c
"func isSubstring(str, sub string) bool ","func isSubstring(str, sub string) bool {
	// brute-force algorithm
	// 計算量はO(nm)だが、文字の種類が多いので，たいていの場合
	// パターンの先頭の 数文字を調べるだけで済むので、実質O(n)
	for start := 0; start <= len(str)-len(sub); start++ {
		i, j := start, 0
		for ; j < len(sub); i, j = i+1, j+1 {
			if str[i] != sub[j] { // i < len(str)は保証
				break
			}
		}
		if j == len(sub) {
			return true
		}
	}
	return false
}
",/Users/mbp/workspace/sandbox/algo/string/is-string.go
char* replaceSpacesWithP20(char* s) ,"char* replaceSpacesWithP20(char* s) {
  /*
    文字列の長さを増やす場合(減らすときは問題ない)
    mallocで新しくメモリを確保する必要がある
    '\0'の領域を確保し忘れないこと
    ORDER: O(n) = 2 * 文字列の長さ
  */
  int length = 0;
  for (char* it = s; *it; it++) {
    if (*it == ' ')
      length += 3;
    else
      length += 1;
  }
  char* new = malloc(sizeof(char) * (length + 1));
  char* head = new;
  for (char* it = s; *it; it++) {
    if (*it == ' ') {
      *new++ = '%';
      *new++ = '2';
      *new++ = '0';
    }
    else
      *new++ = *it;
  }
  *new = '\0';
  return head;
}
",/Users/mbp/workspace/sandbox/algo/string/replaceSpacesWithP20.c
char *s_strip(char *str) ,"char *s_strip(char *str) {
  while (*str == ' ')
    str++;
  char *last = str;
  while (*last)
    last++;
  last--;  // go backword from '\0'
  while (*last == ' ')
    last--;
  *++last = '\0';
  return str;
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
"int s_strcmp(char *p, char *q) ","int s_strcmp(char *p, char *q) {
  while (*p && *q) {
    if (*p < *q)
      return -1;
    else if (*p > *q)
      return 1;
    p++;
    q++;
  }
  if (*p)
    return 1;  // q is longer
  else if (*q)
    return -1;  // p is longer
  else
    return 0; // same length
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
int s_strlen(char *str) ,"int s_strlen(char *str) {
  char *last = str;
  while (*last) last++;
  return last - str;
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
"char *s_join(char **str, char delim, int length) ","char *s_join(char **str, char delim, int length) {
  int sum = 0;
  for (int i = 0; i < length; i++)
    sum += s_strlen(str[i]);
  sum += length;  // delim * (length - 1) + '\0'
  char *p, *q;
  p = q = (char *)malloc(sizeof(char) * sum);
  for (int i = 0; i < length; i++) {
    for (char *s = str[i]; *s; s++)
      *q++ = *s;
    *q++ = delim;
  }
  *--q = '\0';
  return p;
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
char *s_lower(char *str) ,"char *s_lower(char *str) {
  for (char *c = str; *c; c++) {
    if ('A' <= *c && *c <= 'Z') {
      *c = 'a' + (*c - 'A');
    }
  }
  return str;
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
"int s_is_substring(char *ps, char *qs) ","int s_is_substring(char *ps, char *qs) {
  char *p, *q;
  for (char *s = ps; *s; s++) {
    char *p = s;
    char *q = qs;
    while (*p && *q)
      if (*p == *q) {
        p++;
        q++;
      } else
        break;
    if (*q == '\0')
      return 1;
  }
  return -1;
}
  /* printf(""%d\n"", isSubstring(""abcdefg"", ""cde"")); */
  /* printf(""%d\n"", isSubstring(""abcdefg"", ""ced"")); */
  /* printf(""%d\n"", isSubstring(""abcdefg"", """")); */
  /* printf(""%d\n"", isSubstring(""abc"", ""abcdefg"")); */
",/Users/mbp/workspace/sandbox/algo/string/string.c
"char* myremove(char c, char* str) ","char* myremove(char c, char* str) {
  char *dst = str;
  for (char *it = str; *it ;it++) {
    if (*it != c)
      *dst++ = *it;
  }
  *dst = '\0';
  return str;
}
  /* char s1[] = ""abcabc""; */
  /* printf(""%s\n"", myremove('c', s1)); */
",/Users/mbp/workspace/sandbox/algo/string/string.c
char* unique(char* str) ,"char* unique(char* str) {
  char *dst = str;
  for (char *i = str; *i ;i++) {
    char *j;
    for (j = str; j < dst; j++) {
      if (*j == *i)
        break;
    }
    if (j == dst)  // breakしなかった場合
      *dst++ = *i;
  }
  *dst = '\0';
  return str;
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
char* reverse(char* s) ,"char* reverse(char* s) {
/*
 *sが空文字でないなら、
 一つ先が'\0'になるようにpointerを進めること
 sとeを入れ替えることでreverseを実現
 偶数・奇数で中心の文字を入れ替えるかどうかの判断が必要になるが
 s == eの場合が奇数のときに起こるがこれは、交換してもしなくても結果的にはよい
 結局入れ替える条件は、s < eになる
 */
  if (*s == '\0') return s;
  char *head = s;
  char *e = s;
  while (*(e + 1)) e++;
  while (s < e) swap(s++, e--);
  return head;
}
",/Users/mbp/workspace/sandbox/algo/string/string.c
func suffixArray(s string) []string ,"func suffixArray(s string) []string {
    // 文字列の接尾辞を要素とする配列を接尾辞に関して辞書順に並べ替えて得られる配列
    ss := make([]string, len(s))
    for i := 0; i < len(s); i++ {
        ss[i] = s[i:]
    }
    sort.Strings(ss)
    return ss
}
",/Users/mbp/workspace/sandbox/algo/string/suffix-array.go
"func findFromSuffixArray(sa []string, target string) bool ","func findFromSuffixArray(sa []string, target string) bool {
    // O(target * log(len(sa)))
    lo, hi := 0, len(sa)
    for lo <= hi {
        mi := lo + (hi - lo) / 2
        s := sa[mi]
        if len(s) >= len(target) && s[:len(target)] == target {
            return true
        } else if s < target { // 文字列の2回比較遅い
            lo = mi + 1
        } else {
            hi = mi - 1
        }
    }
    return false
}
",/Users/mbp/workspace/sandbox/algo/string/suffix-array.go
type Trie struct ,"type Trie struct {
    children []*Trie // ['a', ... ,'z']
}
func NewTrie () *Trie {
    return &Trie{children: make([]*Trie, 26)}
}
",/Users/mbp/workspace/sandbox/algo/string/trie.go
func (t *Trie) Insert(s string) ,"func (t *Trie) Insert(s string) {
    if len(s) == 0 {
        return
    }
    key := s[0] - 'a'
    if t.children[key] == nil {
        t.children[key] = NewTrie()
    }
    t.children[key].Insert(s[1:])
}
",/Users/mbp/workspace/sandbox/algo/string/trie.go
flatten,"-- squishの第二引数は結果を保持
data Tree a = Node a [Tree a] deriving Show
flatten :: Tree a -> [a]
flatten t = squish t []
  where squish (Node x ts) xs = x:foldr squish xs ts
",/Users/mbp/workspace/sandbox/algo/tree/flatten.hs
(define (flatten tree),"(define (flatten tree)
  (foldr (lambda (x acc)
          (if (pair? x)
              (append (flatten x) acc)
              (cons x acc)))
        '()
        tree))
(define (foldr f last alist)
  (if (pair? alist)
      (f (car alist) (foldr f last (cdr alist)))
      last))
",/Users/mbp/workspace/sandbox/algo/tree/flatten.scm
UnionFindのデータ構造,"type UnionFind struct {
    Data []int  // 親を参照 (自分自身を参照している場合はRoot)
    Rank []int  // node数
}
func NewUnionFind(size int) *UnionFind {
    d := make([]int, size)
    r := make([]int, size)
    for i := 0; i < size; i++ {
        d[i] = i
        r[i] = 1
    }
    return &UnionFind{Data: d, Rank: r}
}
",/Users/mbp/workspace/sandbox/algo/tree/unionFind.go
func (uf *UnionFind) FindRoot(node int) int ,"func (uf *UnionFind) FindRoot(node int) int {
    if node != uf.Data[node] {
        uf.Data[node] = uf.FindRoot(uf.Data[node])
    }
    return uf.Data[node]
}
",/Users/mbp/workspace/sandbox/algo/tree/unionFind.go
"func (uf *UnionFind) Union(a, b int) ","func (uf *UnionFind) Union(a, b int) {
    a2 := uf.FindRoot(a)
    b2 := uf.FindRoot(b)
    if a2 == b2 {
        return
    } else if uf.Rank[a2] >= uf.Rank[b2] {
        uf.Data[b2] = a2
        uf.Rank[a2] += uf.Rank[b2]
    } else {
        uf.Data[a2] = b2
        uf.Rank[b2] += uf.Rank[a2]
    }
}
",/Users/mbp/workspace/sandbox/algo/tree/unionFind.go
% 0 -> 1 -> 2 -> 3の順でプロセスkilled,"% 0 -> 1 -> 2 -> 3の順でプロセスkilled
c(0)->
    receive after 1000 -> exit(""DEAD"") end;
c(N) ->
    process_flag(trap_exit, true),  % EXITのシグナルキャッチ
    spawn_link(fun() -> c(N-1) end),
    receive {'EXIT', _Process, _Reason} = E -> io:format("":~p:"", [E]) end,  % Reason==""DEAD""
    io:format("":::~p:::"", [N]),  % 出力されない(trap_exit有無に関わらず呼ばれない)
    ok.
main() ->
    spawn_link(chain, c, [3]),
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/chain.erl
:Q:restarter,"start() ->
    spawn(?MODULE, restarter, []).
judge(Album) ->
    Ref = make_ref(),  % 自分宛のメールのID
    critic ! {self(), Ref, Album},
    receive
        {Ref, Criticism} -> {Criticism}
    after 2000 ->                                
            timeout
    end.
restarter() ->
    process_flag(trap_exit, true),
    Pid = spawn_link(?MODULE, critic, []),  % 関数とプロセス名同じでも動く
    register(critic, Pid),
    receive
        {'EXIT', Pid, normal} -> ok;
        {'EXIT', Pid, shutdown} -> ok;
        {'EXIT', Pid, _} -> restarter()
    end.
critic()->
    receive
        {From, Ref, {""A""}} ->
            From ! {Ref, ""A HOGE""};
        {From, Ref, _} ->
            From ! {Ref, ""HOGE HOGE !!!!""}
    end,
    critic().
main() ->
    start(),
    receive after 100 -> ok end,
    io:format(""~p~n"", [judge(""A"")]),
    exit(whereis(critic), kill),
    receive after 100 -> ok end,
    io:format(""~p~n"", [judge(""_"")]),
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/linkmon.erl
:Q:monitorの特徴,"% they are unidirectional
% they can be stacked.
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:monitorの正常戻り値,"    erlang:monitor(process, spawn(fun() -> timer:sleep(100) end)),
    receive {'DOWN', _Ref ,process, _Pid, normal} -> io:format(""DOWN~n"", []) end,
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:demonitorのinfo,"    Ref = erlang:monitor(process, spawn(fun() -> timer:sleep(5000) end)),
    io:format(""~p~n"", [demonitor(Ref, [info])]),  % まだ監視プロセスは生きているのでtrue
    receive _ -> io:format(""NOT REACHED~n"", []) after 100 -> ok end,
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:demonitorのflush,"    Ref2 = erlang:monitor(process, spawn(fun() -> ok end)),
    receive after 1000 -> ok end,
    io:format(""~p~n"", [demonitor(Ref2, [flush])]),  % メッセージ破棄(flushがないと、メッセージを受け取る)
    receive _ -> io:format(""NOT REACHED~n"", []) after 100 -> ok end,
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:linkの使いどころ,"% リンクは組織的な構造というもの以上の作りになっています。 アプリケーションの構造を設計するときに、どのプロセスがどんな役割をするか決めて、何が何に依存するかを決めるでしょう。 あるプロセスは他のプロセスを監視し、あるプロセスは双子のプロセスがいないと生きていらない、などです。 この構造は通常固定されていて、事前に知ることが出来ます。 
",/Users/mbp/workspace/sandbox/book/lyse/14/trap.erl
:Q:trapの種類,"% REPLではflush().を使ってメッセージを受け取ること
main () ->
    process_flag(trap_exit, true),
    spawn_link(fun() -> ok end),
    receive A1 -> io:format(""~p~n"", [A1]) end,  % {'EXIT',<0.58.0>,normal}
    spawn_link(fun() -> exit(""HOGE"") end),
    receive A2 -> io:format(""~p~n"", [A2]) end,  % {'EXIT',<0.58.0>,""HOGE""}
    spawn_link(fun() -> exit(normal) end),
    receive A3 -> io:format(""~p~n"", [A3]) end,  % {'EXIT',<0.58.0>,normal}
    spawn_link(fun() -> exit(self(), kill) end),
    receive A4 -> io:format(""~p~n"", [A4]) end,  % {'EXIT',<0.58.0>,killed}
    spawn_link(fun() -> exit(kill) end),
    receive A6 -> io:format(""~p~n"", [A6]) end,  % {'EXIT',<0.58.0>,kill}
    spawn_link(fun() -> 1/0 end),
    receive A5 -> io:format(""~p~n"", [A5]) end,  % {badarith}
    exit(spawn_link(fun() -> timer:sleep(100) end), reason),  % 外部からEXIT
    receive A7 -> io:format(""~p~n"", [A7]) end,  % {'EXIT',<0.64.0>,reason}
    io:format(""~nDONE~n"", []),
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/trap.erl
(define (extend-environment vars vals base-env),"(define (extend-environment vars vals base-env)
  (if (equal? (length vars) (length vals))
      (cons (cons vars vals) base-env)
      (error ""The lengths of vars and vals are not equal"")))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (lookup-variable-value var env),"(define (lookup-variable-value var env)
  (env-action var
              env
              car
              (lambda () (lookup-variable-value var (enclosing-environment env)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define  (set-variable-value! var val env),"(define  (set-variable-value! var val env)
  (env-action var
              env
              (lambda (vals) (set-car! vals val))
              (lambda () (set-variable-value! var val (enclosing-environment env)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (define-variable! var val env),"(define (define-variable! var val env)
  (env-action var
              env
              (lambda (vals) (set-car! vals val))
              (lambda () (add-binding-to-frame! var val (first-frame env)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (env-action var env found-action null-action),"(define (env-action var env found-action null-action)
  (define (scan-env var env)
    (define (loop vars vals)
      (cond ((null? vars) '())
            ((eq? var (car vars)) vals)
            (else (loop (cdr vars) (cdr vals)))))
    (let ((frame (first-frame env)))
      (loop (frame-variables frame)
            (frame-values frame))))
  (if (eq? env the-empty-environment)
      (error ""Unbound variable"" var)
      (let ((vals (scan-env var env)))
        (if (null? vals)
            (null-action)
            (found-action vals)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (eval-apply exp env),"(define (eval-apply exp env)
  (let* ((values (map (lambda (x) (eval x env)) exp))
         (proc (car values))
         (name (car proc))
         (args (cdr values)))
    (cond
     ((eq? name 'primitive)
      (let ((f (cadr proc)))
        (apply f args)))
      ((eq? name 'procedure)
       (let* ((vars (cadr proc))
              (exps (caddr proc))
              (base-env (cadddr proc))
              (new-env (extend-environment vars args base-env))
              (values (map (lambda (e) (eval e new-env)) exps)))
         (last values)))
     (else (error ""Unknown procedure"" proc)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/apply.scm
(define (eval-begin exp env),"(define (eval-begin exp env)
  (let ((exps (cdr exp)))
    (if (null? exps)
        0
        (let ((values (map (lambda (e) (eval e env)) exps)))
          (last values)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/begin.scm
(define (eval-define exp env),"(define (eval-define exp env)
  (let ((symbol (cadr exp))
        (expr (caddr exp)))
    (define-variable! symbol (eval expr env) env)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/define.scm
(define (eval-if exp env),"(define (eval-if exp env)
  (let ((pred (cadr   exp))
        (true (caddr  exp))
        (false-body (cdddr exp)))
    (if (eval pred env)
        (eval true env)
        (if (null? false-body)
            '()
            (last (map (lambda (e) (eval e env)) false-body))))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/if.scm
(define (eval-let exp env),"(define (eval-let exp env)
  (let* ((var-arg (cadr exp))
         (body (caddr exp))
         (vars (map car var-arg))
         (args (map cadr var-arg)))
  (eval `((lambda ,vars ,body) ,@args) env)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/let.scm
(define (eval-quote exp env),"(define (eval-quote exp env)
; (quote EXPR)
  (cadr exp))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/quote.scm
(define (eval exp env),"(define (eval exp env)
  (cond
   ; atom
   ((string? exp) exp)
   ((number? exp) exp)
   ((symbol? exp) (lookup-variable-value exp env))
   ((member (car exp) load-names)
    (let* ((name (format ""eval-~A"" (symbol->string (car exp))))
           (f (builtin-eval (string->symbol name) (interaction-environment))))
      (f exp env)))
   ((pair? exp) (eval-apply exp env))
   (else (error ""Unknown exp"" exp))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval.scm
(define (self-evaluating? exp),"(define (self-evaluating? exp)
  (cond ((number? exp) #t)
        ((string? exp) #t)
        (else #f)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval.scm
(define (setup-environment),"(define (setup-environment)
  (let ((initial-env (extend-environment
                      (map (lambda (a) (car a)) primitive-procedures)
                      (map (lambda (a) (list 'primitive (cadr a))) primitive-procedures)
                      the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/main.scm
(define (driver-loop),"(define (driver-loop)
  (print ""> "")
  (let* ((intput (read))
         (output (eval intput the-global-environment)))
    (print output)
    (driver-loop)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/main.scm
func brace(str string) bool ,"func brace(str string) bool {
	s := []byte{}
	for i := 0; i < len(str); i++ {
		c := str[i]
		if c == '(' || c == '{' || c == '[' {
			s = append(s, c)
		} else {
			if len(s) == 0 {  // s[]の参照するので、その前に要素があるか確認が必要
				return false
			} else {
				s0 := s[len(s)-1]
				s = s[:len(s)-1]
				if (c == ')' && s0 == '(') || (c == ']' && s0 == '[') || (c == '}' && s0 == '{') {
				} else {
					return false
				}
			}
		}
	}
	if len(s) == 0 {  // これがないと({[を受理してしまう
		return true
	} else {
		return false
	}
}
",/Users/mbp/workspace/sandbox/compiler/brace/brace.go
:Q:JSONのdata,"data JSON = 
    Number Double
  | Null
  | JsonString String
  | Bool Bool
  | Array [JSON]
  | Object [(String, JSON)]
  deriving (Show, Eq)
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
literalString :: Parser String,"literalString :: Parser String
literalString = do
  char '""'
  xs <- many $ noneOf ""\""""
  char '""'
  return xs
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
parseTrue :: Parser JSON,"parseTrue :: Parser JSON
parseTrue = string ""true"" *> (return $ Bool True)
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
parseArray :: Parser JSON,"parseArray :: Parser JSON
parseArray = do
  char '['
  xs <- sepBy (ws *> jsonValue <* ws) (char ',')
  char ']'
  return $ Array xs
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
parseObject :: Parser JSON,"parseObject :: Parser JSON
parseObject = do
  char '{'
  xs <- sepBy (ws *> parseEntry <* ws) (char ',')
  char '}'
  return $ Object xs
parseEntry :: Parser (String, JSON)
parseEntry = do
  key <- literalString  -- WARN: not parseString
  char ':'
  val <- jsonValue
  return (key,  val)
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
jsonValue :: Parser JSON,"jsonValue :: Parser JSON
jsonValue =
      parseBool
  <|> parseNull
  <|> parseString
  <|> parseNumber
  <|> parseArray
  <|> parseObject
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
solveRPN :: String -> Float,"solveRPN :: String -> Float
solveRPN = head . foldl foldingFunction [] . words
    where
      foldingFunction (x:y:ys) ""*"" = (x * y):ys
      foldingFunction (x:y:ys) ""+"" = (x + y):ys
      foldingFunction (x:y:ys) ""-"" = (y - x):ys
      foldingFunction (x:y:ys) ""/"" = (y / x):ys
      foldingFunction (x:y:ys) ""^"" = (y ** x):ys
      foldingFunction (x:xs) ""ln"" = log x:xs
      foldingFunction xs ""sum"" = [sum xs]
      foldingFunction xs numberString = read numberString:xs
main = do
  print $ solveRPN ""1 2 3 + +""   -- 6.0
  print $ solveRPN ""90 34 12 33 55 66 + * - + -""  -- 4037.0
",/Users/mbp/workspace/sandbox/compiler/lang/solveRPN.hs
-->,"### 委譲 子供 => 親
```
# 移譲することで、継承せずに親のメソッドを利用できる
class Node(object):
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent  # Noneの場合は、root
    def handle(self, item):
        if self.check(item):
           # do handle in this class
        elif self.parent:
           # Can not handle item so pass it to parent
           self.parent.handle(item)
```
",/Users/mbp/workspace/sandbox/design-pattern/chain_of_responsibility/chain_of_responsibility.md,,
-->,"## Composite Patternとの違い
親=>子と進む(composite)か、子=>親と進む(COR)の違い
",/Users/mbp/workspace/sandbox/design-pattern/chain_of_responsibility/chain_of_responsibility.md
class Logger(object):,"class Logger(object):
    def log(self, msg, level):   # request method
        if level <= self.level:  # Responsibility
            self.message(msg)
        elif self.next:
            self.next.log(msg, level)  # Chain
        else:
            print(""No Logger"")
",/Users/mbp/workspace/sandbox/design-pattern/chain_of_responsibility/log.py
interface EntryInterface ,"interface EntryInterface {
    public String name = """";
    public void remove();
}
class Directory implements EntryInterface {
    public String name;
    Directory(String name) { this.name = name; }
    ArrayList<EntryInterface> entries = new ArrayList<>();
    public void add(EntryInterface e) { entries.add(e); }
    public void remove() {
        for (EntryInterface e: entries) { e.remove(); }
        System.out.printf(""Remove a %s directory\n"", name);
    }
}
class File implements EntryInterface {
    public String name;
    File(String name) { this.name = name; }
    public void remove() { System.out.printf(""Remove a %s file\n"", name); }  // Leafなので探査終了
    public static void main (String[] args) {
        Directory root = new Directory(""root"");
        for (int i: Arrays.asList(1,2,3,4,5))
            root.add(new File(String.format(""text%d.txt"", i)));
        Directory sub = new Directory(""sub dir"");
        for (int i: Arrays.asList(1,2,3,4,5))
            sub.add(new File(String.format(""music%d.mp3"", i)));
        root.add(sub);
        System.out.println(""Call a remove method of a root directory..."");
        root.remove();
    }
}
",/Users/mbp/workspace/sandbox/design-pattern/composite/File.java
-->,"### 参照方向 子供 => 親
```
# 親の参照しかないときは、rootには行き着くが、他の子供へは行けない
class Node(object):
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent  # Noneの場合は、root
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 => 親 list
```
data[child] = parent
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 <= 親
```
# 子供をもつときは、rootから再帰的に木構造を辿れる
class Node(object):
    def __init__(self, value):
        self.value = value
        self.children = []
    def append(self, value):
        self.children.append(Node(value))
    def iter(self):  # 木構造を再帰的に辿る(composite's operation method)
        for child in self.children:
            child.iter()
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 <=> 親
```
class Node(object):
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent
        self.children = []
    def append(self, value):
        self.children.append(Node(value, parent=self))
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 => 親
```
class Root(object):
    def method(self): pass
class Node(object):
    def __init__(self, parent):
        self.parent = parent
    def method(self):
        self.parent.method()
```
",/Users/mbp/workspace/sandbox/design-pattern/decorator/decorator.md,,
-->,"## Composite Patternとの違い
Nodeを別々と見る(composite)か、全てのNodeを同一視する(decorator)かの違い
",/Users/mbp/workspace/sandbox/design-pattern/decorator/decorator.md
class Human(object):  # concreat component,"class Human(object):  # concreat component
    def __init__(self, name):
        self.name = name
    def dressup(self):  # operation
        return self.name
class Cloth(object):  # concreat decorator
    def __init__(self, human):
        self._human = human
    def dressup(self):
        return self._human.dressup() + "" +cloth""
class Shoe(object):
    def __init__(self, human):
        self._human = human
    def dressup(self):
        return self._human.dressup() + "" +shoe""
human = Cloth(Cloth(Shoe(Human(""Bob""))))  # 重ね着可能
print(human.dressup())
",/Users/mbp/workspace/sandbox/design-pattern/decorator/human.py
-->,"### A <>-- B
`A <>-- B`とは、AがBを所有している(one or many).
このことをコードで表すと、下記のようになる.
```
class A:
   def __init__(self, B):
      self.B = B
```
",/Users/mbp/workspace/sandbox/design-pattern/index.md,,
-->,"## Patternごと違い
- データ構造(1:N, N:N, 1:1(委譲))
- 共通インターフェイスを持つ
- 記述はcaller or callee側?(interfaceと実装の区別)
- 分岐if(classで代用)
- Node, Leaf, Rootを区別するか?(狭義: wrapしたものを同一視するか?)
",/Users/mbp/workspace/sandbox/design-pattern/index.md
-->,"# Mediator Pattern
**N:Nの関係があるとき、N+1番目を用意してN:1の関係に変更するようなbrokerを用意**
",/Users/mbp/workspace/sandbox/design-pattern/mediator/mediator.md
-->,"### クラス図
```
class Broker: pass  # intermideate table
class Publisher: publish(self, msg)
class Subscriber: handle(self, publisher, msg)
```
",/Users/mbp/workspace/sandbox/design-pattern/mediator/mediator.md,,
class Broker(object):,"class Broker(object):
    def __init__(self):
        self.registry = []
    def publish(self, publisher, msg):
        for (pub, sub) in self.registry:
            if pub is publisher:
                sub.handle(pub, msg)
    def subscribe(self, subscriber, publisher):
        self.registry.append((publisher, subscriber))
class Publisher(object):
    def __init__(self, name, broker):
        self.name = name
        self.broker = broker
    def publish(self, msg):
        self.broker.publish(self, msg)
class Subscriber(object):
    def __init__(self, name, broker):
        self.name = name
        self.broker = broker
    def subscribe(self, publisher):
        self.broker.subscribe(self, publisher)
    def handle(self, publisher, msg):
        print(""%s got %s from %s"" % (self.name, msg, publisher.name))
",/Users/mbp/workspace/sandbox/design-pattern/mediator/pubsub.py
-->,"### クラス図
```
class Parent:
    def __init__(self):
        self.children = []
   def notfiy(self, msg):
       for c in self.children:
           c.nofify(msg)
```
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.md,,
-->,"## pubsub pattern との違い
どちらもN:Nの関係であるが、brokerあり(pubsub)、なし(observer)の違い
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.md
-->,"## composite pattern との違い
再帰的1:N関係かつ(composite)と非再帰的N:N関係(observer)の違い
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.md
class Subject:,"class Subject:
    def __init__(self, name):
        self.name = name
        self._observers = []
    def register(self, *observers):
        for observer in observers:
            self._observers.append(observer)
    def notify(self, *args, **kwargs):
        for o in self._observers:
            o.notify(self, *args, **kwargs)
class Observer:
    def __init__(self, name):
        self.name = name
    def notify(self, observable, *args, **kwargs):
        print(self.name, 'Got', args, kwargs, 'From', observable.name)
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.py
"func stack_ack(m, n int) int ","func stack_ack(m, n int) int {
	S := []int{}
	for {
		if m == 0 {
			n++  // (elseの戻り値になってる)
			if len(S) == 0 {  // 空なら計算終了
				return n
			} else {
				m = S[len(S)-1]
				S = S[:len(S)-1]
			}
		} else if n == 0 {
			// m -> (m-1), n -> 1
			m--
			n = 1
		} else {
			// (ack m (- n 1))を先に計算する。戻ってきたら、m -> (m-1), n -> (+ n 1)
			S = append(S, m-1)
			n--
		}
	}
}
",/Users/mbp/workspace/sandbox/design-pattern/stack/ack.go
"def add(p1, p2):","def add(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return (x1 + x2, y1 + y2)
class Normal(object):
    def move(self, dx, dy):
        return (dx * 1, dy * 1)
class Fast(object):
    def move(self, dx, dy):
        return (dx * 2, dy * 2)
class Slow(object):
    def move(self, dx, dy):
        return (dx * 0.5, dy * 0.5)
class Player(object):
    def __init__(self):
        self.position = (0, 0)
        self.state = Normal()
    def change(self, state):
        self.state = state
    def up(self):
        self.move(1, 0)
    def down(self):
        self.move(-1, 0)
    def left(self):
        self.move(0, 1)
    def right(self):
        self.move(0, -1)
    def move(self, dx, dy):
        self.position = add(self.state.move(dx, dy), self.position)
        print(""(%s, %s)"" % self.position)
",/Users/mbp/workspace/sandbox/design-pattern/state/state.py
interface Acceptor ,"interface Acceptor {
    public void accept (final Visitor v);
}
class A1 implements Acceptor {
    public void accept (Visitor v) {
        v.visit(this);
    }
}
class A2 implements Acceptor {
    public void accept (Visitor v) {
        v.visit(this);
    }
}
class Visitor {
    public void visit (A1 a) {
        System.out.println(""visit A1"");
    }
    public void visit (A2 a) {
        System.out.println(""visit A2"");
    }
}
public class DoubleDispatch {
    public static void main (String[] args) {
        System.out.println(""create visitor"");
        (new Visitor()).visit(new A1());
        (new Visitor()).visit(new A2());
        System.out.println(""create acceptor"");
        (new A1()).accept(new Visitor());
        (new A2()).accept(new Visitor());
        System.out.println(""for each acceptor"");
        // visitorパターンを使うとvisitの呼び出しを動的に決定できる
        for (Acceptor a: new Acceptor[] {new A1(), new A2(), new A1()}){
            a.accept(new Visitor());
            // (new Visitor()).visit(a); // compile error!
            }
    }
}
",/Users/mbp/workspace/sandbox/design-pattern/visitor/DoubleDispatch.java
class Visitor(object):,"class Visitor(object):
    def visit(self, acceptor):
        # return getattr(self, ""visit_%s"" % acceptor.__class__.__name__)(acceptor)
        return acceptor.accept(self)  # 型あり言語の場合、acceptを全て記述する必要あり(for compiler)
    def visit_List(self, acceptor):
        assert len(acceptor.children) >= 2
        op = self.visit(acceptor.children[0])
        args = [self.visit(n) for n in acceptor.children[1:]]
        return op(args)
    def visit_Op(self, acceptor):
        return acceptor.op
    def visit_Atom(self, acceptor):
        return acceptor.value
class Acceptor(object):
    pass
class List(Acceptor):
    def __init__(self, children):
        assert isinstance(children, list)
        self.children = children
    def accept(self, visitor):
        return visitor.visit_List(self)
class Op(Acceptor):
    def __init__(self, op):
        self.op = op  # op takes only a list as an argument
    def accept(self, visitor):
        return visitor.visit_Op(self)
class Atom(Acceptor):
    def __init__(self, value):
        self.value = value
    def accept(self, visitor):
        return visitor.visit_Atom(self)
",/Users/mbp/workspace/sandbox/design-pattern/visitor/double_dispath.py
-->,"## Interface
### visit
```
# 木構造をAccptorで作成
def Acceptor(object):  # 各Node
    def accept(self, visitor):
        return visitor.visit_XXX(self)
# 各Nodeに訪れた場合の動作をそれぞれ定義
def Visitor(object):
    def visit(self, acceptor):
        return acceptor.accept(self)
    def visit_XXX(self, acceptor):
        pass
```
",/Users/mbp/workspace/sandbox/design-pattern/visitor/visitor.md,,
:Q:monotonicClockとは?,"不特定のエポックからの単調増加な時刻(時刻が巻き戻ったり settimeofday などで調整されたりしない)
",/Users/mbp/workspace/sandbox/lang/go/README.md
:Q:byteの文字列を文字リストへ変換,"    if ! bytes.Equal([]byte(""abc""), []byte{'a', 'b', 'c'}) {
        // stringtoslicebyteによりコピーが走る
        t.Errorf(""abc == 'a' 'b' 'c'"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/byte_test.go
:Q:Goの参照型,"// *int, []int, []*int, *TypeStruct, []TypeStruct, []*TypeStruct
// []*int{&1}は不可. []*S{{A: 1}}は可.
",/Users/mbp/workspace/sandbox/lang/go/basic/deepcopy_test.go
:Q:コピーが走る例,"// 代入文の右辺が実体の時`b := a`は、コピーが走る
// a := (Struct)b // 構造体の値渡し代入
// a := ([]Struct)b[0]  // スライス構造体のindexアクセスによる代入
",/Users/mbp/workspace/sandbox/lang/go/basic/deepcopy_test.go
:Q:makeを使う場合の条件,"- Create a channel
- Create a map with space preallocated
- Create a slice with space preallocated or with len != cap
*/
",/Users/mbp/workspace/sandbox/lang/go/basic/make_test.go
:Q:defar機能,"// defer ステートメントは、 defer へ渡した関数の実行を、呼び出し元の関数の終わり(returnする)まで遅延させるものです。
// defer へ渡した関数の引数は、すぐに評価されますが、その関数自体は呼び出し元の関数がreturnするまで実行されません
// defer へ渡した関数が複数ある場合、その呼び出しはスタック( stack )されます。 呼び出し元の関数がreturnするとき、 defer へ渡した関数は LIFO(last-in-first-out) の順番で実行されます。
",/Users/mbp/workspace/sandbox/lang/go/basic/op_test.go
:Q:reflectが必要になるところ,"// 実行時に値が決定するもの: fmt, template
",/Users/mbp/workspace/sandbox/lang/go/basic/reflect_test.go
:Q:appendの注意点,"- 毎回コピーが走る(dst側については)
- capがオーバーしたらreallocが走り、全要素コピー
- 特にmakeの初期化した場合のサイズは0でない
https://blog.golang.org/slices
*/
func TestAppend1(t *testing.T) {
    s0 := make([]int, 5)
    // 最大capcityの最後にappend
    // そのためcapオーバーする
    s1 := append(s0, 1)
    if len(s1) != 6 && s1[2] == 0 {
        t.Error(""5+1=6"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/slice_test.go
:Q:newの使い道,"func TestNew(t *testing.T) {
    // it makes easier is creating pointers to non-composite types
    f1 := func () *int {
        return new(int)
    }
    f2 := func () *int {
        var i int
        return &i
    }
    if *f1() != 0 {
        t.Error(""参照を"")
    }
    if *f2() != 0 {
        t.Error(""参照を"")
    }
}
",/Users/mbp/workspace/sandbox/lang/go/basic/slice_test.go
:Q:[]byteとstringの違い,"1. slice や要素の address をとれない
2. 要素単位の書き換えができない, immutable: x[i] = 1 とか NG.
3. ""A"" == ""B""可能. []byte{'a'} == []byte{'b'}不可(slice can only be compared to nil)
*/
",/Users/mbp/workspace/sandbox/lang/go/basic/string_test.go
:Q:[]byte型の別称,"    // byteはuint8のエイリアス
    if ""abc"" != string([]byte{'a', 'b', 'c'}) {
        t.Errorf(""abc"")
    }
    if ""abc"" != string([]uint8{'a', 'b', 'c'}) {
        t.Errorf(""abc"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/unicode_test.go
:Q:unicodeの１文字単位に用いられる型,"    // runeはint32のエイリアス
    if ""あいう"" != string([]rune{'あ', 'い', 'う'}) {
        t.Errorf(""あいう"")
    }
    if ""あいう"" != string([]int32{'あ', 'い', 'う'}) {
        t.Errorf(""あいう"")
    }
    
    // MEMO: :Q:stringのindexアクセス""あ""
    if ! (""あ""[0] == 0xe3 && ""あ""[1] == 0x81 && ""あ""[2] == 0x82){
        t.Errorf(""\xe3\x81\x82"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/unicode_test.go
":Q:stringのrangeアクセス""あいう""","    for i, v := range ""あいう"" {
        // byteの長さではなく、文字数回ループする
        switch {
        case i == 0 && v == 12354:
        case i == 3 && v == 12356:
        case i == 6 && v == 'う':
        default:
            t.Errorf(""%d %c"", i, v)
        }
    }
}
",/Users/mbp/workspace/sandbox/lang/go/basic/unicode_test.go
:Q:byteの文字列を文字リストへ変換,"    s := ""hello world""
    b := *(*[]byte)(unsafe.Pointer(&s))
    // b[0] = 'a'  // 代入は失敗する
    print(b)
}
",/Users/mbp/workspace/sandbox/lang/go/basic/unsafe_test.go
:Q:標準出力とエラーを交換する,"echo hoge 3>&1 1>&2 2>&3 | less  # 標準エラーに出力されるので何も表示されない
# &はポインタみたいなものか.
",/Users/mbp/workspace/sandbox/lang/sh/run.sh
:Q:標準出力を閉じる,"ls >&-
",/Users/mbp/workspace/sandbox/lang/sh/run.sh
1 in [1] === false,"// in演算子はpropertyの存在確認
> 0 in [0,1,2,3]
true
> 30 in [0,1,2,30]
",/Users/mbp/workspace/sandbox/lang/ts/base.ts
""", 2)","	if len(ss) == 1 {
",/Users/mbp/workspace/sandbox/main.go
""") ","			r := ParseMemo(t)
			first := """"
			second := """"
			if scanner.Scan() {
				first = scanner.Text()
			}
			if r.Q == """" {
				r.Q = first
			}
			second = first + ""\n""
			for scanner.Scan() {
				t2 := scanner.Text()
				if t2 == """" {
					break
				}
				second += t2 + ""\n""
			}
			r.A = second
			r.path = path
			c.WriteRecord(r)
		}
	}
}
",/Users/mbp/workspace/sandbox/main.go
:Q:クラスタの分け方,"trains = np.array([[-1, -1], [1, 1]])  # len(X) == len(Y)
labels = np.array([1, 2])
clf = GaussianNB()
clf.fit(trains, labels)  # predictよりも時間がかかる
preds = clf.predict(tests)
# predとtestの一致した個数/test数
accuracy = (preds == expecteds) / len(preds)
print(accuracy)
",/Users/mbp/workspace/sandbox/math/src/GuassianNB.py
-->,"### 1bitとは
0と1ので表せる単位
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 1byteとは何bit?
1byte = 8bit
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 8bytesとは何bit?
8bytes = 64bit
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 32bitsとは何byte?
32bits = 4bytes
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 1byteで表せる10進数の範囲
0 ~ 2^8 - 1 (0b0000 0000 ~ 0b1111 1111)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 1byteで表せる16進数の範囲
0x00 ~ 0xFF (Fは2^4なので0bF = 0b1111)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### ~0とは
-1
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 2 ^ j (0<=j<=2)
- 1 << 0 == 0b1
- 1 << 1 == 0b10
- 1 << 2 == 0b100
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 0b10101の2^4倍
10進数の場合は、10^nの倍数だとイメージがつきやすい`12345*10^4 = 123450000`
同じように、2進数でも2^4を掛ければ、`0b10101*2^4 = 0b101010000`となる
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## a1bのマイナスの表現
`NUM = a1b` とおく. ただしbは全て0とするので、1が一番最後の桁となる.
2の補数表現を使うと、`-NUM = ~(a1b) + 1` とおける。
チルダ演算子は、それぞれのbitを反転させるだけなので、`-NUM = ~a0~b + 1`
bは全て0なので反転させると全て1
`-NUM = ~a0(111...1) + 1 = ~a1(000...0) = ~a1b`
よって、`-NUM = ~a1b`
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## x & -x
NUM & ~NUM = a1b & ~a1b = 1b = 1000... (xの最も右側に存在する1)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## perl -E '$i=0b101; for(1..3){$i+=$i&-$i; say sprintf ""%b"", $i;}'
101 => 110 => 1000 => 10000
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## perl -E '$i=0b10110; for(1..3){$i-=$i&-$i; say sprintf ""%b"", $i;}'
10110 => 10100 => 10000 => 0
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## perl -E '$i=0b10110;for(1..3){$i=$i&($i-1); say sprintf ""%b"", $i;}'
0b010110 => 0b010100 => 0b010000 => 0b000000
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## all, any, not all, not anyがTrueになる条件
- all: 全てTrue
- any: 少なくとも一つTrue
- not all: 少なくとも一つFalse
- not any: 全てFalse
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## check whether a number is even or odd
`x & 1` (0なら偶数)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## Check power of 2
`x & (x-1)` (0なら2の累乗)
2の累乗数は、10...00で表せる。そこから1引いた数は11..11となる。そのため２つの&は常に0
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## What's Two Compliment?
x => ~x + 1 (x + (~x + 1) = 0)
2の補数は、符号を入れ替えるだけ
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## What's One Compliment?
x => ~x (x + ~x = -1)
すべてのbitを反転したもの
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 1の2の補数は?
-1 = (0xFFFF)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 13の2の補数は?
`13 = 8 + 4 + 1 = ^3 + ^2 + ^0 = 0b0000 1101` よって
-13 = ~(13) + 1 = 0b0010 + 1 = 0b1111 0011
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 2の補数をその場で思い出すには?
1 = 0b00000001と-1 = 0b11111111の二つの関係より
2の補数は`NUM = ~NUM + 1`という関係性がすぐ思い出せる。
なお、0の場合も当てはまる0b0000 = (0b1111) + 1
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"# べき乗
Xを集合とする。 Xの部分集合全体を2^xとし、異なるn個の中で構成される全ての組み合わせ
f(0) &=& {$phi}
f(n) &=& ${ {a_n} $cup x $mid x $in f(n-1) $} $cup f(n-1)
",/Users/mbp/workspace/sandbox/math/tex/cases/index.md
-->,"## (e^x)'
e^x
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (x^n)'
nx^(n-1)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (sinx)'
cosx
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (cosx)'
-sinx
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (logx)'
1/x
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## {f(x)g(x)}'
f(x)'g(x) + f(x)g(x)'
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Gamma関数
F(n) = I[0,inf] t^(n-1)e^(-t) dt
階乗を自然数でない正の実数にまで拡張
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Gamma(n+1)=n!の証明
F(1) = I[0,inf] e^(-t) dt = [-e^(-t)] = 1
F(n+1) = - ([t^(n-1)e^(-t)] - I[0,inf] nt^n e^(-t) dt)
 = 0 + n F(n) = n F(n) = n (n-1) F(n-1) = n! F(1) = n!
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Gamma(1/2)
root(pi)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Beta関数
B(x,y) = I[0,1] t^(x-1) (1-t)^(y-1) dt
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Beta関数(整数)
B(a,b) = (a-1)!(b-1)!/(a+b-1)! = F(a)F(b)/F(a+b)
beta関数はgammna関数で表せる
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Sigmoid関数
f(x) = 1 / (1 + e^(-ax)) (a>0)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Sigmoid関数が点対称であることを示せ
f(x) + f(-x) = 1より、(0, 1/2)で点対称
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## ガウス積分
I[-inf,inf] e^(-x^2) = root(pi)
I^2 = II e^(-r2) dxdy = I[0,inf]I[0,2pi] e^(-r^2) r dsdr
= piI 2e^(-r^2) r = pi [-e^(-r^2)] = pi(0 - (-e^0)) = pi
よって I^2=pi より、I = root(pi)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## ヤコビアンによる置換積分の公式
J = d(x,y)/d(u,v) = det [[dx/du, dx/dv],[dy/du, dy/dv]] とし
II f(x,y) dxdy = II g(u,v) |J| dudv
つまり、変数変換すると面積とその領域も変換する必要がある.
要するにヤコビアンは微小面積比のこと
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## ヤコビアンによる置換積分(-inf<x, y<inf)のrとシータaの領域
(x, y) = (rcosa, rsina) とすると、領域はxyの平面全域 (円状に領域が増加)
よって、0<r<inf, 0<a<2pi
J = det [[cosa, -rsina], [sina, rconsa]] = rcosa^2 + rsina^2 = r 
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"# 固有値
**n次正方行列Aの固有値aは、x != 0に対して、Ax=axを満たすxが存在するときのaとする。またxを固有ベクトルと呼ぶ**
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/eigenvalue.md
-->,"## 固有空間
```math
aがAの固有値 $Leftrightarrow det(A-aE)=0
```
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/eigenvalue.md,math,
-->,"## 対角化の性質
- Aが対角化可能 <=> n個の1次独立な固有ベクトルをもつ
- n個の異なる固有値をもつ => Aは対角化可能
- 行列AとBが対角化可能 <=> AB=BA
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/eigenvalue.md
-->,"## 群の定義
- (a X b) X c = a X (b X c) (結合法則)
- a X e = e X a = a (単位元の存在)
- a X x = x X a = e (逆元xの存在)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 可換群(アーベル群)
群の性質に加えて可換も成立. a X b = b X a
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 写像
集合AからBへの写像f: A -> B とは、$a \in A$ と $f(a) \in B$ 対応させるもの
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 単射
fが単射とは、 $a \ne b => f(a) \ne f(b)$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 全射
fが全射とは  $\forall b \in B, \exists a \in A$ について $f(a) = b$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 全単射の性質
- $全単射 <=> 逆写像f^{-1}が存在$
- $全単射 <=> 単射かつ全射$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## Aが有限個の元からなる集合の時AからAの写像fは、単射であれば、全単射になることを示せ
A = {a1, ... an}とおき、それぞれfで変換すると、A'={f(a1), ... f(an)}なるが、
単射の性質より、全て異なるものに対応する、かつ要素数がnなので、A'=Aが言えるため全射である.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## Aが有限個の元からなる集合の時AからAの写像は、全射であれば、全単射になることを示せ
もし、単射でないならば、a!=b => f(a)=f(b)となるような、aとbが存在することになるが、
これは、n個の要素から、(n-1)いかに対応づけられたことを意味する。
(関数は入力1つに対して出力1つだけ. つまり、減ることはあっても増えることは絶対ないので、)
全射であるので、n個に対応づくことに矛盾する。よって単射である。
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## (全)単射の関数の例
- 全単射 => f(x) = ax + b
- 単射   => f(x) = e^x
- 全射   => f(x) = x^2 (ただしf(x)>=0)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 行列の積
$l \times m$ 行列Aと $m \times n$ 行列Bの積は、$l $times n$ 行列AB となり、
$AB_{ij} = \sum_{k=1}^m a_{ik} b_{kj}$ と定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### A^{-k}= (A^k)^{-1} = (A^{-1})^k
(AA...A)(A^{-1}...A^{-1})=E
A^k(A^{-1})^k=E より
(A^k)^{-1} = (A^{-1})^k
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 対角行列の逆行列
diag (a1, ..., an) diag (1/a1, ..., 1/an) = E より明らか
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### (AB)C = A(BC) (結合法則) の証明
$ab_{ij}  = \sum_{p=1}^m a_{ip} b_{pj}$ より、j -> qと置き換えて
$(ab)c_{ij} = \sum_{q=1}^n ab_{iq} c_{qj} = \sum_{q=1}^n (\sum_{p=1}^m a_{ip} b_{pq} \c_{qj})$ としcをsumの内側にして、 sumを入れ替える.
$\sum_{p=1}^m a_{ip} (\sum_{q=1}^n  b_{pq} \c_{qj}) $ さらにaはqに無関係なので、２つ目のsumの外側へ.
$= \sum_{p=1}^m a_{ip} bc_{pj} = a(bc)_{ij}$ よって、 $(AB)C = A(BC)$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### A = AE = EA を示せ
$ae_{ij} = \sum_{k=1}^m a_{ik} e_{kj} = a_{i1} e_{1j} + ... + a_{ij} e_{jj} + ... + a_{im} e_{mj}$ より、1つを除いて0になるので、
$ae_{ij} = a_{ij}$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 転置行列
${}^t A = a_{ji}$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 対角行列AのA^k
AA[ij]
 = sum a[ik]a[kj] = a[ii]a[ij] + a[ij]a[jj] = 0 (i!=j)
 = a[ii]a[ii] = a[ii]^2 (i==j)
(a[ii]とa[jj]以外は0)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size xy^t
(n*1)(1*n)なので(n*n)の行列 (xとyは縦ベクトル)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size x^ty
(1*n)(n*1)なので(1*1)の定数
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size xy
(n*1)(n*1)なので未定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size x^ty^t
(1*n)(1*n)なので未定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size x^tE
(1*n)(n*n)なので(1*n)のベクトル
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size xE
(n*1)(n*n)なので未定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### ${}^t (AB) = {}^t B {}^t A$ の証明
$AB_{ij} = \sum_{p=1}^m a_{ip} b_{pj}$ として、ABの転置をとると
${}^t (AB_{ij}) = AB_{ji} = \sum_{p=1}^m a_{jp} b_{pi} = \sum_{p=1}^m b_{pi} a_{jp}$ となるが、
$b_{pi}={}^t b_{ip}, a_{jp} = {}^t a_{pj}$ より
$\sum_{p=1}^m {}^t b_{ip} {}^t a_{pj} = {}^t B {}^t A$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 対象行列(symmetric matrix)
${}^t A = A$ を満たす正方行列A
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 交代行列(skew symmetric matrix)
${}^t A = -A$ を満たす正方行列A
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## エルミート行列
$A^{*} = A$ を満たす複素数正方行列A
A^{*}は、Aの転置かつ共役複素数にしたもの
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 正則行列定義
n次正方行列Aに対してXが存在し XA = AX = E を満たせば、XはAの逆行列
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 正則行列と同値(9)
正則行列は正方行列でもある.
また、正則行列は単射の条件を満たせば全射でもある(逆も然り)
- 逆行列 $A^{-1}$ が存在
- det A !=0
- rankA=n
- dim Im A = n (全射)
- dim Ker A = 0 (単射)
- 線形写像 $T_A(x)=Ax$ は全単射
- $\sum_i^n x_i a_i$ が一次独立
- 斎次方程式 $Ax=0$ は自明の解のみ
- Aが固有値0を持たない 
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 逆行列は一意に決まることの証明
Aの逆行列をX, Yとして、 $AY = E, XA = E$ を用いて
$X=XE=X(AY)=(XA)Y=EY=Y$ よって $X=Y$ より一意であることが示せた
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### $(AB)^{-1} = B^{-1} A^{-1}$ を示せ
$E = A A^{-1} = A (B B^{-1}) A^{-1} = (AB)(B^{-1} A^{-1})$
$AX=E$ の形にできれば、Xが逆行列となる。
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 正方行列Aのある列が0ベクトルならば、Aは正則ではない
$XA = (Xa_1, ..., X*0, ..., Xa_n) != E$ よって逆行列は存在しない
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 置換
{1..n}から{1..n}への全単射の集合を $S_n$ とし、その要素を置換と呼ぶ
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 互換
{1..n}のうち2のみを動かし残りは、そのままな置換を互換と呼ぶ
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 置換$s -> s^{-1}$ により与えられる写像Sn->Snは全単射
(意味: ある置換に対して、その逆写像を対応づける関数)
それぞれの置換は{1..n}->{n!通り}に対応づけるが、s1!=s2であれば、s1^{-1}!=s2^{-1}が成立(単射)
またSnの要素sはn!通りあり、単射であるので、要素数が減ることはない。
Sn->Snと同じ集合に対応づけているので、全射も成立する.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### ある置換tについて、s -> st により与えられる写像Sn->Snは全単射
$s1!=s2 => s1t!=s2t$ であるから
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### sgn
$sgn(\sigma) = \prod_{i,j} \frac{\sigma(i) - \sigma(j)}{i-j}$
分母は正にできるので、s(i)>s(j)の転倒数が偶数なら1(+1 or -1のみとる)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### sgn関数の性質
- sgn(e) = 1
- sgn(互換) = -1
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の定義
$|A| = det A = \sum_{s \in S_n} sgn(s) a_{1s(1)} a_{2s(2)} ... a_{ns(n)}$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の多重線形性
- $det (a_1, ..., a_j + a_J, ..., a_n) = det (a_1, ..., a_j, ..., a_n) + det (a_1, ..., a_J, ..., a_n)$
- $det (a_1, ..., ca_j, ..., a_n) = c det (a_1, ..., a_j, ..., a_n)$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 多重線形性の証明
定義より簡単に
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の交代性
det(a_{t(1)}, ... a_{t(n)}) = sgn(t) det(a_1, ... , a_n)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の交代性の証明
集合を全単射した集合の和は順番が変わっただけなので等しいことを利用して、
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### $det AB = det A det B$を示せ
多重線形性より、$det(AB) = \sum b_{i_1,1} ... b_{i_n,n} det (a_{i_1},...a_{i_n})$ と記述できる.
同一の列が存在するときは、det A = 0になるので、その項を除外すると、i1...inが全て異なる項のみ残る.
置換t{1..n}={i(1)..i(n)}を利用して
$$
det(AB) = \sum b_{t(1)1} ... b_{t(n)n} det (a_{t(1)},..., a_{t(n)})
 = \sum sgn(t) b_{t(1)1} ... b_{t(n)n} det (a_1,..., a_n)
 = det B * det A
$$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 0を含む列 or 行が存在するならば|A|=0を示せx
行列式の定義より、 $\sum_{s} \p a_{is(i)}$ 少なくとも1つが0になるので、合計も0となる
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### $det {}_t A = det A$ の証明
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の多重線形性+交代性から導ける定理
ある列に他の列の定数倍を加えてもよい
$det (a_1, ..., a_i, ..., a_j, ... a_n) = det (a_1, ... a_i + k a_j, ..., a_j, ... a_n$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### あるXについて、AX = Eを満たすならば、Aは正則行列であり、XはAの逆行列である
$det A det X = det AX = det E = 1$ より、$det A != 0$ が言えるので、正則.
逆行列が存在し、$X = A^{-1}$ となるので、XはAの逆行列.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### あるXについて、AX = Eを満たすならば、XA = Eが成立することを示せ
$AX=E => X=A^{-1} => XA = A^{-1}A = E$ よって、 $XA = E$が成立 (Aを右から掛けるとこがミソ)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 第1列に関する|A|の余因子展開
$det A = $sum_{i=1}^n (-1)^{i-1} a_{i1} |i行目以外| = $sum_{i=1} a_{i1} $tilde{a_{i1}}$
$tilde{a_{ij}} = (-1)^{i+j} $Delta_{ij}"" :msg ""行列Aからi行j列を除いた行列を第(i,j)小行列D_{ij}と表す.(i,j)余因子
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 逆行列の存在の証明
逆行列は、 $A^{-1} = \frac{1}{|A|} \tilde{A}$ より $det A=0$ でなければ、Aの余因子行列と行列式で表せる.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 余因子行列
$\overline{A} = \overline{a_{ji}}$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
"### matrixとi,jの関係をイメージする","### matrixとi,jの関係をイメージする
- i==jの時は、対角線
- i > j => 左下
- i < j => 右上
iが大きいほど、下側に
jが大きいほど、右側に
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 一次結合(線形結合)
$\sum k_i a_i$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 一次独立
```math
$sum k_i a_iが一次独立 $leftrightarrow $forall k_i $ne 0 S.T. $sum k_i a_i = 0
一次従属 $leftrightarrow ベクトルを別の基底の線形結合で表現可能
```
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md,math,
-->,"### 基底の定義
e_iがVの基底であるとは、 Vの任意のベクトルがe_iの一次結合として一意に表せる
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
:Q:基底の定義 -->,"\forall y $subseteq V \exists x_i (1 <= i <= n) s.t. y = \sum_{i=1}^n a_i x_i
\sum_{i=1}^n a_i x_i = 0 => a_1 = a_2 = ... = a_n = 0

",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md,math,
-->,"### 基底の性質
- $e_iがVの基底 \rightarrow e_i \in V#
- 基底の個数はdim V個だが、組みは、V上で任意にとることが可能
- n個のベクトルa_iが一次独立 <=> a_iは、n次元ベクトル空間Vの基底
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### dim Vの定義
Vがn個からなる基底をもつとき、nをVの次元と呼び、$dim V = n$と表す
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 次元の公式
n = dim V = dim Ker(T) + dim Im (T)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列P
aとb行(列)を入れ替える
P(a,b)
 = a[ab] = a[ba] = 1
 = a[aa] = a[bb] = 0
 = a[ii] = 1
 = 0 (else)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列P(a,b)の証明
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列Q
k行(列)目をc(!=0)倍する
Q(k;c)
 = a[kk] = c
 = a[ii] = 1 (i!=k)
 = 0 (else)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列Q(k;c)の証明
AB[ij]= sum a[ik]b[kj] = a[ii]b[ij] (a[ii]以外は0)
 = b[ij]  (i!=k)
 = cb[ij] (else)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列R
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列の性質
- 正則行列
- また逆行列も基本行列
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 左基本変形
**連立方程式を解く手法**
- 行と行を入れ替える
- 行に0でない定数をかける
- 別の行の程数倍を加える
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 斎次方程式
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### (全)単射の場合のAの形状
m*n n*1より、nからm次元への写像
- 全単射<=> 正方行列(m=n)
- 単射  <=> 縦長の長方形(m>n)
- 全射  <=> 横長の長方形(m<n)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 写像とrankAの関係
- 全単射<=> rankA = m = n
- 単射  <=> rankA = n
- 全射  <=> rankA = m
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### (全)単射の場合のAの次元
- 全単射<=> 1to1なので、同じ次数
- 単射  <=> 全ての要素が被らないようにする必要があるので、次数の増える方向
- 全射  <=> 全ての要素に行き着く必要があるので、次数の減る方向
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### n次正方行列AのAx=0の解
- rankA=n => 自明な解(x=0)
- rankA<n => 任意の解 (実質的な式の数よりも未知数が多い)
rankA=ImA=n(全射)=>全単射なので、2通りのみ
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 行列Ax=0の解
- 全単射 <=> n個
- 全射 <=> 任意の解
- 単射 <=> 解なし
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 「Aが正則 <=> Ax = 0の解は自明な解のみ」を証明
(十分)正則なのでA^{-1}が存在し、x=0が解となる。
(必要)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"###  単射 => Ker A={0}
Ax=0とする。一方A0=0でもあるので、
単射よりx=0が唯一の解
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"###  単射 <= Ker A={0}
任意のxとyがAx=Ay を満たすとすると =>
A(x-y)=0 => (仮定より)
(x-y)=0
よって単射の定義が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### Ker(T)の定義
Ker(T)={x in K^m | TA(x)=0} (ただしTA(x)=Ax)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 表現行列
$A' = Q^{-1}AP$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 一次変換の定義
線形写像T:V->V'において、V=V'の場合、Tを一次変換と呼ぶ.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 線形写像におけるrank Tの定義
線形写像T:V->V'に対し、rank T := dim (Im (T))
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"## 正則<=>一次独立
正則ならば `Ax=0` において、xは自明な解0しかもたない。
`Ax = (a1, a2, ..., an)x = (x1 a1, x2 a2, ..., xn an) = 0`
よって上記式が成立するのは、x_i=0の時のみなので
a_iは一次独立と言える
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/product.md
-->,"## det Aの解
Ax=axにおいて、固有ベクトルを持つ場合、
定義よりx!=0が条件である. そのため
(A-aE)x=0よりdet(A-aE)=0が条件となる
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/product.md
-->,"# 内積
VをR上のベクトル空間とし、Vの任意のベクトルa,bについて、実数(a,b)が定義されるとき、(,)をV上の内積という
(a,b) = (b,a) (対称性)
(a_1+a_2,b) = (a_1,b)+(a_2,b) (線形性(和))
(la,b) = l(a,b) (線形性(定数倍))
(a,a) $ge 0 and (a,a)=0 $Rightarrow a=0 (正値性)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/product.md
-->,"## AとBが正則ならばABも正則
$E = (AB)B^{-1}A^{-1}$より、逆行列$B^{-1}A^{-1}$が存在するので、正則
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/prove/regular.md
-->,"## Aが正則ならばA^2も正則
E = (AA)A^{-1}A{-1}より正則
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/prove/regular.md
-->,"# ベクトル空間
$forall x, y $in V S.T. x + y $in V (+について可換群)
$forall x $in V, $forall l $in K S.T. l x $in V (2種分配法則, 結合法則, 1の存在)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md
-->,"## 線形写像
V, V'をK上のベクトル空間とし、写像T:V->V'が以下を満たすときTを線形写像と呼ぶ
T(x+y) = T(x) + T(y) (x, y $in V)
T(lx) = lT(x) (x $in V, l $in K)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md
:Q:線形写像Tの性質 -->,"T(0) = 0 (l=0のとき必ず成立)
Tが全単射 <=> V $cong V' (ただし、VとV'は同型)
Tが全単射 <=> dim V = dim V'
Tが単射 $Leftrightarrow T(x)=0 $rightarrow x=0

",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md,math,
:Q:全単射と同値 -->,"Tが全単射 <=> V $cong V' (VとV'は同型)
Tが全単射 <=> dim V = dim V'

",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md,math,
-->,"## 部分空間
```math
W $subset V, $forall x,y $in W, $forall m,n $in K S.T. m x + n y $in W
```
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md,math,
-->,"## 事象AとBが起こる確率
P(A) + P(B)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## 事象AとB同時に確率
P(A) * P(B)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## 独立の定義
P(A, B) = P(A) * P(B)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## ベイズの定理
P(B|A) = P(A|B)P(B)/P(A)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## ２事象のみのベイズ
B=全体-Aの時
P(E) = P(A)P(E|A) * P(B)P(E|B) が成立するため、
P(E|A) = \frac{P(A|E)P(E)}{P(E)}
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"### 陽性の場合に、癌である確率(癌患者とそれ以外の場合における陽性の確率を既知トスる)
癌患者に対して陽性である確率P(p|c)
癌患者以外に対して陽性である確率P(p|-c)
$P(c|p) = P(c, p) / (P(p|c) + P(p|-c))$
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## Monty Hall Problemを条件つき確率で表せ
X={A,B,C}  # 正解の扉
Y={A,B,C}  # 挑戦者が選ぶ扉
Z={A,B,C}  # 司会者が選ぶ扉
P(X=C |Y=C, Z=B)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## Monty Hall Problem (三つの扉に一つだけヤギがいる状態で、一つ挑戦者は選び司会者は正解でない方の扉を開ける。さて選び直すべきか？)
ヤギがどの扉にいるか3通りある。それぞれにつき、挑戦者が扉を選ぶ場合が3通りある。同様に確かとみなせるので、世界を9等分できる。
この条件(GIVEN)のもと司会者が不正解の扉を選択するが、(A)挑戦者が正解を選んだ場合(3/9)は、司会者は外れの扉を2通りで選べる。
既に9等分された世界から移るので、1/18ずつの世界となる。一方で(B)挑戦者が不正解を選んだ場合(6/9)は、司会者は1通りの外れの扉しか選べないので、
世界のサイズは9等分されたままの状態になる。よって選び直さない場合は、1/3で正解となる。(司会者関係ない)。
選び直す場合は、(A)の続きで1/18ずつの世界では、残りの扉を1通りで選び直すので、どちらも外れることになる。
(B)の場合は、残っている正解の扉を1通りで選び直すので世界のサイズは変わらず1/9のままになり、2/3で正解となる。
(分岐が発生すると今いる世界を小さくする必要がある。分割のサイズは確率で決める。)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# (Ω, F , P) の意味
- 大文字オメガ(標本空間)
- 小文字オメガ(標本) (=それぞれの場合. 人間は知覚できない世界の1つ. ROOTから分岐した世界のノード)
- 標本空間の部分集合AをP(A)で表す
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# 確率変数(random variable)とは
- 標本aを引数に取る関数Xのこと. X(a)
- 人間にはaを知覚できないのでX自体が変数となる
- X={A,B,C}とは確率変数Xのとる値を集合で表記
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# 確率分布(random variable)とは
確率変数Xが取るそれぞれの値に対する確率
標本を特定する必要なし
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# P(X=k)の意味
X(標本) = kとなるような標本の面積の割合
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## P(a <= X < b) の意味
a <= X(標本) < bとなるような標本の集合をAとしたときのP(A) 
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## I.I.D (独立同一分布)
- independent and identically distributed
- ここの周辺分布がどれも同じ
- 各々独立
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 期待値の定義
E[g(X)] = sum g(xi) P(X = xi)
特に、g(x) = xの時
E[X] = sum xi P(X = xi)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 分散の定義
V[X]=E[(X-E[X])^2]=E[(X-u)^2] (ただしu = E[X])
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## P(X=a)の言い換え
- sum{y} P(X=a|Y=y) P(Y=y)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## sum P(X=x)の言い換え
- sum{y} P(X=x, Y=y)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X]の言い換え
- E[E[Y|X]]
- sum{a}E[X|Y=a] P(Y=a)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 条件つき期待値の定義
E[g(Y)|X=a] = sum{b}g(b)P(Y=b|X=a)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 条件つき分散の定義
V[Y|X=a]=E[(Y-u(a))^2|X=a]
ただし u(a)=E[Y|X=a]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[{Y-g(X)}^2]が最小となるgは?
g(a)=E[Y|X=a]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 基本性質
- sum P(X=x) = 1
- P(X=x) >= 0
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X+c] = E[X]+c
E[X+c] = sum (x+c)P(X=x) = sum xP(X=x) + sum cP(X=x) = E[x] + c
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[cX] = cE[X]
E[X+c] = sum (xc)P(X=x) = c sum xP(X=x) = cE[x]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X+Y] = E[X] + E[Y]
E[X+Y] = sum{x,y}(x + y)P(X=x, Y=y) = sum xP(X=x,Y=y) + sum yP(X=x,Y=y)
第一項 = sum{x}sum{y}xP(X=x,Y=y) = sum{x}xP(X=x) (第二項も同様)
E[X+Y] = sum{x}xP(X=x) + sum{y}yP(Y=y) = E[X]+E[Y]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[XY] = E[X]E[Y]
XとYが独立であるならば, P(xy)=P(x)P(y)なので
E[X+Y] = sum{x,y}(xy)P(X=x, Y=y) = sum{x}sum{y}(xy)P(X=x)P(Y=y) = sum{x}xP(X=x)sum{y}P(Y=y) E[X]E[Y]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## V[X+c] = V[X]
V[X+c]=V[Y]=E[(Y-v)^2]=E[{(X+c)-(u+c)}^2]=E[(X-u)^2]=V[X]
ただし, v=E[Y]=E[X+c]=E[X]+c=u+c
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## V[cX] = (c^2)V[X]
V[cX]=E[(cX-v)^2]=E[c^2(X-u)^2]=(c^2)E[(X-u)^2]=(c^2)V[X]
v=E[cX]=cE[X]=cu
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 確率変数の正規化
W=(X-u)/s
E[W]=(1/s)(E[X]-u)=0
V[W]=(1/s^2)(V[X])=1
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## V[X+Y] = V[X]+V[Y]
V[X+Y] = V[X]+V[Y]+2E[(X-u)(Y-v)]
XとYが独立であるならば, 
E[(X-u)(Y-v)]=E[X-u]E[Y-v]=(u-u)(v-v)=0
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X^2] = V[X] + E[X]^2 = s^2 + u^2
V[X] = E[(X-u)^2] = E[X^2+u^2-2uX] = E[X^2]+E[u^2]-2Eu[X] = E[X^2]+u^2-2u^2= E[X^2]-u^2
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## Bn(n,p)の分散
s^2=np(1-p)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## P(X=-1)=1/3, P(X=1)=2/3, V[X]?
1-(1/3)^2=8/9
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## I.I.Dの平均値の期待値
Z = sum Xi / n とすると
E[Z] = E[sum Xi / n] = (sum E[Xi]) / n 
iidなので、それぞれの期待値をuとおけて
E[Z] = nu / n = u
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## I.I.Dの平均値の分散
Z = sum Xi / n とすると
V[Z] = V[sum Xi / n] = (sum V[Xi]) / n^2
iidなので、それぞれの分散をs^2とおけて
V[Z] = ns / n^2 = s^2/n
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 大数の法則
iidな確率変数XiについてZ=sum Xi/nとすると
E[Z]=u, V[Z]=s^2/nとおけるので、n=>infとするとV[Z]=0となる
これは試行回数nを無限に増やせば、バラつきがなくなることを意味する
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## nonparametric
分布の具体的な関数を仮定しない
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## parametric
分布の具体的な関数を仮定する(正規分布)
ただし期待値や分散は未知
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## MCMC
解析的に解けないからシミュレーションで事後分布を求めることになった。その方法がMCMCなんだ
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## Bin(m|N,u) の読み方
試行回数Nと起きる確率uが与えられた場合(既知)の、確率変数mの確率分布
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 極大値(非連続)
x[i-1] < x[i] > x[i+1] について i \in \[1, n-1\]
",/Users/mbp/workspace/sandbox/math/tex/seq/1.md
-->,"## y = \sum_{i=0}^{n} a_i x^i
$$
S_n &=& a_0 x^n + a_1 x^{n-1} + ... + a_{n-1} x + a_n
    &=& $sum_{i=0}^{n} a_i x^{n-i}
    &=& $sum_{i=0}^{n-1} a_i x^{n-i} + a_n
    &=& x $sum_{i=0}^{n-1} a_i x^{(n-1)-i} + a_n
    &=& x S_{n-1} + a_n
$$
ようは、a_n除外して、xで括ったらS_{n-1}の項が出現する
",/Users/mbp/workspace/sandbox/math/tex/seq/1.md
-->,"## one byte offset
last - first = n - 1
$\sum_{i=1}^{n} a_i = $sum_{i=0}^{n-1} a_{i+1} = $sum_{i=2}^{n+1} a_{i-1}$
",/Users/mbp/workspace/sandbox/math/tex/seq/1.md
:Q:分割数 -->,"  dp(1, _) = 1
  dp(i, n) = dp(i-1, n) + dp(i, n-i)

",/Users/mbp/workspace/sandbox/math/tex/seq/seq.md,math,
-->,"## 配列A[x,y]範囲に1の要素がいくつあるか?
```math
S_n      = \sum_{i=0}^n A_i
A[0,y]   = S[y]
A[0,x-1] = S[x-1]
A[x,y]   = a_x + a_{x+1} + ... + a_y = A[0,y] - A[0,x-1] = S[y] - S[x-1] (x > 0)
         = a_0 (x = 0)
```
",/Users/mbp/workspace/sandbox/math/tex/seq/seq.md,math,
-->,"## パラメータのチューニング方法
小さいtrainデータでパラメタを最適化してから、全てのデータを適用させる
",/Users/mbp/workspace/sandbox/math/tex/svm.md
-->,"## Entropyの定義
E = -sum (pi)log2(pi)
",/Users/mbp/workspace/sandbox/math/tex/svm.md
-->,"## Entropy
0
",/Users/mbp/workspace/sandbox/math/tex/svm.md
-->,"## 互いに素とは
`gcd(a, b) = 1`
つまり最大公約数が1
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"## 互いに素の例
- (35, 48)
- (素数, 別の素数)
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"## GCDの性質
- GCD(a, a) = a
- GCD(x, 1) = 1
- GCD(pa, qa) = a (p,qは素数)
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"## totient
Euler's Totient Functionは、1 から n までの整数の中で、n と互いに素な数の個数を表します。
n が素数 p ならば、1からp-1までの全ての数とpは互いに素なので, t(p) = p - 1 が成り立ちます。
t(n)=n * PI (1-1/p) (pはnの素因数)
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"### A <= i <= B に含まれる整数の数
B - A + 1
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### A < i < B に含まれる整数の数
B - A - 1
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### A <= i < B に含まれる整数の数
B - A
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### A < i <= B に含まれる整数の数
B - A
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### #${i| A $leqq i $leqq B, i $bmod K = 0 $}
ある0<=n<A, 0<=n'<Bについて
A = Km + n <= i = K*j <= B = Km' + n' & <=> (Kで割る)
    m + n/K    <= j       <= m' + n'/K < m' + 1 
また次を考慮し `0 $leqq & n/K, n'/K & < 1`、Kの倍数から整数に帰着
m <= j <= m' (n/K = 0)
m <  j <= m' (else)
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### #${i| 3 <= i <= 110, i % 3 = 0 $}
3 = 3 * 1, 110 = 3 * 36 + 2より
1 <= (1, 2, ... 36) <= 36なので、16通り
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### min x >= a/b
- [a/b] & (a % b = 0)
- [a/b] + 1 & (else)
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### 数列Snを２分割した数列の差の最小値
S_{N0} & = & a_N + a_{N-1} + ... + a_2 + a_1
S_{N1} & = & a_N + a_{N-1} + ... + a_2 - a_1
...
S_{Nx}     & = & a_N + a_{N-1} + ... + a_{x+1} - a_x ... - a_2 - a_1
S_{N(x+1)} & = & a_N + a_{N-1} + ... - a_{x+1} - a_x ... - a_2 - a_1
...
S_{NN}     & = & - a_N - a_{N-1} + ... - a_2 - a_1
よって、２項間の差は以下のとおり
S_{N(x+1)} - S_{Nx} & = & - 2 a_{x+1} 
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"## newton法(簡易証明)
収束しそうな点(初項)を探す必要あり
f(x)の $x_n$ における接戦は次の通り $y = f'(x_n)(x - x_n) + f(x_n)$
この接線は、(x_{n+1}, 0)を通過するので $0 = f'(x_n)(x_{n+1} - x_n) + f(x_n)$
すなわち $x_{n+1} = x_n - f(x_n)/f'(x_n)$ として、
|$frac{x_{n+1} - x_n}{x_n}| < $epsilon を満たすまで繰り返す
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"## 暗黙のロック
- UPDATEとDELETEは暗黙的にXLOCKが必要
- CREATEする場合にも、挿入される行にXLOCKする必要がある
- unique, foreignのチェックにもロック必要みたい
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## ギャップロックとは?
インデックスとインデックスの間にかけられるロック。
範囲指定での処理 存在しない行への処理
(ex) idとstrがあるだけのシンプルなテーブル。idがPKで1~5までは順番に、その後、10,20と飛んで行が入っている
http://qiita.com/kenjiszk/items/05f7f6e695b93570a9e1
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## SHARE LOCKとは?
- READ => CREATE (間でREADした情報がUPDATE、DELETEされないことを保証したい, 親のテーブル情報)
- insertのロックは、ネクストキーロックではなくインデックスレコードロックである (つまり、ギャップロックが存在しない) 
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>22に変更する処理
1(R) 10 -> 1(U) 11 -> 2(R) 11 -> 2(U) -> 22
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>21に変更する処理
2(R) 10 -> 2(U) 20 -> 1(R) 20 -> 1(U) -> 21
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>20に変更する処理
1(R) 10 -> 2(R) 10 -> 1(U) 11 -> 2(U) -> 20
2(R) 10 -> 1(R) 10 -> 1(U) 11 -> 2(U) -> 20
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>11に変更する処理
2(R) 10 -> 1(R) 10 -> 2(U) 20 -> 1(U) -> 11
1(R) 10 -> 2(R) 10 -> 2(U) 20 -> 1(U) -> 11
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"# ダーティリードとは?
- ロック中のテーブルを参照すること
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## 楽観的ロック
明示的なロックをかけない
更新したデータを行に書き戻す前に、その行を読み取った後に他の誰かがその行に変更を加えていないか確認する方法
Version パターンと呼ばれる
INSERTによって発生する不整合を防止することはできない
バージョン番号を表すカラムをテーブルに追加
SELECTした時のバージョン番号を記憶しておく
UPDATE時に、
バージョン番号が2で取得した番号と等しいかチェックする(UPDATE ... WHERE ... AND lock_version = 1;)
バージョン番号をインクリメントする
更新された行数が、
0だったらエラー。行を読んでから更新する前に他の誰かが行を更新したということ
1だったら更新成功
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## 悲観的ロック
明示的にロックをかける
ロックが開放されるまで、ロックを保持していないユーザはデータを操作できない
場合によっては処理が長時間滞ってしまい、アプリケーションのパフォーマンスを著しく低下させる
MySQL では、LOCK TABLES、SELECT ... LOCK IN SHARE MODE, SELECT ... FOR UPDATE 等によって実現
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
:Q:SLOCKが必要となる例(親の名前で子供を作成),"mysql db -e '
BEGIN;
-- set @pname = (select name from parent where id = 1);  -- SLOCKしないとFK errorとなる
set @pname = (select name from parent where id = 1 lock in share mode);
select sleep(2);
insert into child (name, parent_id) values (@pname, 1);
COMMIT;
' &
sleep 1
mysql db -e 'delete from parent where id = 1;' &
wait
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/slock.sh
# Get a lock for 10 sec,"# Get a lock for 10 sec
redis-cli flushall > /dev/null
f() {
    echo ""TRY TO GET A LOCK $1""
    if redis-cli set LOCK_KEY 1 NX PX 10000 | grep OK > /dev/null; then
        echo ""SUCCESS $1""
        sleep 1; redis-cli del LOCK_KEY > /dev/null
        echo ""DONE $1""
    else
        echo ""FAILURE $1""
    fi
}
f 1 & f 2 & wait
# single instanceの時は、setnxの戻り値を利用して排他的制御が可能.
# ただし、ロックを取得したプロセスがクラッシュしてデッドロックしないよう
# ロックを確保できる時間を設定する必要があるのに注意.
",/Users/mbp/workspace/sandbox/mid/redis/single_redis_lock.sh
-->,"## Materialized view
- 参照のみ: 更新することはできないが、複雑な定義のビューに利用
- Mysql5.7の場合、viewにindexを指定することはできない
",/Users/mbp/workspace/sandbox/sql/README.md
-->,"## slow queryの対処
- `slow_query_log_file` をセットして、遅いクエリを検知する
- eager load (N+1 query)
",/Users/mbp/workspace/sandbox/sql/README.md
insertによるdeadlockの例,"# unique key + bulk insertはdeadlockの可能性がある(解決方法はソート)
mysql db -e '
drop table if exists p;
CREATE TABLE p (`id` bigint(20) unsigned NOT NULL primary key);
'
q1=`perl -E '$a=join "", "", map {""($_)""} 1..999 ; say qq#insert into p (id) values $a ;#'`
q2=`perl -E '$a=join "", "", map {""($_)""} reverse 2..1000 ; say qq#insert into p (id) values $a ;#'`
echo $q1 | mysql db &
echo $q2 | mysql db &
wait
",/Users/mbp/workspace/sandbox/sql/bulkInsert.sh
-- cascadeとは？,"-- cascadeとは？
alter table child add foreign key (parent_id) references parent (id)
on delete cascade on update cascade;
-- update: 親の主キーが変更された場合に、子の参照keyを親の値に更新
-- delete: 親のレコードを削除した場合に、子ののレコードも削除
",/Users/mbp/workspace/sandbox/sql/cascade/cascade.sql
restrictとは？,"alter table child add foreign key (parent_id) references parent (id)
on delete restrict on update restrict;
-- 子供が参照した状態で、削除更新しようとするとエラー
-- ""SET CONSTRAINTS ALL DEFERRED""というコマンドを使うことで
-- 外部キー制約に限ってトランザクションの終わりまで制約の検査を遅延させることができる
",/Users/mbp/workspace/sandbox/sql/cascade/restrict.sql
-- set nullとは？(parent/childで説明),"-- set nullとは？(parent/childで説明)
alter table child add foreign key (parent_id) references parent (id)
on delete set null on update set null;
-- update: 親の主キーが変更された場合に、子の参照keyをNULLにする
-- delete: 親のレコードを削除した場合に、子の参照keyをNULLにする
",/Users/mbp/workspace/sandbox/sql/cascade/setNull.sql
:Q:テーブルの削除,"DROP TABLE IF EXISTS child, attribute, parent CASCADE;
-- CASCADEはposgresqlのみ(mysqlの時は親を最後に記述)
",/Users/mbp/workspace/sandbox/sql/createTable.sql
:Q:childにおける外部参照KEYの定義,"  id int(4) unsigned,
  FOREIGN KEY (id) REFERENCES parent (id) ON DELETE CASCADE ON UPDATE CASCADE
",/Users/mbp/workspace/sandbox/sql/createTable.sql
:Q:parentが持つ属性table,"CREATE TABLE IF NOT EXISTS attribute (
  -- 1to1となるように、PKまたは、uniqueの指定が必要
  parent_id int AUTO_INCREMENT,
  PRIMARY KEY (parent_id)
);
",/Users/mbp/workspace/sandbox/sql/createTable.sql
:Q:member_id=1に関する友達の友達,"select m.id from member m
join contact c1 on c1.user_id = m.id
join contact c2 on c2.user_id = c1.other_id
-- join contact c3 on c3.user_id = c2.other_id  -- さらに友達
where c2.other_id = 1;
",/Users/mbp/workspace/sandbox/sql/friendsFriends.sql
:Q:最も良い成績を選択,"select * from grade where score = (select max(score) from grade);
",/Users/mbp/workspace/sandbox/sql/getMaxAgePerson.sql
:Q:最も良い成績を選択(ただし結果は1recordのみ),"-- 重複した値をもたず、結果が1レコードのみで良ければ、order byが使える
select * from grade order by score desc limit 1;
",/Users/mbp/workspace/sandbox/sql/getMaxAgePerson.sql
insertでの排他制御,"updateとは異なり楽観ロックをかけることができないので、unique制約を使い整合性を保つ
unique(parent_id default=0, user_id)
この場合、もし競合状態が発生しても一つしか生成されない
",/Users/mbp/workspace/sandbox/sql/lock.txt
":Q:varchar(5)の時の""abcdef""の挙動","insert into size_test (n1) values (""abcdef"");
-- strictの場合は、エラーとなる。
-- 警告の場合は、truncateされる(""abcdef"" => ""abcde"")
",/Users/mbp/workspace/sandbox/sql/size.sql
":Q:varchar(5)の時の""あabc""の挙動","insert into size_test (n1) values (""あabc"");
-- 「あ」は、3bytesなので、残り2bytes格納できる(""あabc"" => ""あab"")
-- 文字数でカウントされない
",/Users/mbp/workspace/sandbox/sql/size.sql
:Q:tinytextに格納てきる日本語,"-- tinytextは、255 (2^8−1) bytesまで格納できる。utf-8の「あ」は、3byteなので、85文字格納できる。
insert into size_test (n2) values (repeat(""あ"", 85));
",/Users/mbp/workspace/sandbox/sql/size.sql
:Q:成績の平均が上位3までの学生のSQL,"select s.id, AVG(g.score) from student s join grade g
on s.id = g.student_id group by s.id order by AVG(g.score) desc limit 3;
",/Users/mbp/workspace/sandbox/sql/top10StudentsAboutScore.sql
-- 異なるデータを一つのリストに混在させる方法,"-- 異なるデータを一つのリストに混在させる方法
-- 1. １つのテーブルにまとめる. (非正規化。余計なカラムが多くなる)
-- 2. 親に共通部分をまとめる. 子供で別々のカラムを定義 (継承問題)
-- 3. union. sortするのでoffsetのコストが高い. 予めtableをfilterしておく
-- 4. マテリアルview. データのためのリソースとindexの再計算処理のコスト
",/Users/mbp/workspace/sandbox/sql/union.sql
int main() ,"int main() {
  short int word = 0x0001;  // 2byte
  char *byte = (char *) &word;
  if (*byte) printf(""Little endian\n"");  // 01 00
  else printf(""big endian\n""); // 00 01
}
",/Users/mbp/workspace/sandbox/unix/checkEndian.c
# O(N)のパターン(ただし、２重ループ),"# O(N)のパターン(ただし、２重ループ)
# ルートNまでの総和はO(N): 1 + 2 + ... $sqrt[]{N} = $frac{1 + $sqrt[]{N}}{2} = O(N)
def ON(N, i=1):
    while i * i <= N:
        for j in range(i):
            pass
        i += 1
",/Users/mbp/workspace/sandbox/unix/order.py
# O(logN)のパターン,"# O(logN)のパターン
# 2で割る場合や余りの場合: 1 -> 2 -> 4 -> 8 -> ... 2^(n-1)
def OlogN(N):
    while N > 0:
        N /= 2
",/Users/mbp/workspace/sandbox/unix/order.py
# O(MN)のパターン,"# O(MN)のパターン
# 掛け算の場合はどちらが外側のループになるか、2通り考えられる
def OMN(N, M):
    for _ in range(M):
        for _ in range(N):
            pass
",/Users/mbp/workspace/sandbox/unix/order.py
# O(M+N)のパターン,"# O(M+N)のパターン
def OMON(N, M):
    for _ in range(M):
        pass
    for _ in range(N):
        pass
",/Users/mbp/workspace/sandbox/unix/order.py
