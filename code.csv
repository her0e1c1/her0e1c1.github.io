長さlのソート配列に含まれるNの個数,"func search(a []int, f func(int) bool) int {
    rt, lo, hi := 0, 0, len(a)-1
    for lo <= hi {
        mi := lo + (hi - lo) / 2
        if a[i] <= a[mi] {
            hi = mi - 1
            rt = mi
        } else {
            lo = mi + 1
        }
    }
	return len(dp)
}
",/Users/mbp/workspace/sandbox/algo/binary-search/count-elem.go
長さlのソート配列に含まれるNの個数,"countElem xs n = (foldl f 0 bits) - (foldl g (2^32) bits) + 1 where
  f acc x = if f2 (acc + x) then acc + x else acc
  g acc x = if g2 (acc - x) then acc - x else acc  -- (head xs) > n なら-1を返すべき. (head xs) < nの場合は(length xs)を返す
  f2 a = (length xs) > a && xs !! a <= n
  g2 a = (length xs) <= a || a >= 0 && xs !! a >= n  -- 配列のサイズを超える場合は、indexが小さくなる方向へ
  bits = reverse [2^i | i<-[0..32]]
",/Users/mbp/workspace/sandbox/algo/binary-search/count-elem.hs
"func InOrderPrev (n, prev *Node) *Node ","func InOrderPrev (n, prev *Node) *Node {
// left -> parent -> right PREV で考えずに
// left <- parent <- right NEXT で考える
	if n == nil {
		return nil
	} else if prev == nil {
		if n.Left != nil {
			return InOrderPrev(n.Left, n)
        } else {
			return InOrderPrev(n.Parent, n)
		}
	} else {
        if n.Right == nil || n.Right == prev {
			return n
		} else if n.Left == prev {
			return InOrderPrev(n.Parent, n)
		} else {
			return InOrderPrev(n.Right, n)
		}
	}
}
",/Users/mbp/workspace/sandbox/algo/binary-tree/order/inOrderPrev.go
お釣りの問題,"solve :: [Int] -> Int -> [[Int]]
solve [] sum = [[]]
-- coinsは降順ソート
solve (c:coins) csum = concatMap (g . f) [0 .. (div csum c)]
  where
    -- xは、cにおける使用するコインの枚数
    -- fは、c:coinsにおける使用するコインのリストを返す
    f x = map ((take x (repeat c)) ++) (solve coins (csum - c * x))
    g = filter (\a-> sum a == csum)
",/Users/mbp/workspace/sandbox/algo/dp/change/change.hs
:Q:circusTower,"// (身長、体重) がそれぞれ下にいる人よりも小さくなることを制限として、最も長い人タワーを作る時の組み合わせ
func circusTower(A []Pair) []Pair {
	sort.Sort(Pairs(A))
	var dfs func(int) []Pair
	dfs = func(i int) []Pair {
		if i == len(A) {
			return []Pair {}
		} else {
			var humans []Pair
			h1, w1 := A[i].height, A[i].width
			for j := i+1; j < len(A); j++ {
				h2, w2 := A[j].height, A[j].width
				if h1 < h2 && w1 < w2 {
					if h := dfs(j); len(humans) < len(h) {
						humans = h
					}
				}
			}
			humans = append(humans, A[i])
			return humans
		}
	}
	return dfs(0)
}
",/Users/mbp/workspace/sandbox/algo/dp/circusTower/circusTower.go
"func solve(sizes, prices []int, capacity int) int ","func solve(sizes, prices []int, capacity int) int {
	dp := make([]int, capacity + 1)
	for s := 0; s < len(sizes); s++ {
		for c := capacity; c >= sizes[s]; c-- { // 再利用ができるのは、i=>i+1へ単純に値を渡している場合.
			dp[c] = max(dp[c], dp[c-sizes[s]] + prices[s])
		}
	}
	return dp[capacity]
}
func main() {
	fmt.Println(solve([]int{1,2,3,4,5}, []int{5,4,3,2,1}, 6))  // 12 = (1,2,3)
}
",/Users/mbp/workspace/sandbox/algo/dp/knapsack/knapsack.go
"knapsack :: (Ord a, Num a) => [(a, a)] -> a -> a","knapsack :: (Ord a, Num a) => [(a, a)] -> a -> a
-- pairs = [(size, price)] (逆方向)
knapsack pairs size = go pairs size where
    go [] size = 0
    go ((s,p):sps) size =
      let
        ssize = size - s
        cap1 = go sps size  -- 現在の(s, p)を使わない
        cap2 = if ssize >= 0 then p + go sps ssize else 0
      in maximum [cap1, cap2]
main = print $ knapsack [(x, 6-x) |x <- [1..5]] 6
",/Users/mbp/workspace/sandbox/algo/dp/knapsack/knapsack.hs
:Q:繰り返し二乗法(bottom up),"func pow(a, n int) int {
    // 下位ビットから、x^iを掛ける/掛けないをすることでも行き先を決めることができる！
    // 2^6 = (2^2 * 2^2) * (2^1 * 2^1) (正しい遷移)
    // この考え方に釣られると、pow(x, n) = pow(x * x, n / 2) * x
    // 2^6 = (2^3 * 2^3) * 2^1  (再帰的ではあるが、この場合は間違った遷移となる)
    x := 1
    for n > 0 {
        if (n & 1 == 1) {
            x *= a
        }
        a = a * a
        n = n >> 1
    }
    return x
}
",/Users/mbp/workspace/sandbox/algo/dp/pow.go
:Q:繰り返し二乗法(dp),"func pow_dp(a, n int) int {
    // => 向きには１方向. それを利用して0からnへのルートを知ることができる
    x := 1
    for d := 32; d >= 0; d-- {
        x = x * x  // x==1なので1bitが立つまでは初期状態
        if (1 << uint(d) & n > 0) {
            x *= a
        }
    }
    return x
}
",/Users/mbp/workspace/sandbox/algo/dp/pow_dp.go
(define (add list1 list2),"(define (add list1 list2)
  (let loop ((a list1) (b list2) (carry 0))
    (let* ((sum (+ (if (null? a) 0 (car a))
                   (if (null? b) 0 (car b))
                   carry))
           (digit (mod sum 10))
           (next-carry (if (>= sum 10) 1 0))
           (next-a (if (null? a) '() (cdr a)))
           (next-b (if (null? b) '() (cdr b))))
      (if (and (null? a) (null? b))
          (if (= carry 1) '(1) '())
          (cons digit (loop next-a next-b next-carry))))))
",/Users/mbp/workspace/sandbox/algo/famous/AddEachDigitOf2Lists/AddEachDigitOf2Lists.scm
:Q:BIT(Binary Indexed Tree)とは?,"// a1からanまでの総和をlog(n)で求めることができるデータ構造
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
type Bit struct ,"type Bit struct {
	data []int
	size int
}
func NewBit(size int) *Bit {
	b := &Bit{size:size}
	b.data = make([]int, size)
	return b
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
func (b *Bit) read (idx int) int ,"func (b *Bit) read (idx int) int {
	sum := 0
	for idx > 0 {
		sum += (*b).data[idx]
		idx -= idx & -idx
	}
	return sum
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
"func (b *Bit) update (idx, value int) ","func (b *Bit) update (idx, value int) {
    /*
     * idx == 0の場合は1のbitがないので
     * 常に0のままになる
     * そのため、idx >= 1が条件
     */
	if idx == 0 { return }
	for idx <= (*b).size {
		(*b).data[idx] += value
		idx += idx & -idx
	}
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
":Q:a[i]=iの時のS(5),S(10)","	b := NewBit(100)
	for i := 0; i <= 10; i++ {
		b.update(i, i)
	}
	fmt.Println(b.read(1))  // 1
	fmt.Println(b.read(5))  // 15
	fmt.Println(b.read(10)) // 55
	
	fmt.Println(b)
}
",/Users/mbp/workspace/sandbox/algo/famous/bit.go
func findConsecutiveSegments(s []int) string ,"func findConsecutiveSegments(s []int) string {
    return loop(s, nil, nil)
}
func loop(s []int, start, prev *int) string {
    format := func () string {
        if start == nil || prev == nil {
            return """"
        } else if *start == *prev {
			return fmt.Sprintf(""%d"", *start)
		} else {
			return fmt.Sprintf(""%d-%d"", *start, *prev)
		}
    }
	if len(s) == 0 {
		return format() + ""\n""
    } else if prev == nil {
        return loop(s[1:], &s[0], &s[0])
    } else if s[0] - 1 == *prev {
        return loop(s[1:], start, &s[0])
    } else {
		return format() + "", "" + loop(s[1:], &s[0], &s[0])
	}
}
",/Users/mbp/workspace/sandbox/algo/famous/findConsecutiveSegments.go
"def f(lines, pattern, N):","def f(lines, pattern, N):
 queue = []
 n = 0
 for line in lines:    
  if pattern in line:
   while queue:
    print(queue.pop(0))
   print(line)
   n = N
  elif n > 0:
   print(line)
   n -= 1
  else:
   queue.append(line)
   if len(queue) > N:
    queue.pop(0)
f(""1 p 3 2 1 4 3 3 4"".split(), ""3"", 1); print("""")
f(""1 p 3 2 1 4 3 3 4"".split(), ""3"", 2); print("""")
f(""1 p 3 2 1 4 3 3 4"".split(), ""2"", 2); print("""")
",/Users/mbp/workspace/sandbox/algo/famous/grep.py
"def move(n, src, buf, dst):","def move(n, src, buf, dst):
    assert len(src + buf + dst) == N, ""move wrong""
    assert n <= len(src), ""move wrong""
    if n > 0:
        move(n - 1, src, dst, buf)  # この関数が返ると、bufにn-1個移したことになる
        dst.append(src.pop())
        assert len(dst) <= 1 or dst[-1] < dst[-2], 'move wrong'  # 大小関係を満たしているか確認
        print(s, b, d)
        move(n - 1, buf, src, dst)
",/Users/mbp/workspace/sandbox/algo/famous/hanoi/hanoi.py
:Q:ページング式,"-- 幅(width) (ページ数は常に一定)
-- == 2 * diff + 1
-- == 右端 - 左端 + 1  (右端>左端)
-- ページ数は一定になるよう式変形し、表現変更
-- == x - (x - 2 * diff) + 1 (IF last < x + diff)
-- == (x + 2 * diff) - x + 1 (IF x - diff < first)
-- == (x + diff) - (x - diff) + 1 (IF first <= x - diff <= x + diff <= last)
-- first + diff <= x <= last - diff (十分な幅がある条件)
",/Users/mbp/workspace/sandbox/algo/famous/paging/paging.hs
"paging :: Int -> Int -> Int -> (Int, Int)","paging :: Int -> Int -> Int -> (Int, Int)
paging = go 0 where
  go first diff cur last
        | not $ (first <= cur) && (cur <= last) = error ""bad args""
        | (last - first + 1) <= 2 * diff + 1 = (first, last)  -- 幅が十分大きい場合
        | cur < first + diff = (first, first + 2 * diff)  -- 左端
        | last - diff < cur  = (last - 2 * diff, last)  -- 右端
        | otherwise = (cur - diff, cur + diff)  -- [現在-幅, 現在+幅]
paging2 = paging 2  -- diff == 2
main = do
  mapM_ (\x -> (putStr . show) x >> (print $ paging2 x 10)) [0..10]
",/Users/mbp/workspace/sandbox/algo/famous/paging/paging.hs
solve :: Int -> [[Int]],"solve :: Int -> [[Int]]
solve boardSize = go [] where
  go queens = if length queens == boardSize
              then [queens]
              else concatMap (go . flip (:) queens) $ filter f [0 .. (boardSize - 1)]
    where
      f x = not $ elem x queens || canAttack x queens
canAttack :: Int -> [Int] -> Bool
canAttack x queens = go queens 0 where
  go [] _ = False
  go (q:queens) n = q == x + (n + 1) || q == x - (n + 1) || go queens (n + 1)
",/Users/mbp/workspace/sandbox/algo/famous/queen/queen.hs
:Q:人に見やすいフォーマットに変換,"def show(n, binary=False):
    if n < 0:
        return ""-"" + show(-1 * n, binary)
    def to_s(x, unit, label=''):
        return '%.1f%sB' % (x / float(unit), label)
    for i, unit in enumerate(["""", ""K"", ""M"", ""G"", ""T"", ""P"", ""Z""]):
        if binary:
            start = 2 ** (10 * i)
            end   = 2 ** (10 * (i + 1))
        else:
            start = 10 ** (3 * i)
            end   = 10 ** (3 * (i + 1))  # end = start * (10 ** 3)
        if start <= n < end:
            return to_s(n, start, unit)
    else:
        return to_s(n, 1)
",/Users/mbp/workspace/sandbox/algo/famous/show-human.py
(define (choose choices),"(define (choose choices)
  (if (null? choices)
      (try-again)
      (call/cc
       (lambda (cc)
         (set! *alternatives*
               (cons
                (lambda ()
                  (cc (choose (cdr choices))))
                *alternatives*))
                  (car choices)))))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
(define try-again #f),"(define try-again #f)
(define *alternatives* '())
(call/cc
 (lambda (cc)
   (set! try-again
         (lambda ()
           (if (null? *alternatives*)
               (cc '(there are no more values))
               (let ((next (car *alternatives*)))
                 (set! *alternatives* (cdr *alternatives*))
                 (next)))))))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:amb,"(define (amb . choices)
    (choose choices))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:try-againのサンプル,";; (test*
;;  ""try-again * 3""
;;  '(3 a)
;;  (begin
;;    (let ((x (amb 1 2 3))
;;          (y (amb 'a 'b)))
;;      (list x y))
;;    (try-again)
;;    (try-again)
;;    (try-again)
;;    )
;; )
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:require,"(define (require p)
  (if (not p) (amb)))
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
:Q:requireのサンプルコード,"(test*
 ""triangle""
 '(3 4 5)
 (let ((x (amb 1 2 3 4 5))
       (y (amb 1 2 3 4 5))
       (z (amb 1 2 3 4 5)))
   (require (= (+ (* x x) (* y y)) (* z z)))
   (list x y z))
 )
",/Users/mbp/workspace/sandbox/algo/fp/amb.scm
":Q:[1..10]=>[2,4,6,8,10,1,3,5,7,9]","  print $ (uncurry (++) . partition even) [1..10]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
":Q:[-5..5]=>[0,1,2,3,4,5,-5,-4,-3,-2,-1]","  print $ (uncurry (flip (++)) . break (>=0)) [-5..5]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
:Q:[1..10]=>偶数だけ取り出す=>1加算=>Sum,"  -- (.)は、引数が一つだけの関数を連結するときに使用できる
  print $ (foldl (+) 0 . map (+1) . filter even) [1..10]  -- 35
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
":Q:[Left1,Right2,Left3]=>[1,3]","  print $ [x | (Left x) <- [Left 1, Right 2, Left 3]]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
":Q:[1..3]=>[Just1,Just2,Just3]","  print $ map Just [1..3]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
":Q:[1..5]=>[[1..5],[2..5],[3,4,5],[4,5],[5],[]]","  print $ let xs = [1..5] in map (flip drop xs) [0..length xs]
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
:Q:[a]==[a](uncurry使う),"  -- uncurryは、２タプルの１結果を２引数の関数に適用するのに使う
  print $ uncurry (++) (splitAt 1 [1..5])
",/Users/mbp/workspace/sandbox/algo/fp/basic.hs
:Q:チャーチ数0,"; 0 := λ f x . x
(define zero (lambda(f) (lambda(x) x)))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
:Q:チャーチ数1,"; 1 := λ f x . f x
(define one  (lambda(f) (lambda(x) (f x))))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
:Q:チャーチ数2,"; 2 := λ f x . f f x
(define two  (lambda(f) (lambda(x) (f (f x)))))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
:Q:チャーチ数から整数への変換する関数,"; 関数 toInt は数字を表現する関数を受け取り、0 を引数として1を加算する関数を渡します。
; 数字を表現する関数がその数字の回数だけ1を加算します
(define toInt (lambda(n) ((n (lambda(x)(+ x 1))) 0)))
(test* ""zero"" 0 (toInt zero))
(test* ""one""  1 (toInt one))
(test* ""two""  2 (toInt two))
",/Users/mbp/workspace/sandbox/algo/fp/calculus.scm
(define (fact/cps n cont),"(define (fact/cps n cont)
; mは(fact (- n 1))の結果が来る
; (cont XXX)とするとXXXが(fact/cps n cont)の戻り値となる.
  (if (= n 1)
      (cont 1)
      (fact/cps (- n 1) (lambda (m) (cont (* n m))))))
(test* ""(fact/cps 1)""  1   (fact/cps 1 values))
(test* ""(fact/cps 10)"" 120 (fact/cps 5 values))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (fib/cps n k),"(define (fib/cps n k)
  (cond ((= n 0) (k 0))
        ((= n 1) (k 1))
        (else
         (fib/cps (- n 1)
                  (lambda (r1)
                    (fib/cps (- n 2) (lambda (r2)
                                       (k (+ r1 r2)))))))))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (flatten/cps tree k),"(define (flatten/cps tree k)
  (cond ((null? tree) (k '()))
        ((pair? tree)
         (flatten/cps (car tree)
                      (lambda (r1)
                        (flatten/cps
                         (cdr tree)
                         (lambda (r2) (k (append r1 r2)))))))
        (else (k (list tree)))))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (leaf-count/cps tree k),"(define (leaf-count/cps tree k)
  (if (pair? tree)
      (leaf-count/cps (car tree) (lambda (n)
                        (leaf-count/cps (cdr tree) (lambda (m) (k (+ n m))))))
      (k 1)))
",/Users/mbp/workspace/sandbox/algo/fp/cps.scm
(define (even-odd? x),"(define (even-odd? x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n) (if (= n 0) #t (od? ev? od? (- n 1))))
   (lambda (ev? od? n) (if (= n 0) #f (ev? ev? od? (- n 1))))))
(print (even-odd? 10))  ; #t
(print (even-odd? 11))  ; #f
",/Users/mbp/workspace/sandbox/algo/fp/y/even-odd.scm
:Q:不動点とは,"; fixed point combinator f(x)=xを満たすxの事
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
:Q:fact-Y-combinator,"(define fact
  (lambda (f)
    (lambda (n)
      (if (= n 0) 1 (* n (f (- n 1)))))))
(define Y
  (lambda (f)
    ((lambda (x) (f x x))
     (lambda (x) (f x x)))))
;; (define Y
;;   (lambda (f)
;;     ((lambda (x) (x x))
;;      (lambda (x) (f (lambda (y) ((x x) y)))))))
(define factorial (Y fact))
(print (factorial 5))  ; 120
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
:Q:(Lx.(x+1))1の意味,"; xは引数で、(x+1)は戻り値、1は実引数でx=1
; (Lx.x+1)1=>(1+1)=>2 (実引数を適用するとLも除外)
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
:Q:FixedPointCombinators,"; Y = Lf.(Lx.f(x x)) (Lx.f(x x)) とおくと
; Y g = (Lf.(Lx.f(x x)) (Lx.f(x x))) g
; = (Lx.g(x x)) (Lx.g(x x))  ; これが繰り返し現れる
; = g((Lx.g(x x)) (Lx.g(x x)))
; = g (Y g)
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
ZCombinator,"; λf.(λx.f(λy.xxy))(λx.f(λy.xxy))
",/Users/mbp/workspace/sandbox/algo/fp/y/fact.scm
; inner関数がなくても、lambdaで内部関数定義できる,"; inner関数がなくても、lambdaで内部関数定義できる
(define fib
  (lambda (n)
    ((lambda (f) (f f n))
     (lambda (self a)
       (cond ((= a 0) 0)
             ((= a 1) 1)
             (else (+ (self self (- a 1))
                      (self self (- a 2)))))))))
(print (fib 10))  ; 55
",/Users/mbp/workspace/sandbox/algo/fp/y/fib.scm
"func (g *Graph) IsConected(src int, dst int) bool ","func (g *Graph) IsConected(src int, dst int) bool {
	q := []int {src}
	visited := make([]bool, g.N)
	for len(q) != 0 {
		node := q[0]
		if node == dst {  // srcから始めて、dstに行ければtrue
			return true
		}
		visited[node] = true
		q = q[1:]
		for _, next := range g.E[node] {
			if ! visited[next] {
				q = append(q, next)
			}
		}
	}
	return false
}
",/Users/mbp/workspace/sandbox/algo/graph/bfs/is_connected.go
"func NewGraph(x []int, y []int, N int) (*Graph) ","func NewGraph(x []int, y []int, N int) (*Graph) {
	g := &Graph{N: N}
	E := make([][]int, N)
	for i := 0; i < len(x); i++ {
		xi := x[i]
		yi := y[i]
		E[xi] = append(E[xi], yi)
	}
	g.E = E
	return g
}
",/Users/mbp/workspace/sandbox/algo/graph/bfs/shortest_path.go
"func (g *Graph) Find(src, dst int) []int ","func (g *Graph) Find(src, dst int) []int {
	q := []int {src}
	visited := make([]bool, g.N)
	previous := make([]int, g.N)
	for i := 0; i < g.N; i++ { previous[i] = -1 }  // TODO: how to make values default
	for len(q) != 0 {
		node := q[0]
		if node == dst {
			paths := []int {node}
			for i := previous[node]; i != -1; i = previous[i] {
				paths = append(paths, i)
			}
			return paths
		}
		q = q[1:]
		visited[node] = true
		for _, next := range g.E[node] {
			if ! visited[next] {
				q = append(q, next)
				previous[next] = node
			}
		}
	}
	return []int {}
}
",/Users/mbp/workspace/sandbox/algo/graph/bfs/shortest_path.go
func (g *Graph) TopologicalSort() []int ,"func (g *Graph) TopologicalSort() []int {
	var dfs func(n int)  // 宣言必須!
	sorted := []int {}
	visited := make([]bool, g.N)
	dfs = func (n int) {
		visited[n] = true
		for _, next := range g.E[n] {
			if ! visited[next] {
				dfs(next)
			}
		}
		sorted = append(sorted, n)  // 答えは決まった時点で格納
	}
	for node := 0; node < g.N; node++ {
		dfs(node)
	}
	return sorted
}
",/Users/mbp/workspace/sandbox/algo/graph/dfs/topological-sort.go
:Q:wfloydの特徴,"// マイナスを含んだ重み付き有向グラフの全ペアの最短経路問題
",/Users/mbp/workspace/sandbox/algo/graph/floyd/floyd.cpp
int inf = 1 << 20;  // 1 << 30にすると配列の計算でoverflowするので多少小さい値にすること,"int inf = 1 << 20;  // 1 << 30にすると配列の計算でoverflowするので多少小さい値にすること
int wf(int n, vector<int> x, vector<int> y, vector<int> w){
  vector<vector<int>> a(n, vector<int>(n, inf));
  for (int i = 0; i < n; i++) a[i][i] = 0;  // 0とINFの初期化必須
  for (int i = 0; i < x.size(); i++) a[x[i]][y[i]] = w[i];  // u => v (cost)
  for (int k = 0; k < n; k++) 
    for (int i = 0; i < n; i++)
      for (int j = 0; j < n; j++)
        a[i][j] = min(a[i][j], a[i][k] + a[k][j]);
  return a[0][n-1];
}
",/Users/mbp/workspace/sandbox/algo/graph/floyd/floyd.cpp
"if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X) AND if A[K] = N + 1 then operation K is max counter.","func maxCounters(A []int, N int) []int {
    c := make([]int, N)
    ma, base := 0, 0
    for i := 0; i < len(A); i++ {
        a := A[i]-1
        if (a == N) {
              base = ma
        } else {
            b := c[a]
            if (b < base) {
                c[a] = base + 1
            } else {
                c[a] = b + 1
            }
            if (ma < c[a]) {
                ma = c[a]  // maxは逐一更新
            }
        }
    }
    for i := 0; i < N; i++ {
        if (c[i] < base) {
			c[i] = base
		}
    }
    return c
}
",/Users/mbp/workspace/sandbox/algo/greedy/maxCounters.go
極大値が間隔Kで取れる場合はTrue,"func maxIntervalOfLocalMaximuns(K int, S []int) bool {
	// Sは極大値のx座標のリスト
    i := 0  // 左端から貪欲に
    for cnt := 0; cnt < K-1; cnt++ {  // 2つ目の間隔が取れるか?から開始
		if i == len(S) {
			return false
		}
        x1 := S[i]
        j := i + 1
        for j < len(S) {
            x2 := S[j]
            if x2 - x1 >= K {
				break
			}
            j++
		}
        if j == len(S) {
			return false
		}
        i = j
	}
    return true
}
",/Users/mbp/workspace/sandbox/algo/greedy/maxIntervalOfLocalMaximuns.go
各一定区間内に極大値をもつよう区分,"func maxNumberGroupOfLocalMaximuns(groups int, S []bool) bool {
    N := len(S)
    if N % groups != 0 {
        panic(""N % groups == 0"")
    }
    interval := N / groups
    for cnt := 0; cnt < groups; cnt++ {
		for i := 0; i < N; i += interval {
			last := i + interval  // [i, last)で右端は含めない
			for i < last {
				if S[i] {
					break
				}
				i++
			}
			if i == last {
				return false
			}
		}
	}
    return true
}
",/Users/mbp/workspace/sandbox/algo/greedy/maxNumberGroupOfLocalMaximuns.go
char* reverse(char* s) ,"char* reverse(char* s) {
  if (*s == '\0') return s;
  char *head = s;
  char *e = s;
  while (*(e + 1)) e++;
  while (s < e) swap(s++, e--);
  return head;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
char* unique(char* str) ,"char* unique(char* str) {
  char *dst = str;
  for (char *i = str; *i ;i++) {
    char *j;
    for (j = str; j < dst; j++) {
      if (*j == *i)
        break;
    }
    if (j == dst)  // breakしなかった場合
      *dst++ = *i;
  }
  *dst = '\0';
  return str;
}
",/Users/mbp/workspace/sandbox/algo/list/list.c
length' :: [a] -> Int,"length' :: [a] -> Int
length' = foldr (const (+1)) 0
-- (const (+1)) 2 3 == 4
-- (+1) ((const) 2 3)
-- const 2 3 == 2
-- Error ((+1) . const) 2 3
",/Users/mbp/workspace/sandbox/algo/list/list.hs
reverse' :: [a] -> [a],"reverse' :: [a] -> [a]
reverse' = foldl (flip (:)) []
",/Users/mbp/workspace/sandbox/algo/list/list.hs
elem' :: (Eq a) => a -> [a] -> Bool  -- O(n),"elem' :: (Eq a) => a -> [a] -> Bool  -- O(n)
elem' a [] = False
elem' a (x:xs) = a == x || elem' a xs -- (n-1)の結果を使うものは、共有メモリで計算できると思った
",/Users/mbp/workspace/sandbox/algo/list/list.hs
unique' :: (Eq a) => [a] -> [a] -- O(n^2),"unique' :: (Eq a) => [a] -> [a] -- O(n^2)
unique' [] = []
unique' (x:xs) = let ys = unique' xs in if elem' x ys then ys else x:ys
",/Users/mbp/workspace/sandbox/algo/list/list.hs
foldl' :: (b -> a -> b) -> b -> [a] -> b,"foldl' :: (b -> a -> b) -> b -> [a] -> b
-- a0 + a1 + ... an = (((a0 + a1) + ... ) + an-1) + an)
-- foldl f a0 Sn = f (foldl a0 Sn-1) an
foldl' f acc [] = acc
foldl' f acc (x:xs) = foldl' f (f acc x) xs  -- 末尾再帰
",/Users/mbp/workspace/sandbox/algo/list/list.hs
foldr' :: (a -> b -> b) -> b -> [a] -> b,"foldr' :: (a -> b -> b) -> b -> [a] -> b
-- a1 + ... an + a0 = (a1 + ... + (an-1 + (an + a0)))
-- foldr f a0 Sn = f (foldr a0 Sn-1) an
foldr' f acc [] = acc
foldr' f acc (x:xs) = f x (foldr' f acc xs)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
:Q:foldlとfoldrの違い,"-- foldlは左の要素から計算(+) かつ、(acc X x)
-- foldrは右の要素から計算(cons) かつ、 (x X acc)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"span' :: (a -> Bool) -> [a] -> ([a], [a])","span' :: (a -> Bool) -> [a] -> ([a], [a])
-- 条件に合致し続けるまでの要素, それ以外
span' f [] = ([], [])
span' f (x:xs)
  | f x = let (ys, zs) = span' f xs in (x:ys, zs)
  | otherwise =  ([], x:xs)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"break' :: (a -> Bool) -> [a] -> ([a], [a])","break' :: (a -> Bool) -> [a] -> ([a], [a])
-- 条件に合致し続したところで終了
break' p = span (not . p)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
groupBy' :: (a -> a -> Bool) -> [a] -> [[a]],"groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]
-- A sorted list is required
groupBy' p [] = []
groupBy' p (x:xs) = (x:ys):(groupBy' p zs) where
  (ys, zs) = span (p x) xs
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"zip' :: [a] -> [b] -> [(a,b)]","zip' :: [a] -> [b] -> [(a,b)]
-- ２つの配列のうち、要素数の少ない方に要素数を合わせる
zip' [] y = []
zip' x [] = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
",/Users/mbp/workspace/sandbox/algo/list/list.hs
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c],"zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' f xs ys = map (uncurry f) (zip xs ys)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
deleteBy' :: Eq a => (a -> Bool) -> [a] -> [a],"deleteBy' :: Eq a => (a -> Bool) -> [a] -> [a]
deleteBy' eq [] = []
deleteBy' eq (x:xs) = let ys = deleteBy' eq xs in if eq x then ys else x:ys
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"unstableSplit :: [a] -> ([a], [a])","unstableSplit :: [a] -> ([a], [a])
-- リストの先頭の要素を2つ取り出して、双方に渡す
unstableSplit (x:y:zs) = (x:xs, y:ys) where (xs, ys) = unstableSplit zs
unstableSplit xs = (xs, [])
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"stableSplit :: [a] -> ([a], [a])","stableSplit :: [a] -> ([a], [a])
-- xsは1つ消費, ysは2つ消費. zsが0 or 1になるところでちょうどxsは半分消費したことになるので、そこで半分に分割
stableSplit xs = go xs xs where
  go (x:xs) (_:_:ys) = (x:us, vs) where (us, vs) = go xs ys
  go xs _ = ([], xs)
",/Users/mbp/workspace/sandbox/algo/list/list.hs
"; f(123, 0) = f(12, 3) = f(1, 32) = f(0, 321)","; f(123, 0) = f(12, 3) = f(1, 32) = f(0, 321)
(define (reverseInt-tail num)
  (let loop ((n num) (acc 0))
    (if (= n 0)
        acc
        (loop (div n 10) (+ (* acc 10) (mod n 10))))))
",/Users/mbp/workspace/sandbox/algo/list/reverseInt/reverseInt-tail.scm
"struct node* reverse(struct node* head, int k) ","struct node* reverse(struct node* head, int k) {
  int flag, count;
  struct node *n, *first, *last, *bf, *bl;
  flag = 1;
  count = 0;
  n = head;
  bf = bl = first = last = NULL;
  while (n) {
    if (count == k) {
      if (first == NULL && last == NULL) {
        first = bf;
        last = bl;
      } else {
        last->next = bf;
        last = bl;
      }
      flag = flag ? 0 : 1;
      bf = bl = NULL;
      count = 0;
    } else {
      struct node* next = n->next;  // 上書きされる前に次をあらかじめ保持しておく
      if (bf == NULL && bl == NULL) {
        n->next = NULL;
        bf = bl = n;
      } else if (flag) {
        n->next = bf;
        bf = n;
      } else {
        bl->next = n;
        bl = n;
      }
      count++;
      n = next;
    }
  }
  if (bf)
    last->next = bf;
  return first;
}
",/Users/mbp/workspace/sandbox/algo/list/reverseK/reverseK.c
reverseK :: Int -> [Int] -> [Int],"reverseK :: Int -> [Int] -> [Int]
reverseK k xs = go xs where
  go xs
    | length xs <= k     = a1
    | length xs <= 2 * k = a1 ++ a2
    | otherwise          = a1 ++ a2 ++ go a3
    where
      a1 = reverse $ take k xs
      a2 = take k $ drop k xs
      a3 = drop (2 * k) xs
",/Users/mbp/workspace/sandbox/algo/list/reverseK/reverseK.hs
def transpose(A):,"def transpose(A):
    m, n = len(A), len(A[0])
    B = [[None] * m for _ in range(n)]
    for i in range(m):
        for j in range(n):
            B[j][i] = A[i][j]
    return B
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
":Q:r[i,j]を求める式","# i<=j の時
# lr[i,j] = sum l[i,k]r[k,j] = l[i,1]r[1,j] + ... + l[i,i-1]r[i-1,j] + l[i,i]r[i,j]
# l[i,i] = 1より
# r[i,j] = lr[i,j] - sum(1<=k<=i-1) l[i,k]r[k,j] (i>=2)
# r[1,j] = lr[i,j] (i=1)  # 一番上の行は何もしない
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
":Q:l[i,j]を求める式","# j<i の時
# lr[i,j] = sum l[i,k]r[k,j] = l[i,1]r[1,j] + ... + l[i,j-1]r[j-1,j] + l[i,j]r[j,j]
# l[i,j] = {lr[i,j] - sum(1<=k<=j-1) l[i,k]r[k,j]} / r[j,j] (j>=2)
# l[i,1] = lr[i,1] / r[1,1] (j=1)  # i>=2以上についてr[1,1]で割る
# なお、 sum(1<=k<=0)=0とすれば、一つの式で表せる
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
:Q:decomposeWithoutPivot,"def decompose(A):
    m, n = len(A), len(A[0])
    for k in range(max(m, n)):
        for i in range(k + 1, m):
            A[i][k] /= float(A[k][k])
        for i in range(k + 1, m):
            for j in range(k + 1, n):
                A[i][j] -= float(A[i][k] * A[k][j])
    return A
# kを固定して[i,j]を動かす
# kまで求めたら、A[k,k]でそれより下の要素を割る
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
:Q:Lx=yを求める式,"# y[i] = sum A[i,k] x[k] = A[i,1] x[1] + ... + A[i,i-1] x[i-1] + 1 * x[i] + 0 ...
# x[i] = y[i] - sum (1<=k<=i-1) A[i,k] x[k]
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
:Q:Rx=zを求める式,"# z[i] = sum A[i,k] x[k] = A[i,i] x[i] + ... + A[i,n] x[n]  # i-1以下は0
# z[i] = sum (n>=k>=i) A[i,k] x[k]
# A[i,i] x[i] = z[i] - sum (n>=k>=i+1) A[i,k] x[k]  # 最後にA[i,i]で割る
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
:Q:Ax=yを解くプログラム,"def solve(A, y, do_decompose=True):
    # Ax=y => LUx=y => Lz=y => Ux=zの順に求める(y=>z=>xの順に解を上書き)
    n = len(A)  # 連立方程式は正方行列の必要あり
    if do_decompose:
        decompose(A)
    for i in range(n):
        for k in range(i):
            y[i] -= A[i][k] * y[k]  # k<i, y[k]=z[k]
    for i in reversed(range(n)):
        for k in range(i + 1, n):
            y[i] -= A[i][k] * y[k]  # i<k, y[k]=x[k]
        y[i] /= float(A[i][i])
    return y
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
:Q:AX=Eの逆行列を求める,"def inv(A):
    n = len(A)  # 逆行列は正則である必要あり
    decompose(A)  # LU分解は一度だけ行う
    X = []
    for i in range(n):
        e = [1 if i == j else 0 for j in range(n)]
        X.append(solve(A, e, do_decompose=False))
    return transpose(X)
",/Users/mbp/workspace/sandbox/algo/math/matrix/LU.py
:Q:fibを行列で表現,"# a(n+2)=1*a(n+1)+1*a(n)
# a(n+1)=1*a(n+1)+0*a(n)
# A=[[1,1],[1,0]]の行列で、３項間を表せる
# また(現在)=定数(一つ前)のような等比数列の形をしているので
# [a(n+2), a(n+1)]=A[a(n+1), a(n+0)]=A^2[a(n+0), a(n-1)] = ... =A^(n+1)[a1, a0]
# 検算(n=-1の時, 左辺=右辺に成る必要があるのでA^0=Eになる必要がある)
",/Users/mbp/workspace/sandbox/algo/math/matrix/fib.py
:Q:行列計算でのfib,"def fib(n):
    # mulは行列の積の計算. 繰り返し二乗法を用いてO(log n)
    def loop(n):
        if n == 0:
            return E
        elif n == 1:
            return A
        elif n % 2 == 0:
            a = loop(n / 2)
            return mul(a, a)
        else:
            a = loop((n - 1) / 2)
            return mul(A, mul(a, a))
    E = [[1, 0], [0, 1]]
    A = [[1, 1], [1, 0]]
    return mul(loop(n), [[1], [0]])[1][0]
",/Users/mbp/workspace/sandbox/algo/math/matrix/fib.py
:Q:行列AとBの積,"def mul(A, B):
    # 正方行列であることの仮定あり
    assert len(A) > 0 and len(B) > 0
    assert len(A[0]) == len(B)
    l, m, n = len(A), len(B), len(B[0])
    C = [[0] * n for _ in range(l)]
    # 3重ループ
    for i in range(l):
        for j in range(n):
            C[i][j] = sum(A[i][k] * B[k][j] for k in range(m))
    return C
",/Users/mbp/workspace/sandbox/algo/math/matrix/product.py
":Q:配列[x,y]にtrueの要素がいくつあるか?","def f(A, x, y):
    N = len(A)
    if not (0 <= x <= y < N):
        return None
    elif x == y:
        return A[x]  # this is not needed
    S = [0] * N
    S[0] = A[0]
    for i in range(1, N):
        a = 1 if A[i] else 0
        S[i] = S[i - 1] + a
    if x == 0:
        return S[y]
    else:
        return S[y] - S[x - 1]
",/Users/mbp/workspace/sandbox/algo/prefix-sum/count-true-in-list.py
":Q:数列a_nの要素が、少なくとも一つ[x, y]に含まれているか? (全体の範囲は[0,M))","def f(A, x, y):
    if not (0 <= x <= y <= len(A)):
        return None
    s = [0] * M  # メモリ確保
    for a in A:
        s[a] = 1
    for i in range(len(s) - 1):
        s[i + 1] += s[i]
    if x == 0:
        return s[y] == 1
    return s[y] != s[x - 1]
",/Users/mbp/workspace/sandbox/algo/prefix-sum/element-in-range.py
:Q:赤黒木のdata,"data Color = B | R deriving Show
data Hash k v = Leaf | Node Color (Hash k v) (k, v) (Hash k v) deriving Show
",/Users/mbp/workspace/sandbox/algo/sample/tree/red-black/red-black.hs
insert' :: Ord k => k -> v -> Hash k v -> Hash k v,"insert' :: Ord k => k -> v -> Hash k v -> Hash k v
insert' k v Leaf = Node R Leaf (k, v) Leaf
insert' k v (Node c a (k', v') b) = case compare k k' of
  LT -> balance $ Node c (insert' k v a) (k', v') b
  GT -> balance $ Node c a (k', v') (insert' k v b)
  EQ -> Node c a (k, v) b
",/Users/mbp/workspace/sandbox/algo/sample/tree/red-black/red-black.hs
balance :: Ord k => Hash k v -> Hash k v,"balance :: Ord k => Hash k v -> Hash k v
balance (Node B (Node R (Node R a x b) y c) z d) = (Node R (Node B a x b) y (Node B c z d))
balance (Node B (Node R a x (Node R b y c)) z d) = (Node R (Node B a x b) y (Node B c z d))
balance (Node B a x (Node R (Node R b y c) z d)) = (Node R (Node B a x b) y (Node B c z d))
balance (Node B a x (Node R b y (Node R d z c))) = (Node R (Node B a x b) y (Node B c z d))
balance x  = x
",/Users/mbp/workspace/sandbox/algo/sample/tree/red-black/red-black.hs
"fromList :: Ord k => [(k, v)] -> Hash k v","fromList :: Ord k => [(k, v)] -> Hash k v
fromList = foldl insert Leaf
insert :: Ord k => Hash k v -> (k, v) -> Hash k v
insert x (k, v) = turnB $ insert' k v x
",/Users/mbp/workspace/sandbox/algo/sample/tree/red-black/red-black.hs
:Q:配列を三等分する時の最大和(max(A[j:i]+A[i+k])),"func MaxDoubleSliceSum(A []int) int {
	K1 := make([]int, len(A)) // [0,i)までの最大和
	K2 := make([]int, len(A)) // (i,len(A)-1]までの最大和
	for i := 1; i < len(A)-1; i++ {
		K1[i] = max(K1[i-1] + A[i], 0)
	}
	for i := len(A)-2; i > 0; i-- {
		K2[i] = max(K2[i+1]+A[i], 0)
	}
	m := 0
	for i := 1; i < len(A)-1; i++ {
		m = max(m, K1[i-1]+K2[i+1])  // i番目を確定させておけば、後はどこかで区切れていればOK
	}
	return m
}
",/Users/mbp/workspace/sandbox/algo/seq/MaxDoubleSliceSum.go
:Q:0からN-1まで1~6ずつ進む中で、合計値が最大のもの,"func NumberSolitaire(A []int) int {
	var dfs func(int) int
	var min int = -1 << 30
	var memo = make([]int, len(A))
	for i := range memo { memo[i] = min }
	dfs = func(d int) int {
		if d == len(A)-1 {
			return A[d]  // 必ず解があると仮定して良い
		}
		if memo[d] != min {
			return memo[d]
		}
		max := min
		for i := 1; i <= 6; i++ {  // i<Nのパターンもあるね
			if i + d >= len(A) { continue }
			if t := dfs(i + d); t > max {
				max = t
			}
		}
		memo[d] = max + A[d]
		return memo[d]
	}
	return dfs(0)
}
",/Users/mbp/workspace/sandbox/algo/seq/NumberSolitaire.go
:Q:一次元を二次元に変換,"func OneToTwo(N, x int) int {
	if x >= N*N {
		panic(""x is huge"")
	}
	a := make([][]int, N)
	for i := 0; i < N; i++ {
		a[i] = make([]int, N)
		for j := 0; j < N; j++ {
			a[i][j] = i*N + j
		}
	}
    // OneToTwo(5, 23) = a[4][3] = 23
    return a[x/N][x%N]
}
",/Users/mbp/workspace/sandbox/algo/seq/OneToTwo.go
:Q:互いに通り過ぎる車の組み合わせ,"// 0=>, <=1に進むとして、1側を固定し0がいくつ通過するか数える
func solve(a []int) int {
	s := make([]int, len(a))
	s[len(a)-1] = 0
	for i := len(a)-1; i >= 1; i-- {
		s[i-1] += s[i] + a[i]
	}
	ans := 0
	for i := 0; i < len(a); i++ {
		if a[i] == 0 {
			ans += s[i]
		}
	}
	return ans
}
",/Users/mbp/workspace/sandbox/algo/seq/PassingCars.go
:Q:数列Snを２分割した数列の差の最小値,"func solve(a []int) int {
	sum := 0
	for i := 0; i < len(a); i++ { sum += a[i] }
	ms := abs(sum)
	for i := 0; i < len(a); i++ {
		sum -= 2*a[i]
		if ms > abs(sum) {
			ms = sum
		}
	}
	return ms
}
",/Users/mbp/workspace/sandbox/algo/seq/TapeEquilibrium.go
"int anagram(char* p, char* q) ","int anagram(char* p, char* q) {
  char counter[256] = {0};  // 256文字までと仮定
  int pl, ql;
  pl = ql = 0;
  // pにおけるそれぞれの文字数をカウント
  for (char* it = p; *it; it++) {
    char c = *it - 'a';
    counter[c]++;
    pl++;
  }
  // qで上で取得したカウンタを減算
  for (char* it = q; *it; it++) {
    char c = *it - 'a';
    counter[c]--;
    ql++;
    if (counter[c] < 0)  // 不足した時点で終了
      return 0;
  }
  if (pl == ql)
    return 1;  // p, qの長さが等しいも満たす必要あり(q側に余計な文字がないことの保証)
  return 0;
}
",/Users/mbp/workspace/sandbox/algo/seq/anagram/anagram.c
:Q:anagram,"anagram p q = (sort p) == (sort q)
",/Users/mbp/workspace/sandbox/algo/seq/anagram/anagram.hs
:Q:配列の要素が、少なくとも1回ずつ出現する数列のうち、最小のもの,"func atLeastOne(S []int, I int) int {
	buff := make([]int, len(S))
	sum := 0
	for i := 0; i < len(S); i++ {
		a := S[i]
		// if (a > I) continue;
		buff[a]++
		if buff[a] == 1 {
			sum++  // first found
		}
		if (sum == I+1) {  // [0, I]
			return i
		}
	}
	return -1;
}
func main() {
	fmt.Println(atLeastOne([]int{4,4,1,2,0,5,5,3,1,2}, 5))  // 7
}
",/Users/mbp/workspace/sandbox/algo/seq/atLeastOne.go
func continuousSubseq(a []int) int ,"func continuousSubseq(a []int) int {
	if (len(a) == 0) {
		return 0
	}
	var m, s int
	m = s = a[0]
	for i := 1; i < len(a); i++ { 
		s = max(s + a[i], a[i])
		m = max(m, s)
	}
	return m
}
",/Users/mbp/workspace/sandbox/algo/seq/continuousSubseq/continuousSubseq.go
:Q:ある数列の連続した部分数列の和の最大値,"c a b = compare (sum a) (sum b)
s [x] = [x]
s (x:xs) = maximumBy c [[x], (x:(s xs))]  -- xから新しくカウントし直す
m [x] = [x]  -- [-10]と[]を比べるため
m (x:xs) = maximumBy c [(m xs), (s(x:xs))]  -- 一つ手前と今
",/Users/mbp/workspace/sandbox/algo/seq/continuousSubseq/continuousSubseq.hs
func dominant(a []int) *int ,"func dominant(a []int) *int {
	if len(a) == 0 {
		return nil
	}
	stack := 1
	cnt := 1
	var c *int = &a[0]
	for i := 1; i < len(a); i++ {
		if a[i] == *c {
			stack++
			cnt++
		} else if stack > 0 {  // c is definitely not dominant
			stack--
		} else {
			stack = 1
			cnt = 1
			c = &a[i]
		}
	}
	if len(a) < 2*cnt {
		return c
	}
	return nil
}
",/Users/mbp/workspace/sandbox/algo/seq/dominant/dominant.go
"func equileader(A []int, x int) int ","func equileader(A []int, x int) int {
	// xが超過する場合の数を返す
	num := 0
	for i := 0; i < len(A); i++ {
		if A[i] == x {
			num++
		}
	}
	s, n := 0, 0  // nは、i番目までにおけるxの要素数
	for i := 0; i < len(A); i++ {
		if A[i] == x {
			n += 1
		}
		// 区間[0, i]にて、    xが半分超過すること (要素数i+1!)
		// 区間[i+1, n-1]にて、xが半分超過すること
		if 2 * n > i + 1 && 2 * (num - n) > len(A) - (i + 1) {
			s += 1
		}
	}
	return s
}
",/Users/mbp/workspace/sandbox/algo/seq/equileader.go
"func exp(a, n int) int ","func exp(a, n int) int {
	if (n == 0) {
		return 1;
	} else if (n % 2 == 0) {
		x := exp(a, n / 2)
		return x * x
	} else {
		x := exp(a, (n - 1) / 2)
		return x * x * a
	}
}
",/Users/mbp/workspace/sandbox/algo/seq/exp/exp.go
fib n,"fib n
  | n == 0 || n == 1 = n
  | otherwise        = fib(n - 1) + fib(n - 2)
",/Users/mbp/workspace/sandbox/algo/seq/fib/fib.hs
list_t* find(list_t* node) ,"list_t* find(list_t* node) {
  if (node == NULL)
    return NULL;
  list_t *fast, *slow;
  fast = slow = node;
  // find a point where both of two meet
  while (fast->next) {
    slow = slow->next;
    fast = fast->next->next;
    if (slow == fast)
      break;
  }
  // node is not cycled
  if (fast->next == NULL)
    return NULL;
  slow = node;
  while (slow != fast) {
    slow = slow->next;
    fast = fast->next;
  }
  return slow;
}
",/Users/mbp/workspace/sandbox/algo/seq/floyd-cycle-finding.c
":Q:gcd(44,12)のプロセス","; 44 12 => 12 8 => 8 4 => 4 0 (ans = 4)
",/Users/mbp/workspace/sandbox/algo/seq/gcd/gcd.scm
(define (gcd m n),"(define (gcd m n)
  (cond ((< m n) (gcd n m))
        ((= n 0) m)
        (else (gcd n (mod m n)))))
",/Users/mbp/workspace/sandbox/algo/seq/gcd/gcd.scm
:Q:共通約数のみ存在する場合はTrue,"f :: Int -> Int -> Bool
f a b = g a where
  g x = let y = gcd x b in
    if y == 1 then x == 1 else g (div x y)
main = do
  print $ f 75 15  -- {3 5}
  print $ f 15 75
  print $ f 8 15
",/Users/mbp/workspace/sandbox/algo/seq/has-other-divisor/has-other-divisor.hs
"func Horner(a []int, x int) int ","func Horner(a []int, x int) int {
	if len(a) == 0 { panic(""ERROR"") }
	s := a[0]
	for i := 1; i < len(a); i++ {
		s = s * x + a[i]
	}
	return s
}
",/Users/mbp/workspace/sandbox/algo/seq/horner.go
:Q:Least Common Multiple,"-- ab = lcm(a,b) * gcd(a,b)の関係式より
lcm' a b = div (a * b) (gcd a b)
",/Users/mbp/workspace/sandbox/algo/seq/lcm/lcm.hs
"func f(a, b string) string ","func f(a, b string) string {
	dp := make([][]string, len(a) + 1)
	for i := 0 ; i < len(dp); i++ { dp[i] = make([]string, len(b) + 1)}
	for x := 0; x < len(a); x++ {
		for y := 0; y < len(b); y++ {
			if a[x] == b[y] {
				dp[x+1][y+1] = dp[x][y] + string(a[x])
			} else {
				s1 := dp[x][y+1]
				s2 := dp[x+1][y]
				if len(s1) > len(s2) {
					dp[x+1][y+1] = s1
				} else {
					dp[x+1][y+1] = s2
				}
			}
		}
	}
	return dp[len(a)][len(b)]
}
",/Users/mbp/workspace/sandbox/algo/seq/lcs/lcs.go
:Q:LongestCommonSequence,"c a b = compare (length a) (length b)
f = g where
 g xss@(x:xs) yss@(y:ys)
  | x == y    = x : g xs ys
  | otherwise = maximumBy c [(g xss ys), (g xs yss)]
 g _ _ = """"
{-
f(x, y)
 =  0 (x = 0 or y = 0)
 = f(x-1, y-1) + 1 (x = y)
 = $max ${f(x-1,y), f(x, y-1) $} (else)
-}
",/Users/mbp/workspace/sandbox/algo/seq/lcs/lcs.hs
func localMaximum(x []int) []bool ,"func localMaximum(x []int) []bool {
	bs := make([]bool, len(x))
	for i := 1; i < len(x)-1; i++ {
		if x[i-1] < x[i] && x[i] > x[i+1] {
			bs[i] = true
		}
	}
	return bs
}
  
",/Users/mbp/workspace/sandbox/algo/seq/localMaximum.go
:Q:Kadane'sAlgorithm,"-- 株価の儲けの最大を求める
f (x:y:xs) = g (x-y) (x-y) (y:xs) where
  g s m (x:y:xs) = g ns nm (y:xs) where
    d  = x - y
    ns = max d (s + d)
    nm = max m ns  -- 暫定最大値
  g s m x = max m (-1)
main = do
  print $ f $ reverse [4,1,2,5,3]  -- 4 (2-1+5-2) 
  print $ f $ reverse [5,4,3,2,1]  -- -1 (失敗)
  print $ f $ reverse [4,1,2,5,3,4] -- 4
",/Users/mbp/workspace/sandbox/algo/seq/maxProfix.hs
:Q:x^2=n(newton),"// x(n+1) = xn - f(xn)/f'(xn)
func f(n, x1, e float64) float64 {
	for {
		x2 := x1 - (x1 * x1 - n) / (2 * x1)
		if (abs(x2-x1) < e) { return x2 }
		x1 = x2
	}
}
",/Users/mbp/workspace/sandbox/algo/seq/newton.go
:Q:polland,"; mod nとした乱数生成関数fとし、x,yの2数を生成させ、対象の整数の因数を求める。(x=yとなった場合は失敗)
(define (polland n)
 (define rlist (shuffle (iota n)))
 (let1 f (^x (ref rlist x))
       (let loop ((x 2) (y 2))
         (let* ((x (f x))
                (y (f (f y)))
                (d (gcd (abs (- x y)) n)))
           (cond ((= d 1) (loop x y))
                 ((= d n) -1)
                 (else d))))))
(define (main args)
  (print (polland 108))  ; 9
  (print (polland 3))  ; -1
  0)
",/Users/mbp/workspace/sandbox/algo/seq/polland/pollanrd-rho.scm
:Q:２つの素数の積の集合(同じものを含む),"def f(N):
 p = [True] * (N+1)
 p[0] = p[1] = False
 i = 2
 while i*i <= N:
  if p[i]:
   for j in range(i*i, N+1, i):
    p[j] = False
  i += 1
 s = [False] * (N+1)
 for i in range(N+1):
  if p[i]:
   j = i
   while j*i <= N:
    if p[j]:
     s[j*i] = True
    j += 1
 return [i for i in range(N+1) if s[i]]
print(f(4))  # [4]
print(f(100))  # [4, 6, 9, 10, 14, 15, 21, 22, 25, 26, 33, 34, 35, 38, 39, 46, 49, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95]
",/Users/mbp/workspace/sandbox/algo/seq/semi-prime/semi-prime.py
vector<bool> make_prime_table(int size),"vector<bool> make_prime_table(int size){
  vector<bool>isPrime(size, true);
  isPrime[0] = isPrime[1] = false;  // 0, 1は素数でないので2から始める
  for (int i = 2; i * i < size; i++) {  // (size-1)まで参照
    if (isPrime[i]) {
      // jは、iより小さい数からスタートしなくてよい(i=3なら、6でもなく9からでOK)
      for (int j = i; i * j < size; j++)
        isPrime[i * j] = false;
    }
  }
  return isPrime;
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.cpp
func generate() chan int ,"func generate() chan int {
	ch := make(chan int)
	go func() {
		for i := 2; ; i++ {
			ch <- i
		}
	}()
	return ch
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.go
"func filter(in chan int, prime int) chan int ","func filter(in chan int, prime int) chan int {
	out := make(chan int)
	go func() {
		for {
			if i := <- in; i % prime != 0 {
				out <- i
			}
		}
	}()
	return out
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.go
func sieve() chan int ,"func sieve() chan int {
	out := make(chan int)
	go func () {
		ch := generate()
		for {
			prime := <- ch
			out <- prime
			ch = filter(ch, prime)
		}
	}()
	return out
}
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.go
:Q:prime,"-- p*p以上の整数を篩にかける(残ったものが素数)
primes = f [2..] where
  f (p:xs) = p:f [x | x <- xs, (mod x p) /= 0]
",/Users/mbp/workspace/sandbox/algo/seq/sieve/sieve.hs
:Q:yates-shuffle,"// 末尾と取り替えるインデックスを決めて、それと末尾を入れ替え
func shuffle(a []int) {
	for i := len(a) - 1; i >= 1; i-- {
		j := rand.Int() % (i + 1)
		if ! (0 <= j && j <= i) { panic(""invalid"") }
		a[i], a[j] = a[j], a[i]
 }
}
",/Users/mbp/workspace/sandbox/algo/seq/yates/yates.go
:Q:anagram同士が隣同士になるようソート(CI9.2),"sort' :: [String] -> [String]
sort' = Data.List.sortBy (\a b -> compare (sort a) (sort b))
",/Users/mbp/workspace/sandbox/algo/sort/anagram-sort.hs
"void bsort(int *a, int *buff, int size, int range) ","void bsort(int *a, int *buff, int size, int range) {
  int counter[range], offset[range];
  for (int i = 0; i < range; i++) counter[i] = offset[i] = 0;
  for (int i = 0; i < size; i++) counter[a[i]]++;
  offset[0] = 0;
  for (int i = 0; i < range - 1; i++) offset[i + 1] = offset[i] + counter[i];
  for (int i = 0; i < size; i++) {
    int v = a[i];
    buff[offset[v]++] = v;  // 加えたら同じ値のoffsetは更新
  }
}
",/Users/mbp/workspace/sandbox/algo/sort/bucket-sort.c
"bucketsortBy :: (a -> Int) -> (Int, Int) -> [a] -> [a]","bucketsortBy :: (a -> Int) -> (Int, Int) -> [a] -> [a]
bucketsortBy getkey dom = concatMap reverse . filter (not . null)
    . elems . accumArray (flip (:)) [] dom . map (\x -> (getkey x, x))
",/Users/mbp/workspace/sandbox/algo/sort/bucket-sort.hs
bucketsort' :: [Int] -> [Int] -> [Int],"bucketsort' :: [Int] -> [Int] -> [Int]
bucketsort' keys xs = [x| k <- keys, x <- xs, x == k]
",/Users/mbp/workspace/sandbox/algo/sort/bucket-sort.hs
"int find(int *a, int left, int right, int pos) ","int find(int *a, int left, int right, int pos) {
  int k = left;
  int pivot = a[left];
  for (int i = left + 1; i <= right; i++)
    if (a[i] < pivot) swap(&a[i], &a[++k]);
  swap(&a[left], &a[k]);
  if (k == pos) return a[k];
  else if (pos < k) return find(a, left, k-1, pos);
  else return find(a, k+1, right, pos);
}
",/Users/mbp/workspace/sandbox/algo/sort/find-kth-smallest.c
"data_type maxChild(data_type *a, int parent, int size) ","data_type maxChild(data_type *a, int parent, int size) {
  int left, right;
  if ((left = LEFT(parent)) >= size)
    return 0;
  else if ((right = RIGHT(parent)) == size) {
    return left;
  } else if (a[left] < a[right])
    return right;
  else
    return left;
}
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.c
"void downHeap(data_type *a, int size) ","void downHeap(data_type *a, int size) {
  int parent = 0;
  while (1) {
    int child = maxChild(a, parent, size);
    if (child > 0 && a[parent] < a[child]) {
      swap(a, parent, child);
      parent = child;
    } else
      break;
  }
}
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.c
"data_type *heapSort(data_type *array, int size) ","data_type *heapSort(data_type *array, int size) {
  for (int i = 0; i < size; i++)
    upHeap(array, i);
  for (int i = size - 1; i >= 0; i--) {
    // swapではiは有効, downHeapではiは無効
    swap(array, 0, i);  // sort from last to first
    downHeap(array, i); 
  }
  return array;
}
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.c
data Heap a = Leaf | Node a [Heap a],"data Heap a = Leaf | Node a [Heap a]
  deriving Show
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
unify :: Ord a => [Heap a] -> Heap a,"unify :: Ord a => [Heap a] -> Heap a
unify [] = Leaf
unify [x] = x
unify (x:y:zs) = merge (merge x y) (unify zs)
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
merge :: Ord a => Heap a -> Heap a -> Heap a,"merge :: Ord a => Heap a -> Heap a -> Heap a
merge Leaf h = h
merge h Leaf = h
merge lhs@(Node l lh) rhs@(Node r rh)
  | compare l r == LT = Node l (rhs:lh)
  | otherwise         = Node r (lhs:rh)
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
fromList :: Ord a => [a] -> Heap a,"fromList :: Ord a => [a] -> Heap a
fromList = unify . map (\x -> (Node x []))
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
toList :: Ord a => Heap a -> [a],"toList :: Ord a => Heap a -> [a]
toList Leaf = []
toList (Node x xs) = x : toList (unify xs)
",/Users/mbp/workspace/sandbox/algo/sort/heap-sort.hs
sort :: Ord a => [a] -> [a],"sort :: Ord a => [a] -> [a]
sort [] = []
sort (x:xs) = insert x $ sort xs where
  insert y [] = [y]
  insert y (x:xs)
    | x < y = x:insert y xs
    | otherwise = y:x:xs
",/Users/mbp/workspace/sandbox/algo/sort/insert-sort.hs
"void msort(int *a, int left, int right) ","void msort(int *a, int left, int right) {
  if (left >= right)
    return;
  int mid = left + (right - left) / 2;
  msort(a, left, mid);
  msort(a, mid + 1, right);
  int l = left, r = mid + 1, k = 0;
  int len = right - left + 1;
  int buff[len];  // O(n)のスペースが必要(VLA)
  while (l <= mid && r <= right) {  // どちらか一方の配列を全て使い切るまでloop
    if (a[l] < a[r])
      buff[k++] = a[l++];
    else
      buff[k++] = a[r++];
  }
  while (l <= mid)   buff[k++] = a[l++];  // 残りの一方の配列をappend
  while (r <= right) buff[k++] = a[r++];
  memcpy(a + left, buff,  sizeof(int) * len);  // sizeof忘れ、offsetのleft忘れ
  /* for (int i = 0; i < len; i++) a[left + i] = buff[i]; */
}
",/Users/mbp/workspace/sandbox/algo/sort/merge-sort.c
sort :: Ord a => [a] -> [a],"sort :: Ord a => [a] -> [a]
sort [] = []
sort [x] = [x]
sort xs = merge (sort ys) (sort zs) where
  (ys, zs) = split xs
merge :: Ord a => [a] -> [a] -> [a]
merge xs [] = xs
merge [] ys = ys
merge xxs@(x:xs) yys@(y:ys)
  | x < y     = x:merge xs yys
  | otherwise = y:merge xxs ys
",/Users/mbp/workspace/sandbox/algo/sort/merge-sort.hs
"split :: [a] -> ([a], [a])  -- this is not stable","split :: [a] -> ([a], [a])  -- this is not stable
split (x:y:zs) = (x:xs, y:ys) where (xs, ys) = split zs
split xs = (xs, [])  -- after match
-- split []  = ([] , [])
-- split [x] = ([x], [])
",/Users/mbp/workspace/sandbox/algo/sort/merge-sort.hs
"void swap (int *x, int *y) ","void swap (int *x, int *y) {
  int t = *x;
  *x = *y;
  *y = t;
}
",/Users/mbp/workspace/sandbox/algo/sort/quick-sort.c
"void qsort (int *a, int left, int right) ","void qsort (int *a, int left, int right) {
  if (left >= right)
    return;
  int pivot = a[left];
  int l = left;
  int r = right;
  while (1) {  // l <= r可能?
    while (a[l] < pivot) l++;
    while (a[r] > pivot) r--;
    if (l <= r) {
      swap(&a[l], &a[r]);
      l++;
      r--;
    } else
      break;
  }
  qsort(a, left, r);
  qsort(a, l, right);
}
",/Users/mbp/workspace/sandbox/algo/sort/quick-sort.c
"func QuickSort(a []int, left, right int) ","func QuickSort(a []int, left, right int) {
	if !(left < right) {
		return
	}
	// pivotは左右を含むし、どこでもいいはず、なら左端に決め打つ
	var k, pivot int
	k, pivot = left, left
	for i := left + 1; i <= right; i++ {
		if a[i] < a[pivot] {
			k++ // kは前の最後の保存場所
			a[i], a[k] = a[k], a[i]
		}
	}
	// pivotを(全体の)k番目にする (覚えておくと組み立てやすい)
	a[pivot], a[k] = a[k], a[pivot]
	// pivotを境にソートされているので、kを含まなくて良い
	QuickSort(a, left, k-1)
	QuickSort(a, k+1, right)
}
",/Users/mbp/workspace/sandbox/algo/sort/quick-sort.go
positiveLsdSort :: (Bits a) => [a] -> [a],"positiveLsdSort :: (Bits a) => [a] -> [a]
positiveLsdSort = flip (foldl f) [0..bitSize (0 :: Int)] where
  f acc x = uncurry (++) $ partition (not . flip testBit x) acc
",/Users/mbp/workspace/sandbox/algo/sort/radix-sort.hs
"func hasArrayTwoCandidates(arr []int, sum int) bool ","func hasArrayTwoCandidates(arr []int, sum int) bool {
	left := 0
	right := len(arr) - 1
	for left < right {
		s := arr[left] + arr[right]
		if s == sum {
			return true
		} else if s < sum {
			left++
		} else {
			right--
		}
	}
	return false
}
",/Users/mbp/workspace/sandbox/algo/sorted/hasArrayTwoCandidates/hasArrayTwoCandidates.go
:Q:returnTrueIfSortedArrayHasTtriangle,"f a = any id [a!!i + a!!i+1 > a!!i+2 | i<-[0..length a-2]]
",/Users/mbp/workspace/sandbox/algo/sorted/triangle-exists.hs
:Q:配列の３つの積の最大値は,"# $max_{i,j,k $in N} a[i] $times a[j] $times a[k]
def f(data):
    s = sorted(data)
    m1 = s[-1] * s[-2] * s[3]
    m2 = s[0] * s[1] * s[-1]
    return max(m1, m2)
",/Users/mbp/workspace/sandbox/algo/sorted/triple-product.py
:Q:最小値をO(1)で取得できるstack.push()(ただし重複した値をpushしない),"func (s *Stack) Push(v Node) {
	s.stack = append(s.stack, v)
	if len(s.cache) == 0 || s.Min().value > v.value {
		s.cache = append(s.cache, v)
	}
}
",/Users/mbp/workspace/sandbox/algo/stack/minium-stack.go
:Q:最小値をO(1)で取得できるstack.pop()(ただし重複した値をpushしない),"func (s *Stack) Pop() *Node {
	if s.Empty() {
		return nil
	}
	x := s.stack[len(s.stack)-1]
	s.stack = s.stack[:len(s.stack)-1]
	if len(s.cache) != 0 && s.Min().value == x.value {
		s.cache = s.cache[:len(s.cache)-1]
	}
	return &x
}
",/Users/mbp/workspace/sandbox/algo/stack/minium-stack.go
class SetOfStacks ,"class SetOfStacks {
private:
  int threshold;
  list<stack<int>> stacks;
public:
  SetOfStacks(int threshold) {
    this->threshold = threshold;
  }
  void push(int value) {
    if (!stacks.empty()){
      stack<int>& last = stacks.back();
      if (last.size() < threshold)
        return last.push(value);
    }
    stack<int> s;
    s.push(value);
    stacks.push_back(s);
  }
  int pop() {
    if (empty())
      throw ""Empty stack can't pop\n"";
    stack<int>& last = stacks.back();
    if (last.empty()) {  // 因みに{}内でlastの上書きするとエラーみたい?
      stacks.pop_back();
      return pop();
    }
    int top = last.top();
    last.pop();
    return top;
  }
  bool empty() {
    if (stacks.empty())
      return true;
    stack<int>& last = stacks.back();
    if (stacks.size() == 1 && last.empty())
      return true;
    return false;
  }
};
",/Users/mbp/workspace/sandbox/algo/stack/setOfStack.cpp
:Q:2つのqueueでstackを実装,"type Queue struct {
	s1 Stack
	s2 Stack
}
func (q *Queue) Push(x int) {
	q.s1 = append(q.s1, x)
}
// FILOを2回繰り返せばFIFOになる
func (q *Queue) Pop() int {
	if !q.s2.Empty() {
		return q.s2.Pop()
	}
	for !q.s1.Empty() {  // s1は全てからにする!
		q.s2.Push(q.s1.Pop())
	}
	if !q.s2.Empty() {
		return q.s2.Pop()
	}
	panic(""Queue is empty"")
}
func (q *Queue)Empty() bool {
    return q.s1.Empty() && q.s2.Empty()
}
",/Users/mbp/workspace/sandbox/algo/stack/stackQueue.go
fibの級数表記をzipWidthで表現,"fib = 0:1:zipWith (+) fib (tail fib)
fib'@(_ : tf) = 0:1:zipWith (+) fib' tf
",/Users/mbp/workspace/sandbox/algo/stream/fib.hs
:Q:等比数列2^(n-1),"a = 1: map (*2) a
",/Users/mbp/workspace/sandbox/algo/stream/geometric.hs
整数の級数表記をzipWidthで表現,"integer = 1: zipWith (+) (repeat 1) integer
",/Users/mbp/workspace/sandbox/algo/stream/int.hs
// 以下の関係であればtrue,"// 以下の関係であればtrue
// apple == pleap
int isRotation(char* p, char* q) {
  int pl = strlen(p);
  int ql = strlen(q);
  if (pl != ql)
    return 0;
  // pのメモリが静的の場合もあるので動的にメモリを確保する
  int len = pl * 2 + 1;
  char* pp = malloc(sizeof(char) * len);
  strcat(pp, p);
  // pl=1のとき、pが1文字なので'\0'はpp+1に存在
  strcat(pp + pl, p);
  int result = strstr(pp, q) > 0;
  free(pp);  // 結果がわかれば領域は用済み
  return result;
}
",/Users/mbp/workspace/sandbox/algo/string/isRotation/isRotation.c
char* replaceSpacesWithP20(char* s) ,"char* replaceSpacesWithP20(char* s) {
  int length = 0;
  for (char* it = s; *it; it++) {
    if (*it == ' ')
      length += 3;
    else
      length += 1;
  }
  char* new = malloc(sizeof(char) * (length + 1));
  char* head = new;
  for (char* it = s; *it; it++) {
    if (*it == ' ') {
      *new++ = '%';
      *new++ = '2';
      *new++ = '0';
    }
    else
      *new++ = *it;
  }
  *new = '\0';
  return head;
}
",/Users/mbp/workspace/sandbox/algo/string/replaceSpacesWithP20.c
void insert(char* s) ,"  void insert(char* s) {
    char key = *s - 'a';
    if (*s == '\0')
      return;
    else if (children[key] == NULL)
      children[key] = new Trie();
    children[key]->insert(s + 1);
  }
",/Users/mbp/workspace/sandbox/algo/string/trie.cpp
bool find(char* s) ,"  bool find(char* s) {
    char key = *s - 'a';
    if (*s == '\0')
      return true;
    else if (children[key] == NULL)
      return false;
    return children[key]->find(s + 1);
  }
",/Users/mbp/workspace/sandbox/algo/string/trie.cpp
struct _bst ,"struct _bst {
  data_type data;
  struct _bst *parent;
  struct _bst *left;
  struct _bst *right;
};
typedef struct _bst bst_t;
bst_t *bst_init(data_type data) {
  bst_t *tree = (bst_t *)malloc(sizeof(bst_t));
  if (tree == NULL) {
    printf(""Out of memory\n"");
    exit(1);
  }
  tree->data = data;
  tree->parent = NULL;
  tree->left = NULL;
  tree->right = NULL;
  return tree;
}
",/Users/mbp/workspace/sandbox/algo/struct/bst.c
"void bst_insert(bst_t **bst, data_type data, bst_t *parent) ","void bst_insert(bst_t **bst, data_type data, bst_t *parent) {
  // O(log2n)
  // you don't need the arparent of parent as previous data
  // but it makes code more simple
  // WARN: it takes O(n) to insert a sorted list
  // if you insert range(0, 10), the height is 10
  bst_t *tree = *bst;
  if (tree == NULL) {
    tree = bst_init(data);
    tree->parent = parent;
    *bst = tree;
  } else if (tree->data >= data) {
    bst_insert(&(tree->left), data, tree);
  } else {
    bst_insert(&(tree->right), data, tree);
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/bst.c
"bst_t *bst_search(bst_t *tree, data_type data) {  // O(log2n)","bst_t *bst_search(bst_t *tree, data_type data) {  // O(log2n)
  if (tree == NULL)
    return NULL;
  else if (tree->data == data)
    return tree;
  else if (tree->data >= data)
    return bst_search(tree->left, data);
  else
    return bst_search(tree->right, data);
}
",/Users/mbp/workspace/sandbox/algo/struct/bst.c
:Q:DeleteBST,"// if tree has 2 children, find the child of the min data at the side of right
// TODO: how to delete root?
void bst_delete(bst_t **bst, data_type data) {
  bst_t *tree = *bst;
  // which side is connected with parent
  // left == 1 or right == -1 or root == 0
  int left = 0;
  while (1) {
    if (tree == NULL) {
      break;  // NOT FOUND
    } else if (tree->data > data) {
      left = 1;
      tree = tree->left;
    } else if (tree->data < data) { 
      left = -1;
      tree = tree->right;
    } else {
      // data is found
      bst_t *next = NULL;
      if (tree->left == NULL) {
        next = tree->right;  // it is ok whether right is NULL or not
      } else if (tree->right == NULL) {
        next = tree->left;
      } else {
        // the current tree has 2 children
        // so get the succesor tree, which is the min data
        bst_t *tmp = tree;
        left = tree->right->left ? 1 : -1;
        tree = tree->right;
        while (tree->left)
          tree = tree->left;
        tmp->data = tree->data;
        next = tree->right;
      }
      if (left == 1) {
        tree->parent->left = next;
      } else if (left == -1) {
        tree->parent->right = next;
      } else {
        *bst = next; // root which doesn't have both of the 2 children
      }
      if (next)
        next->parent = tree->parent;
      free(tree);
      break;
    }
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/bst.c
:Q:tree構造+init,"typedef struct _tree {
  int data;
  struct _tree* parent;
  struct _tree* left;
  struct _tree* right;
} btree;
btree *btree_init(int data) {
  btree *t = (btree *)malloc(sizeof(btree));
  t->parent = t->left = t->right = NULL;
  t->data = data;
  return t;
}
",/Users/mbp/workspace/sandbox/algo/struct/btree.h
struct _entry ,"struct _entry {
  char *key;
  data_type data;
  struct _entry *next;
};
struct _hash_table {
  int size;
  struct _entry **table;
};
typedef struct _entry entry_t;
typedef struct _hash_table hash_table_t;
",/Users/mbp/workspace/sandbox/algo/struct/hashtable.c
"int get_hash(hash_table_t *table, char *key) ","int get_hash(hash_table_t *table, char *key) {
  // hash must unsigned because it is used by an index of an array
  unsigned int v = 0;
  char *p = key;
  while (*p) {
    v += *p++;
  }
  return v % table->size;
}
",/Users/mbp/workspace/sandbox/algo/struct/hashtable.c
"entry_t *make_entry(char *key, data_type data) ","entry_t *make_entry(char *key, data_type data) {
  entry_t *n = (entry_t *)malloc(sizeof(entry_t));
  char *k = strdup(key);
  if (n == NULL || k == NULL) {
    printf(""Out of memory"");
    exit(1);
  }
  n->key = k;
  n->data = data;
  n->next = NULL;
  return n;
}
",/Users/mbp/workspace/sandbox/algo/struct/hashtable.c
"entry_t *ht_search(hash_table_t *ht, char *key) {  // O(n/size * key) ()","entry_t *ht_search(hash_table_t *ht, char *key) {  // O(n/size * key) ()
  int hashvalue = get_hash(ht, key);
  for (entry_t *e = ht->table[hashvalue]; e; e=e->next) {
    // it is better to take an action here not on the callee side
    // a key can't be hashed because collision should not occur here
    // so if you use a long key, it takes a long time to compare
    if (strcmp(e->key, key) == 0)
      return e;
  }
  return NULL;
}
",/Users/mbp/workspace/sandbox/algo/struct/hashtable.c
"void ht_insert(hash_table_t *ht, char *key, data_type data) {  // O(n/size + key)","void ht_insert(hash_table_t *ht, char *key, data_type data) {  // O(n/size + key)
  entry_t *e = ht_search(ht, key);
  if (e == NULL) {
    // create
    int hashvalue = get_hash(ht, key);
    entry_t *n = make_entry(key, data);
    // insert at the head
    n->next = ht->table[hashvalue];
    ht->table[hashvalue] = n;
  } else {
    // update
    e->data = data;
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/hashtable.c
"void ht_delete(hash_table_t *ht, char *key) {  // O(n/size + key)","void ht_delete(hash_table_t *ht, char *key) {  // O(n/size + key)
  entry_t *e = ht_search(ht, key);
  if (e) {
    int hashvalue = get_hash(ht, key);
    // should move this code into ht_search
    for (entry_t *e = ht->table[hashvalue], *p = NULL; e; p=e, e=e->next) {
      if (strcmp(e->key, key) == 0) {
        if (p == NULL)
          ht->table[hashvalue] = e->next;
        else
          p->next = e->next;
        free(e);
      }
    }
  } else {
    printf(""Not found key"");
    exit(1);
  }
}
// insert key value
// search
",/Users/mbp/workspace/sandbox/algo/struct/hashtable.c
:Q:list構造,"struct _list {
  int data;
  struct _list *next;
};
typedef struct _list list_t;
list_t* init(int data){
  list_t* newNode = (list_t*) malloc(sizeof(list_t));
  if (newNode == NULL) {
    exit(1);
  }
  newNode->data = data;
  newNode->next = NULL;
  return newNode;
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
"void append(list_t** head, int data)","void append(list_t** head, int data){
  // add an item to the last of a list O(n)
  list_t* n = init(data);
  if (*head == NULL) {
    *head = n;
  } else {
    list_t* last = *head;
    while(last->next)
      last = last->next;
    last->next = n;
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
"void append1(list_t** start, list_t** end, int data)","void append1(list_t** start, list_t** end, int data){
  // add an item to the last of a list O(1)
  list_t* n = init(data);
  if (*start == NULL) {
    *start = n;
    *end = n;
  } else {
    (*end)->next = n;
    *end = n;
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
"list_t* inits(int argc, ...) ","list_t* inits(int argc, ...) {
  // with append1, O(n)
  // if you use append, the complexity is O(n^2)
  if (argc <= 0)
    return NULL;
  va_list list;
  va_start(list, argc);
  // WARN: you need NULL, or sometimes it's initilized by the other value
  // NULL needs including stdio.h header
  list_t* head = NULL;
  list_t* tail = NULL;
  for (int i = 0; i < argc; i++)
    append1(&head, &tail, va_arg(list, int));
  va_end(list);
  return head;
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
"list_t* search(list_t *head, int data) {  // O(n)","list_t* search(list_t *head, int data) {  // O(n)
  while (head) {
    if (head->data == data)
      return head;
    head = head->next;
  }
  return NULL;
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
// Delete the node of the argument,"// Delete the node of the argument
void deleteThis(list_t* node) {
  if (node == NULL)
    return;
  else if (node->next == NULL) {
    // the last item;
    // you need previous node to set null the next node
    // free(prev);
    // prev->next = null;  // I can't do here!
    printf(""Can't delete the last item"");
    exit(1);
  } else {
    list_t *tmp = node->next;
    node->data = tmp->data;
    node->next = tmp->next;
    free(tmp);  // Don't forget!
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
int removeThis(list_t* node) ,"int removeThis(list_t* node) {
  if (node == NULL || node->next == NULL)
    return 0;
  list_t* tmp = node->next;
  node->data = node->next->data;
  node->next = node->next->next;
  free(tmp);
  return 1;
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
list_t* unique(list_t* head) ,"list_t* unique(list_t* head) {
  list_t* current = head;
  while (current) {
    list_t* next = current->next;
    list_t* prev = current;
    while (next) {
      if (next->data == current->data) {
        prev->next = next->next;
        free(next);
        next = prev->next;
      } else {
        prev = next;
        next = next->next;
      }
    }
    current = current->next;
  }
  return head;
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
list_t* removeAllDups(list_t* head) ,"list_t* removeAllDups(list_t* head) {
  // 同じものがあれば、全て削除する(uniqueではない)
  list_t *f = NULL, *l = NULL, *current = head;
  while (current) {
    int found = 0;
    list_t* next = current->next;
    list_t* prev = current;
    while (next) {  // ここはuniqueと同じ
      if (next->data == current->data) {
        found = 1;
        prev->next = next->next;
        free(next);
        next = prev->next;
      } else {
        prev = next;
        next = next->next;
      }
    }
    if (found) {  // 自分自身も削除
      list_t* tmp = current; 
      current = current->next;
      free(tmp);
    } else {
      if (f == NULL && l == NULL) {
        f = l = current;
      } else {
        l->next = current;
        l = l->next;
      }
      current = current->next;
      l->next = NULL;
    }
  }
  return f;
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
"list_t* lastButK(list_t* node, int k) ","list_t* lastButK(list_t* node, int k) {
  // 配列の長さ-k-1で要素を取得するでもよいが、kだけ先読みしたpointerを1つ用意することで高速化可能
  if (k < 0)
    return NULL;
  list_t *s, *e;
  s = e = node;
  for (int i = 0; i < k; i++) {
    if (e == NULL)
      return NULL;
    e = e->next;
  }
  while (e) {  // s <= eが成立
    s = s->next;
    e = e->next;
  }
  return s;  // k=0の時NULL
}
",/Users/mbp/workspace/sandbox/algo/struct/list.c
:Q:btree構造,"struct _rbtree {
  enum _color color;
  rbtree_data_type data;
  struct _rbtree *parent;
  struct _rbtree *left;
  struct _rbtree *right;
};
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
"#define APPEND_L(p, c) {                        \","#define APPEND_L(p, c) {                        \
    (p)->left  = (c);                           \
    if ((c) != NULL) (c)->parent = (p);         \
  }
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
"#define APPEND_R(p, c) {                        \","#define APPEND_R(p, c) {                        \
    (p)->right = (c);                           \
    if ((c) != NULL) (c)->parent = (p);         \
  }
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
"#define APPEND_P(root, tree, c) {                 \","#define APPEND_P(root, tree, c) {                 \
    if ((tree)->parent == NULL) {                \
      (*root) = (c);                              \
      (c)->parent = NULL;                         \
    } else { _APPEND_P(tree, c); }               \
  }
#define _APPEND_P(c1, c2) {                     \
    if ((c1)->parent->left == (c1))             \
      { (c1)->parent->left = (c2); }            \
    else { (c1)->parent->right = (c2); }        \
    (c2)->parent = (c1)->parent;                \
    (c1)->parent = NULL;                        \
  }
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
#define LEFT_CHILD(c) ((c)->parent->left == (c)),"#define LEFT_CHILD(c) ((c)->parent->left == (c))
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
#define RIGHT_CHILD(c) ((c)->parent->right == (c)),"#define RIGHT_CHILD(c) ((c)->parent->right == (c))
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
// -> y r-> x l-> z,"// -> y r-> x l-> z
// -> x l-> y r-> z
void rotateL(rbtree_t **root, rbtree_t *tree) {
  // rbtree_t *tree = *root;
  if (tree == NULL || tree->right == NULL) {
    printf(""Can't rotate"");
    exit(1);
  }
  rbtree_t *r = tree->right;
  rbtree_t *rl = r->left;
  APPEND_P(root, tree, r);
  APPEND_L(r, tree);
  APPEND_R(tree, rl);
}
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
"void rbtree_balance(rbtree_t **root, rbtree_t *tree) ","void rbtree_balance(rbtree_t **root, rbtree_t *tree) {
  rbtree_t *p, *u;  // parent, uncle
  while ((p = tree->parent) && p->color == RED && p->parent) {
    if (LEFT_CHILD(p))
      u = p->parent->right;
    else
      u = p->parent->left;
    if (u && u->color == RED) {
      // make a grand parent RED and loop from it recursively
      p->parent->color = RED;
      p->color = u->color = BLACK;
      tree = tree->parent->parent;
    } else {
      // make a parent BLACK and a grand parent RED and rotate
      // (on other way, make a current tree black and loop recursively!)
      // so that the parent is at the top. And finish loop
      // in other words, swap the colors between a parent and a grand parent
      if (LEFT_CHILD(p)) {
        if (RIGHT_CHILD(tree)) {
          // LR
          // after rotation, a tree's pointer is the same as LL
          tree = p;
          rotateL(root, tree);
        }
        // LL
        tree->parent->color = BLACK;
        tree->parent->parent->color = RED;
        rotateR(root, tree->parent->parent);
      } else {
        if (LEFT_CHILD(tree)) {
          // RL
          tree = p;
          rotateR(root, tree);
        }
        // RR
        tree->parent->color = BLACK;
        tree->parent->parent->color = RED;
        rotateL(root, tree->parent->parent);
      }
    }
  }
}
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
"void rbtree_insert(rbtree_t **root, rbtree_data_type data) ","void rbtree_insert(rbtree_t **root, rbtree_data_type data) {
  rbtree_t *node = (rbtree_t *)malloc(sizeof(rbtree_t));
  if (node == NULL) {
    printf(""Out of memory"");
    exit(1);
  }
  node->color = RED;  // new data is always RED
  node->data = data;
  node->left = node->right = node->parent = NULL;
  if (*root == NULL) {
    *root = node;
  } else {
    rbtree_t *parent = NULL, *tree = *root;
    while (1) {
      if (tree->data >= data) {
        if (tree->left) {
          parent = tree->parent;
          tree = tree->left;
        } else {
          tree->left = node;
          node->parent = tree;
          break;
        }
      } else {
        if (tree->right) {
          parent = tree->parent;
          tree = tree->right;
        } else {
          tree->right = node;
          node->parent = tree;
          break;
        }
      }
    }
    rbtree_balance(root, node);
  }
  (*root)->color = BLACK;
}
",/Users/mbp/workspace/sandbox/algo/struct/myrbtree.h
node_t* init(int value),"node_t* init(int value){
  node_t* newNode = (node_t*) malloc(sizeof(node_t));
  if (newNode == NULL)
    return NULL;
  newNode->value = value;
  newNode->next = NULL;
  return newNode;
}
",/Users/mbp/workspace/sandbox/algo/struct/stack.c
"void push(node_t** head, int value)","void push(node_t** head, int value){
  // stackはリストの先頭に要素を加えていくことでO(1)を実現
  node_t* new = init(value);
  if (*head == NULL) {
    *head = new;
    return;
  }
  node_t* first = *head;
  new->next = first;
  *head = new;
}
",/Users/mbp/workspace/sandbox/algo/struct/stack.c
void pop(node_t** head),"void pop(node_t** head){
  node_t* first = *head;
  if (first == NULL)  // empty
    return;
  int value = first->value;
  *head = first->next;
  free(first);
}
",/Users/mbp/workspace/sandbox/algo/struct/stack.c
char *s_strip(char *str) ,"char *s_strip(char *str) {
  while (*str == ' ')
    str++;
  char *last = str;
  while (*last)
    last++;
  last--;  // go backword from '\0'
  while (*last == ' ')
    last--;
  *++last = '\0';
  return str;
}
",/Users/mbp/workspace/sandbox/algo/struct/string.c
"int s_strcmp(char *p, char *q) ","int s_strcmp(char *p, char *q) {
  while (*p && *q) {
    if (*p < *q)
      return -1;
    else if (*p > *q)
      return 1;
    p++;
    q++;
  }
  if (*p)
    return 1;  // q is longer
  else if (*q)
    return -1;  // p is longer
  else
    return 0; // same length
}
",/Users/mbp/workspace/sandbox/algo/struct/string.c
int s_strlen(char *str) ,"int s_strlen(char *str) {
  char *last = str;
  while (*last) last++;
  return last - str;
}
",/Users/mbp/workspace/sandbox/algo/struct/string.c
"char *s_join(char **str, char delim, int length) ","char *s_join(char **str, char delim, int length) {
  int sum = 0;
  for (int i = 0; i < length; i++)
    sum += s_strlen(str[i]);
  sum += length;  // delim * (length - 1) + '\0'
  char *p, *q;
  p = q = (char *)malloc(sizeof(char) * sum);
  for (int i = 0; i < length; i++) {
    for (char *s = str[i]; *s; s++)
      *q++ = *s;
    *q++ = delim;
  }
  *--q = '\0';
  return p;
}
",/Users/mbp/workspace/sandbox/algo/struct/string.c
char *s_lower(char *str) ,"char *s_lower(char *str) {
  for (char *c = str; *c; c++) {
    if ('A' <= *c && *c <= 'Z') {
      *c = 'a' + (*c - 'A');
    }
  }
  return str;
}
",/Users/mbp/workspace/sandbox/algo/struct/string.c
"int s_is_substring(char *ps, char *qs) ","int s_is_substring(char *ps, char *qs) {
  char *p, *q;
  for (char *s = ps; *s; s++) {
    char *p = s;
    char *q = qs;
    while (*p && *q)
      if (*p == *q) {
        p++;
        q++;
      } else
        break;
    if (*q == '\0')
      return 1;
  }
  return -1;
}
  /* printf(""%d\n"", isSubstring(""abcdefg"", ""cde"")); */
  /* printf(""%d\n"", isSubstring(""abcdefg"", ""ced"")); */
  /* printf(""%d\n"", isSubstring(""abcdefg"", """")); */
  /* printf(""%d\n"", isSubstring(""abc"", ""abcdefg"")); */
",/Users/mbp/workspace/sandbox/algo/struct/string.c
"char* myremove(char c, char* str) ","char* myremove(char c, char* str) {
  char *dst = str;
  for (char *it = str; *it ;it++) {
    if (*it != c)
      *dst++ = *it;
  }
  *dst = '\0';
  return str;
}
  /* char s1[] = ""abcabc""; */
  /* printf(""%s\n"", myremove('c', s1)); */
",/Users/mbp/workspace/sandbox/algo/struct/string.c
:Q:vector構造,"struct _vector {
  int* data;
  size_t size;
};
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
"vector_t *inits(size_t size, ...) ","vector_t *inits(size_t size, ...) {
  // O(n)
  vector_t *n = init(size);
  va_list list;
  va_start(list, size);
  int *data = n->data;
  for (int i = 0; i < size; i++) {
    *data++ = va_arg(list, int);
  }
  va_end(list);
  return n;
}
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
"int equal(vector_t *v1, vector_t *v2) ","int equal(vector_t *v1, vector_t *v2) {
  if (v1->size != v2->size)
    return 0;
  for (int i = 0; i < v1->size; i++)
    if (v1->data[i] != v2->data[i])
      return 0;
  return 1;
}
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
"int indexAt(vector_t *head, int index) ","int indexAt(vector_t *head, int index) {
  // O(1)
  // Using a vector, you can access an element of it for a constant time.
  if (0 <= index && index < head->size)
    return head->data[index];
  printf(""Out of index"");
  exit(1);
}
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
"void insertAt(vector_t *head, int index, int value) ","void insertAt(vector_t *head, int index, int value) {
  // O(n + 1) or O(2n)
  // I think if realloc returns aother pinter, it means memcpy is executed so it needs O(n)
  int *data = (int *)realloc(head->data, sizeof(int) * (head->size + 1));
  if (data == NULL)
    exit(1);
  head->data = data;
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
"void deleteAt(vector_t *head, int index) ","void deleteAt(vector_t *head, int index) {
  // O(n)
  if (index == 0)
    return;
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
"vector_t *append(vector_t *h1, vector_t *h2) ","vector_t *append(vector_t *h1, vector_t *h2) {
  // O(n + m) M(n + m)
  if (h1 == NULL || h2 == NULL) {
    printf(""Can't append"");
    exit(1);
  }
  // At first you need the size of h1 + h2 to get memory
  size_t s = h1->size + h2->size;
  vector_t *n = init(s);
  memcpy(n->data, h1->data, sizeof(int) * h1->size);
  memcpy(n->data + h1->size, h2->data, sizeof(int) * h2->size);
  return n;
}
",/Users/mbp/workspace/sandbox/algo/struct/vector.c
:Q:flatten,"-- squishの第二引数は結果を保持
data Tree a = Node a [Tree a] deriving Show
flatten :: Tree a -> [a]
flatten t = squish t []
  where squish (Node x ts) xs = x:foldr squish xs ts
",/Users/mbp/workspace/sandbox/algo/tree/flatten/flatten.hs
(define (flatten tree),"(define (flatten tree)
  (fold (lambda (x acc)
          (append acc (if (pair? x)
                          (flatten x)
                          (list x))))
        '()
        tree))
",/Users/mbp/workspace/sandbox/algo/tree/flatten/flatten.scm
% 0 -> 1 -> 2 -> 3の順でプロセスkilled,"% 0 -> 1 -> 2 -> 3の順でプロセスkilled
c(0)->
    receive after 1000 -> exit(""DEAD"") end;
c(N) ->
    process_flag(trap_exit, true),  % EXITのシグナルキャッチ
    spawn_link(fun() -> c(N-1) end),
    receive {'EXIT', _Process, _Reason} = E -> io:format("":~p:"", [E]) end,  % Reason==""DEAD""
    io:format("":::~p:::"", [N]),  % 出力されない(trap_exit有無に関わらず呼ばれない)
    ok.
main() ->
    spawn_link(chain, c, [3]),
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/chain.erl
:Q:restarter,"start() ->
    spawn(?MODULE, restarter, []).
judge(Album) ->
    Ref = make_ref(),  % 自分宛のメールのID
    critic ! {self(), Ref, Album},
    receive
        {Ref, Criticism} -> {Criticism}
    after 2000 ->                                
            timeout
    end.
restarter() ->
    process_flag(trap_exit, true),
    Pid = spawn_link(?MODULE, critic, []),  % 関数とプロセス名同じでも動く
    register(critic, Pid),
    receive
        {'EXIT', Pid, normal} -> ok;
        {'EXIT', Pid, shutdown} -> ok;
        {'EXIT', Pid, _} -> restarter()
    end.
critic()->
    receive
        {From, Ref, {""A""}} ->
            From ! {Ref, ""A HOGE""};
        {From, Ref, _} ->
            From ! {Ref, ""HOGE HOGE !!!!""}
    end,
    critic().
main() ->
    start(),
    receive after 100 -> ok end,
    io:format(""~p~n"", [judge(""A"")]),
    exit(whereis(critic), kill),
    receive after 100 -> ok end,
    io:format(""~p~n"", [judge(""_"")]),
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/linkmon.erl
:Q:monitorの特徴,"% they are unidirectional
% they can be stacked.
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:monitorの正常戻り値,"    erlang:monitor(process, spawn(fun() -> timer:sleep(100) end)),
    receive {'DOWN', _Ref ,process, _Pid, normal} -> io:format(""DOWN~n"", []) end,
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:demonitorのinfo,"    Ref = erlang:monitor(process, spawn(fun() -> timer:sleep(5000) end)),
    io:format(""~p~n"", [demonitor(Ref, [info])]),  % まだ監視プロセスは生きているのでtrue
    receive _ -> io:format(""NOT REACHED~n"", []) after 100 -> ok end,
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:demonitorのflush,"    Ref2 = erlang:monitor(process, spawn(fun() -> ok end)),
    receive after 1000 -> ok end,
    io:format(""~p~n"", [demonitor(Ref2, [flush])]),  % メッセージ破棄(flushがないと、メッセージを受け取る)
    receive _ -> io:format(""NOT REACHED~n"", []) after 100 -> ok end,
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/monitor.erl
:Q:linkの使いどころ,"% リンクは組織的な構造というもの以上の作りになっています。 アプリケーションの構造を設計するときに、どのプロセスがどんな役割をするか決めて、何が何に依存するかを決めるでしょう。 あるプロセスは他のプロセスを監視し、あるプロセスは双子のプロセスがいないと生きていらない、などです。 この構造は通常固定されていて、事前に知ることが出来ます。 
",/Users/mbp/workspace/sandbox/book/lyse/14/trap.erl
:Q:trapの種類,"% REPLではflush().を使ってメッセージを受け取ること
main () ->
    process_flag(trap_exit, true),
    spawn_link(fun() -> ok end),
    receive A1 -> io:format(""~p~n"", [A1]) end,  % {'EXIT',<0.58.0>,normal}
    spawn_link(fun() -> exit(""HOGE"") end),
    receive A2 -> io:format(""~p~n"", [A2]) end,  % {'EXIT',<0.58.0>,""HOGE""}
    spawn_link(fun() -> exit(normal) end),
    receive A3 -> io:format(""~p~n"", [A3]) end,  % {'EXIT',<0.58.0>,normal}
    spawn_link(fun() -> exit(self(), kill) end),
    receive A4 -> io:format(""~p~n"", [A4]) end,  % {'EXIT',<0.58.0>,killed}
    spawn_link(fun() -> exit(kill) end),
    receive A6 -> io:format(""~p~n"", [A6]) end,  % {'EXIT',<0.58.0>,kill}
    spawn_link(fun() -> 1/0 end),
    receive A5 -> io:format(""~p~n"", [A5]) end,  % {badarith}
    exit(spawn_link(fun() -> timer:sleep(100) end), reason),  % 外部からEXIT
    receive A7 -> io:format(""~p~n"", [A7]) end,  % {'EXIT',<0.64.0>,reason}
    io:format(""~nDONE~n"", []),
    ok.
",/Users/mbp/workspace/sandbox/book/lyse/14/trap.erl
(define (extend-environment vars vals base-env),"(define (extend-environment vars vals base-env)
  (if (equal? (length vars) (length vals))
      (cons (cons vars vals) base-env)
      (error ""The lengths of vars and vals are not equal"")))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (lookup-variable-value var env),"(define (lookup-variable-value var env)
  (env-action var
              env
              car
              (lambda () (lookup-variable-value var (enclosing-environment env)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define  (set-variable-value! var val env),"(define  (set-variable-value! var val env)
  (env-action var
              env
              (lambda (vals) (set-car! vals val))
              (lambda () (set-variable-value! var val (enclosing-environment env)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (define-variable! var val env),"(define (define-variable! var val env)
  (env-action var
              env
              (lambda (vals) (set-car! vals val))
              (lambda () (add-binding-to-frame! var val (first-frame env)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (env-action var env found-action null-action),"(define (env-action var env found-action null-action)
  (define (scan-env var env)
    (define (loop vars vals)
      (cond ((null? vars) '())
            ((eq? var (car vars)) vals)
            (else (loop (cdr vars) (cdr vals)))))
    (let ((frame (first-frame env)))
      (loop (frame-variables frame)
            (frame-values frame))))
  (if (eq? env the-empty-environment)
      (error ""Unbound variable"" var)
      (let ((vals (scan-env var env)))
        (if (null? vals)
            (null-action)
            (found-action vals)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/env.scm
(define (eval-apply exp env),"(define (eval-apply exp env)
  (let* ((values (map (lambda (x) (eval x env)) exp))
         (proc (car values))
         (name (car proc))
         (args (cdr values)))
    (cond
     ((eq? name 'primitive)
      (let ((f (cadr proc)))
        (apply f args)))
      ((eq? name 'procedure)
       (let* ((vars (cadr proc))
              (exps (caddr proc))
              (base-env (cadddr proc))
              (new-env (extend-environment vars args base-env))
              (values (map (lambda (e) (eval e new-env)) exps)))
         (last values)))
     (else (error ""Unknown procedure"" proc)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/apply.scm
(define (eval-begin exp env),"(define (eval-begin exp env)
  (let ((exps (cdr exp)))
    (if (null? exps)
        0
        (let ((values (map (lambda (e) (eval e env)) exps)))
          (last values)))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/begin.scm
(define (eval-define exp env),"(define (eval-define exp env)
  (let ((symbol (cadr exp))
        (expr (caddr exp)))
    (define-variable! symbol (eval expr env) env)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/define.scm
(define (eval-if exp env),"(define (eval-if exp env)
  (let ((pred (cadr   exp))
        (true (caddr  exp))
        (false-body (cdddr exp)))
    (if (eval pred env)
        (eval true env)
        (if (null? false-body)
            '()
            (last (map (lambda (e) (eval e env)) false-body))))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/if.scm
(define (eval-let exp env),"(define (eval-let exp env)
  (let* ((var-arg (cadr exp))
         (body (caddr exp))
         (vars (map car var-arg))
         (args (map cadr var-arg)))
  (eval `((lambda ,vars ,body) ,@args) env)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/let.scm
(define (eval-quote exp env),"(define (eval-quote exp env)
; (quote EXPR)
  (cadr exp))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval/quote.scm
(define (eval exp env),"(define (eval exp env)
  (cond
   ; atom
   ((string? exp) exp)
   ((number? exp) exp)
   ((symbol? exp) (lookup-variable-value exp env))
   ((member (car exp) load-names)
    (let* ((name (format ""eval-~A"" (symbol->string (car exp))))
           (f (builtin-eval (string->symbol name) (interaction-environment))))
      (f exp env)))
   ((pair? exp) (eval-apply exp env))
   (else (error ""Unknown exp"" exp))))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval.scm
(define (self-evaluating? exp),"(define (self-evaluating? exp)
  (cond ((number? exp) #t)
        ((string? exp) #t)
        (else #f)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/eval.scm
(define (setup-environment),"(define (setup-environment)
  (let ((initial-env (extend-environment
                      (map (lambda (a) (car a)) primitive-procedures)
                      (map (lambda (a) (list 'primitive (cadr a))) primitive-procedures)
                      the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/main.scm
(define (driver-loop),"(define (driver-loop)
  (print ""> "")
  (let* ((intput (read))
         (output (eval intput the-global-environment)))
    (print output)
    (driver-loop)))
",/Users/mbp/workspace/sandbox/book/sicp/evaluator/main.scm
func brace(str string) bool ,"func brace(str string) bool {
	s := []byte{}
	for i := 0; i < len(str); i++ {
		c := str[i]
		if c == '(' || c == '{' || c == '[' {
			s = append(s, c)
		} else {
			if len(s) == 0 {  // s[]の参照するので、その前に要素があるか確認が必要
				return false
			} else {
				s0 := s[len(s)-1]
				s = s[:len(s)-1]
				if (c == ')' && s0 == '(') || (c == ']' && s0 == '[') || (c == '}' && s0 == '{') {
				} else {
					return false
				}
			}
		}
	}
	if len(s) == 0 {  // これがないと({[を受理してしまう
		return true
	} else {
		return false
	}
}
",/Users/mbp/workspace/sandbox/compiler/brace/brace.go
:Q:JSONのdata,"data JSON = 
    Number Double
  | Null
  | JsonString String
  | Bool Bool
  | Array [JSON]
  | Object [(String, JSON)]
  deriving (Show, Eq)
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
literalString :: Parser String,"literalString :: Parser String
literalString = do
  char '""'
  xs <- many $ noneOf ""\""""
  char '""'
  return xs
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
parseTrue :: Parser JSON,"parseTrue :: Parser JSON
parseTrue = string ""true"" *> (return $ Bool True)
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
parseArray :: Parser JSON,"parseArray :: Parser JSON
parseArray = do
  char '['
  xs <- sepBy (ws *> jsonValue <* ws) (char ',')
  char ']'
  return $ Array xs
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
parseObject :: Parser JSON,"parseObject :: Parser JSON
parseObject = do
  char '{'
  xs <- sepBy (ws *> parseEntry <* ws) (char ',')
  char '}'
  return $ Object xs
parseEntry :: Parser (String, JSON)
parseEntry = do
  key <- literalString  -- WARN: not parseString
  char ':'
  val <- jsonValue
  return (key,  val)
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
jsonValue :: Parser JSON,"jsonValue :: Parser JSON
jsonValue =
      parseBool
  <|> parseNull
  <|> parseString
  <|> parseNumber
  <|> parseArray
  <|> parseObject
",/Users/mbp/workspace/sandbox/compiler/json/json.hs
-->,"### 委譲 子供 => 親
```
# 移譲することで、継承せずに親のメソッドを利用できる
class Node(object):
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent  # Noneの場合は、root
    def handle(self, item):
        if self.check(item):
           # do handle in this class
        elif self.parent:
           # Can not handle item so pass it to parent
           self.parent.handle(item)
```
",/Users/mbp/workspace/sandbox/design-pattern/chain_of_responsibility/chain_of_responsibility.md,,
-->,"## Composite Patternとの違い
親=>子と進む(composite)か、子=>親と進む(COR)の違い
",/Users/mbp/workspace/sandbox/design-pattern/chain_of_responsibility/chain_of_responsibility.md
class Logger(object):,"class Logger(object):
    def log(self, msg, level):   # request method
        if level <= self.level:  # Responsibility
            self.message(msg)
        elif self.next:
            self.next.log(msg, level)  # Chain
        else:
            print(""No Logger"")
",/Users/mbp/workspace/sandbox/design-pattern/chain_of_responsibility/log.py
interface EntryInterface ,"interface EntryInterface {
    public String name = """";
    public void remove();
}
class Directory implements EntryInterface {
    public String name;
    Directory(String name) { this.name = name; }
    ArrayList<EntryInterface> entries = new ArrayList<>();
    public void add(EntryInterface e) { entries.add(e); }
    public void remove() {
        for (EntryInterface e: entries) { e.remove(); }
        System.out.printf(""Remove a %s directory\n"", name);
    }
}
class File implements EntryInterface {
    public String name;
    File(String name) { this.name = name; }
    public void remove() { System.out.printf(""Remove a %s file\n"", name); }  // Leafなので探査終了
    public static void main (String[] args) {
        Directory root = new Directory(""root"");
        for (int i: Arrays.asList(1,2,3,4,5))
            root.add(new File(String.format(""text%d.txt"", i)));
        Directory sub = new Directory(""sub dir"");
        for (int i: Arrays.asList(1,2,3,4,5))
            sub.add(new File(String.format(""music%d.mp3"", i)));
        root.add(sub);
        System.out.println(""Call a remove method of a root directory..."");
        root.remove();
    }
}
",/Users/mbp/workspace/sandbox/design-pattern/composite/File.java
-->,"### 参照方向 子供 => 親
```
# 親の参照しかないときは、rootには行き着くが、他の子供へは行けない
class Node(object):
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent  # Noneの場合は、root
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 => 親 list
```
data[child] = parent
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 <= 親
```
# 子供をもつときは、rootから再帰的に木構造を辿れる
class Node(object):
    def __init__(self, value):
        self.value = value
        self.children = []
    def append(self, value):
        self.children.append(Node(value))
    def iter(self):  # 木構造を再帰的に辿る(composite's operation method)
        for child in self.children:
            child.iter()
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 <=> 親
```
class Node(object):
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent
        self.children = []
    def append(self, value):
        self.children.append(Node(value, parent=self))
```
",/Users/mbp/workspace/sandbox/design-pattern/composite/composite.md,,
-->,"### 参照方向 子供 => 親
```
class Root(object):
    def method(self): pass
class Node(object):
    def __init__(self, parent):
        self.parent = parent
    def method(self):
        self.parent.method()
```
",/Users/mbp/workspace/sandbox/design-pattern/decorator/decorator.md,,
-->,"## Composite Patternとの違い
Nodeを別々と見る(composite)か、全てのNodeを同一視する(decorator)かの違い
",/Users/mbp/workspace/sandbox/design-pattern/decorator/decorator.md
class Human(object):  # concreat component,"class Human(object):  # concreat component
    def __init__(self, name):
        self.name = name
    def dressup(self):  # operation
        return self.name
class Cloth(object):  # concreat decorator
    def __init__(self, human):
        self._human = human
    def dressup(self):
        return self._human.dressup() + "" +cloth""
class Shoe(object):
    def __init__(self, human):
        self._human = human
    def dressup(self):
        return self._human.dressup() + "" +shoe""
human = Cloth(Cloth(Shoe(Human(""Bob""))))  # 重ね着可能
print(human.dressup())
",/Users/mbp/workspace/sandbox/design-pattern/decorator/human.py
-->,"### A <>-- B
`A <>-- B`とは、AがBを所有している(one or many).
このことをコードで表すと、下記のようになる.
```
class A:
   def __init__(self, B):
      self.B = B
```
",/Users/mbp/workspace/sandbox/design-pattern/index.md,,
-->,"## Patternごと違い
- データ構造(1:N, N:N, 1:1(委譲))
- 共通インターフェイスを持つ
- 記述はcaller or callee側?(interfaceと実装の区別)
- 分岐if(classで代用)
- Node, Leaf, Rootを区別するか?(狭義: wrapしたものを同一視するか?)
",/Users/mbp/workspace/sandbox/design-pattern/index.md
-->,"# Mediator Pattern
**N:Nの関係があるとき、N+1番目を用意してN:1の関係に変更するようなbrokerを用意**
",/Users/mbp/workspace/sandbox/design-pattern/mediator/mediator.md
-->,"### クラス図
```
class Broker: pass  # intermideate table
class Publisher: publish(self, msg)
class Subscriber: handle(self, publisher, msg)
```
",/Users/mbp/workspace/sandbox/design-pattern/mediator/mediator.md,,
class Broker(object):,"class Broker(object):
    def __init__(self):
        self.registry = []
    def publish(self, publisher, msg):
        for (pub, sub) in self.registry:
            if pub is publisher:
                sub.handle(pub, msg)
    def subscribe(self, subscriber, publisher):
        self.registry.append((publisher, subscriber))
class Publisher(object):
    def __init__(self, name, broker):
        self.name = name
        self.broker = broker
    def publish(self, msg):
        self.broker.publish(self, msg)
class Subscriber(object):
    def __init__(self, name, broker):
        self.name = name
        self.broker = broker
    def subscribe(self, publisher):
        self.broker.subscribe(self, publisher)
    def handle(self, publisher, msg):
        print(""%s got %s from %s"" % (self.name, msg, publisher.name))
",/Users/mbp/workspace/sandbox/design-pattern/mediator/pubsub.py
-->,"### クラス図
```
class Parent:
    def __init__(self):
        self.children = []
   def notfiy(self, msg):
       for c in self.children:
           c.nofify(msg)
```
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.md,,
-->,"## pubsub pattern との違い
どちらもN:Nの関係であるが、brokerあり(pubsub)、なし(observer)の違い
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.md
-->,"## composite pattern との違い
再帰的1:N関係かつ(composite)と非再帰的N:N関係(observer)の違い
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.md
class Subject:,"class Subject:
    def __init__(self, name):
        self.name = name
        self._observers = []
    def register(self, *observers):
        for observer in observers:
            self._observers.append(observer)
    def notify(self, *args, **kwargs):
        for o in self._observers:
            o.notify(self, *args, **kwargs)
class Observer:
    def __init__(self, name):
        self.name = name
    def notify(self, observable, *args, **kwargs):
        print(self.name, 'Got', args, kwargs, 'From', observable.name)
",/Users/mbp/workspace/sandbox/design-pattern/observer/observer.py
"func stack_ack(m, n int) int ","func stack_ack(m, n int) int {
	S := []int{}
	for {
		if m == 0 {
			n++  // (elseの戻り値になってる)
			if len(S) == 0 {  // 空なら計算終了
				return n
			} else {
				m = S[len(S)-1]
				S = S[:len(S)-1]
			}
		} else if n == 0 {
			// m -> (m-1), n -> 1
			m--
			n = 1
		} else {
			// (ack m (- n 1))を先に計算する。戻ってきたら、m -> (m-1), n -> (+ n 1)
			S = append(S, m-1)
			n--
		}
	}
}
",/Users/mbp/workspace/sandbox/design-pattern/stack/ack.go
:Q:fibWithQueue,"# Leafの総和がtot
def dfs(n):
    tot = 0
    stack = [n]
    while stack:
        a = stack.pop()
        if a in [0, 1]:
            tot += a
        else:
            stack.append(a - 1)
            stack.append(a - 2)
    return tot
",/Users/mbp/workspace/sandbox/design-pattern/stack/fib.py
"def add(p1, p2):","def add(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return (x1 + x2, y1 + y2)
class Normal(object):
    def move(self, dx, dy):
        return (dx * 1, dy * 1)
class Fast(object):
    def move(self, dx, dy):
        return (dx * 2, dy * 2)
class Slow(object):
    def move(self, dx, dy):
        return (dx * 0.5, dy * 0.5)
class Player(object):
    def __init__(self):
        self.position = (0, 0)
        self.state = Normal()
    def change(self, state):
        self.state = state
    def up(self):
        self.move(1, 0)
    def down(self):
        self.move(-1, 0)
    def left(self):
        self.move(0, 1)
    def right(self):
        self.move(0, -1)
    def move(self, dx, dy):
        self.position = add(self.state.move(dx, dy), self.position)
        print(""(%s, %s)"" % self.position)
",/Users/mbp/workspace/sandbox/design-pattern/state/state.py
interface Acceptor ,"interface Acceptor {
    public void accept (final Visitor v);
}
class A1 implements Acceptor {
    public void accept (Visitor v) {
        v.visit(this);
    }
}
class A2 implements Acceptor {
    public void accept (Visitor v) {
        v.visit(this);
    }
}
class Visitor {
    public void visit (A1 a) {
        System.out.println(""visit A1"");
    }
    public void visit (A2 a) {
        System.out.println(""visit A2"");
    }
}
public class DoubleDispatch {
    public static void main (String[] args) {
        System.out.println(""create visitor"");
        (new Visitor()).visit(new A1());
        (new Visitor()).visit(new A2());
        System.out.println(""create acceptor"");
        (new A1()).accept(new Visitor());
        (new A2()).accept(new Visitor());
        System.out.println(""for each acceptor"");
        // visitorパターンを使うとvisitの呼び出しを動的に決定できる
        for (Acceptor a: new Acceptor[] {new A1(), new A2(), new A1()}){
            a.accept(new Visitor());
            // (new Visitor()).visit(a); // compile error!
            }
    }
}
",/Users/mbp/workspace/sandbox/design-pattern/visitor/DoubleDispatch.java
class Visitor(object):,"class Visitor(object):
    def visit(self, acceptor):
        # return getattr(self, ""visit_%s"" % acceptor.__class__.__name__)(acceptor)
        return acceptor.accept(self)  # 型あり言語の場合、acceptを全て記述する必要あり(for compiler)
    def visit_List(self, acceptor):
        assert len(acceptor.children) >= 2
        op = self.visit(acceptor.children[0])
        args = [self.visit(n) for n in acceptor.children[1:]]
        return op(args)
    def visit_Op(self, acceptor):
        return acceptor.op
    def visit_Atom(self, acceptor):
        return acceptor.value
class Acceptor(object):
    pass
class List(Acceptor):
    def __init__(self, children):
        assert isinstance(children, list)
        self.children = children
    def accept(self, visitor):
        return visitor.visit_List(self)
class Op(Acceptor):
    def __init__(self, op):
        self.op = op  # op takes only a list as an argument
    def accept(self, visitor):
        return visitor.visit_Op(self)
class Atom(Acceptor):
    def __init__(self, value):
        self.value = value
    def accept(self, visitor):
        return visitor.visit_Atom(self)
",/Users/mbp/workspace/sandbox/design-pattern/visitor/double_dispath.py
-->,"## Interface
### visit
```
# 木構造をAccptorで作成
def Acceptor(object):  # 各Node
    def accept(self, visitor):
        return visitor.visit_XXX(self)
# 各Nodeに訪れた場合の動作をそれぞれ定義
def Visitor(object):
    def visit(self, acceptor):
        return acceptor.accept(self)
    def visit_XXX(self, acceptor):
        pass
```
",/Users/mbp/workspace/sandbox/design-pattern/visitor/visitor.md,,
newtype ParsecT s u m a,"newtype ParsecT s u m a
    = ParsecT {unParser :: forall b .
                 State s u
              -> (a -> State s u -> ParseError -> m b) -- consumed ok
              -> (ParseError -> m b)                   -- consumed err
              -> (a -> State s u -> ParseError -> m b) -- empty ok
              -> (ParseError -> m b)                   -- empty err
              -> m b
             }
#if MIN_VERSION_base(4,7,0)
     deriving ( Typeable )
     -- GHC 7.6 doesn't like deriving instances of Typeabl1 for types with
     -- non-* type-arguments.
#endif
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
parserReturn :: a -> ParsecT s u m a,"parserReturn :: a -> ParsecT s u m a
parserReturn x
    = ParsecT $ \s _ _ eok _ ->
      eok x s (unknownError s)
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
parserBind :: ParsecT s u m a -> (a -> ParsecT s u m b) -> ParsecT s u m b,"parserBind :: ParsecT s u m a -> (a -> ParsecT s u m b) -> ParsecT s u m b
{-# INLINE parserBind #-}
parserBind m k
  = ParsecT $ \s cok cerr eok eerr ->
    let
        -- consumed-okay case for m
        mcok x s err =
            let
                 -- if (k x) consumes, those go straigt up
                 pcok = cok
                 pcerr = cerr
                 -- if (k x) doesn't consume input, but is okay,
                 -- we still return in the consumed continuation
                 peok x s err' = cok x s (mergeError err err')
                 -- if (k x) doesn't consume input, but errors,
                 -- we return the error in the 'consumed-error'
                 -- continuation
                 peerr err' = cerr (mergeError err err')
            in  unParser (k x) s pcok pcerr peok peerr                      
        -- empty-ok case for m
        meok x s err =
            let
                -- in these cases, (k x) can return as empty
                pcok = cok
                peok x s err' = eok x s (mergeError err err')
                pcerr = cerr
                peerr err' = eerr (mergeError err err') 
            in  unParser (k x) s pcok pcerr peok peerr
        -- consumed-error case for m
        mcerr = cerr
        -- empty-error case for m
        meerr = eerr
    in unParser m s mcok mcerr meok meerr
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
parserPlus :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a,"parserPlus :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
{-# INLINE parserPlus #-}
parserPlus m n
    = ParsecT $ \s cok cerr eok eerr ->
      let
          meerr err =
              let
                  neok y s' err' = eok y s' (mergeError err err')
                  neerr err' = eerr $ mergeError err err'
              in unParser n s cok cerr neok neerr
      in unParser m s cok cerr eok meerr
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
try :: ParsecT s u m a -> ParsecT s u m a,"try :: ParsecT s u m a -> ParsecT s u m a
try p =
    ParsecT $ \s cok _ eok eerr ->
    unParser p s cok eerr eok eerr
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
tokenPrimEx showToken nextpos (Just nextState) test,"tokenPrimEx showToken nextpos (Just nextState) test
  = ParsecT $ \(State input pos user) cok cerr eok eerr -> do
      r <- uncons input
      case r of
        Nothing -> eerr $ unexpectError """" pos
        Just (c,cs)
         -> case test c of
              Just x -> let newpos = nextpos pos c cs
                            newUser = nextState pos c cs user
                            newstate = State cs newpos newUser
                        in seq newpos $ seq newstate $
                           cok x newstate $ newErrorUnknown newpos
              Nothing -> eerr $ unexpectError (showToken c) pos
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
manyAccum :: (a -> [a] -> [a]) -> ParsecT s u m a -> ParsecT s u m [a],"manyAccum :: (a -> [a] -> [a]) -> ParsecT s u m a -> ParsecT s u m [a]
manyAccum acc p =
    ParsecT $ \s cok cerr eok eerr ->
    let walk xs x s' err =
            unParser p s'
              (seq xs $ walk $ acc x xs)  -- consumed-ok
              cerr                        -- consumed-err
              manyErr                     -- empty-ok
              (\e -> cok (acc x xs) s' e) -- empty-err
    in unParser p s (walk []) cerr manyErr (\e -> eok [] s e)
",/Users/mbp/workspace/sandbox/dev/parsec/Text/Parsec/Prim.hs
:Q:monotonicClockとは?,"不特定のエポックからの単調増加な時刻(時刻が巻き戻ったり settimeofday などで調整されたりしない)
",/Users/mbp/workspace/sandbox/lang/go/README.md
:Q:byteの文字列を文字リストへ変換,"    if ! bytes.Equal([]byte(""abc""), []byte{'a', 'b', 'c'}) {
        // stringtoslicebyteによりコピーが走る
        t.Errorf(""abc == 'a' 'b' 'c'"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/byte_test.go
:Q:Goの参照型,"// *int, []int, []*int, *TypeStruct, []TypeStruct, []*TypeStruct
// []*int{&1}は不可. []*S{{A: 1}}は可.
",/Users/mbp/workspace/sandbox/lang/go/basic/deepcopy_test.go
:Q:コピーが走る例,"// 代入文の右辺が実体の時`b := a`は、コピーが走る
// a := (Struct)b // 構造体の値渡し代入
// a := ([]Struct)b[0]  // スライス構造体のindexアクセスによる代入
",/Users/mbp/workspace/sandbox/lang/go/basic/deepcopy_test.go
:Q:makeを使う場合の条件,"- Create a channel
- Create a map with space preallocated
- Create a slice with space preallocated or with len != cap
*/
",/Users/mbp/workspace/sandbox/lang/go/basic/make_test.go
:Q:defar機能,"// defer ステートメントは、 defer へ渡した関数の実行を、呼び出し元の関数の終わり(returnする)まで遅延させるものです。
// defer へ渡した関数の引数は、すぐに評価されますが、その関数自体は呼び出し元の関数がreturnするまで実行されません
// defer へ渡した関数が複数ある場合、その呼び出しはスタック( stack )されます。 呼び出し元の関数がreturnするとき、 defer へ渡した関数は LIFO(last-in-first-out) の順番で実行されます。
",/Users/mbp/workspace/sandbox/lang/go/basic/op_test.go
:Q:reflectが必要になるところ,"// 実行時に値が決定するもの: fmt, template
",/Users/mbp/workspace/sandbox/lang/go/basic/reflect_test.go
:Q:appendの注意点,"- 毎回コピーが走る(dst側については)
- capがオーバーしたらreallocが走り、全要素コピー
- 特にmakeの初期化した場合のサイズは0でない
https://blog.golang.org/slices
*/
func TestAppend1(t *testing.T) {
    s0 := make([]int, 5)
    // 最大capcityの最後にappend
    // そのためcapオーバーする
    s1 := append(s0, 1)
    if len(s1) != 6 && s1[2] == 0 {
        t.Error(""5+1=6"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/slice_test.go
:Q:newの使い道,"func TestNew(t *testing.T) {
    // it makes easier is creating pointers to non-composite types
    f1 := func () *int {
        return new(int)
    }
    f2 := func () *int {
        var i int
        return &i
    }
    if *f1() != 0 {
        t.Error(""参照を"")
    }
    if *f2() != 0 {
        t.Error(""参照を"")
    }
}
",/Users/mbp/workspace/sandbox/lang/go/basic/slice_test.go
:Q:[]byteとstringの違い,"1. slice や要素の address をとれない
2. 要素単位の書き換えができない, immutable: x[i] = 1 とか NG.
3. ""A"" == ""B""可能. []byte{'a'} == []byte{'b'}不可(slice can only be compared to nil)
*/
",/Users/mbp/workspace/sandbox/lang/go/basic/string_test.go
:Q:[]byte型の別称,"    // byteはuint8のエイリアス
    if ""abc"" != string([]byte{'a', 'b', 'c'}) {
        t.Errorf(""abc"")
    }
    if ""abc"" != string([]uint8{'a', 'b', 'c'}) {
        t.Errorf(""abc"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/unicode_test.go
:Q:unicodeの１文字単位に用いられる型,"    // runeはint32のエイリアス
    if ""あいう"" != string([]rune{'あ', 'い', 'う'}) {
        t.Errorf(""あいう"")
    }
    if ""あいう"" != string([]int32{'あ', 'い', 'う'}) {
        t.Errorf(""あいう"")
    }
    
    // MEMO: :Q:stringのindexアクセス""あ""
    if ! (""あ""[0] == 0xe3 && ""あ""[1] == 0x81 && ""あ""[2] == 0x82){
        t.Errorf(""\xe3\x81\x82"")
    }
",/Users/mbp/workspace/sandbox/lang/go/basic/unicode_test.go
":Q:stringのrangeアクセス""あいう""","    for i, v := range ""あいう"" {
        // byteの長さではなく、文字数回ループする
        switch {
        case i == 0 && v == 12354:
        case i == 3 && v == 12356:
        case i == 6 && v == 'う':
        default:
            t.Errorf(""%d %c"", i, v)
        }
    }
}
",/Users/mbp/workspace/sandbox/lang/go/basic/unicode_test.go
:Q:byteの文字列を文字リストへ変換,"    s := ""hello world""
    b := *(*[]byte)(unsafe.Pointer(&s))
    // b[0] = 'a'  // 代入は失敗する
    print(b)
}
",/Users/mbp/workspace/sandbox/lang/go/basic/unsafe_test.go
:Q:標準出力とエラーを交換する,"echo hoge 3>&1 1>&2 2>&3 | less  # 標準エラーに出力されるので何も表示されない
# &はポインタみたいなものか.
",/Users/mbp/workspace/sandbox/lang/sh/run.sh
:Q:標準出力を閉じる,"ls >&-
",/Users/mbp/workspace/sandbox/lang/sh/run.sh
""", 2)","    if len(ss) == 1 {
        
    } else {
        m.Q = ss[1]
    }
	return m
}
",/Users/mbp/workspace/sandbox/main.go
""") ","			r := ParseMemo(t)
			first := """"
			second := """"
			if scanner.Scan() {
				first = scanner.Text()
			}
			if r.Q == """" {
				r.Q = first
			}
            second = first + ""\n""
			for scanner.Scan() {
				t2 := scanner.Text()
				if t2 == """" {
					break
				}
				second += t2 + ""\n""
			}	
			r.A = second
			r.path = path
			c.WriteRecord(r)
		}
	}
}
",/Users/mbp/workspace/sandbox/main.go
:Q:クラスタの分け方,"trains = np.array([[-1, -1], [1, 1]])  # len(X) == len(Y)
labels = np.array([1, 2])
clf = GaussianNB()
clf.fit(trains, labels)  # predictよりも時間がかかる
preds = clf.predict(tests)
# predとtestの一致した個数/test数
accuracy = (preds == expecteds) / len(preds)
print(accuracy)
",/Users/mbp/workspace/sandbox/math/src/GuassianNB.py
-->,"### 1bitとは
0と1ので表せる単位
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 1byteとは何bit?
1byte = 8bit
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 8bytesとは何bit?
8bytes = 64bit
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 32bitsとは何byte?
32bits = 4bytes
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 1byteで表せる10進数の範囲
0 ~ 2^8 - 1 (0b0000 0000 ~ 0b1111 1111)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 1byteで表せる16進数の範囲
0x00 ~ 0xFF (Fは2^4なので0bF = 0b1111)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### ~0とは
-1
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"### 2 ^ j (0<=j<=2)
- 1 << 0 == 0b1
- 1 << 1 == 0b10
- 1 << 2 == 0b100
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 0b10101の2^4倍
10進数の場合は、10^nの倍数だとイメージがつきやすい`12345*10^4 = 123450000`
同じように、2進数でも2^4を掛ければ、`0b10101*2^4 = 0b101010000`となる
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## a1bのマイナスの表現
`NUM = a1b` とおく. ただしbは全て0とするので、1が一番最後の桁となる.
2の補数表現を使うと、`-NUM = ~(a1b) + 1` とおける。
チルダ演算子は、それぞれのbitを反転させるだけなので、`-NUM = ~a0~b + 1`
bは全て0なので反転させると全て1
`-NUM = ~a0(111...1) + 1 = ~a1(000...0) = ~a1b`
よって、`-NUM = ~a1b`
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## x & -x
NUM & ~NUM = a1b & ~a1b = 1b = 1000... (xの最も右側に存在する1)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## perl -E '$i=0b101; for(1..3){$i+=$i&-$i; say sprintf ""%b"", $i;}'
101 => 110 => 1000 => 10000
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## perl -E '$i=0b10110; for(1..3){$i-=$i&-$i; say sprintf ""%b"", $i;}'
10110 => 10100 => 10000 => 0
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## perl -E '$i=0b10110;for(1..3){$i=$i&($i-1); say sprintf ""%b"", $i;}'
0b010110 => 0b010100 => 0b010000 => 0b000000
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## all, any, not all, not anyがTrueになる条件
- all: 全てTrue
- any: 少なくとも一つTrue
- not all: 少なくとも一つFalse
- not any: 全てFalse
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## check whether a number is even or odd
`x & 1` (0なら偶数)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## Check power of 2
`x & (x-1)` (0なら2の累乗)
2の累乗数は、10...00で表せる。そこから1引いた数は11..11となる。そのため２つの&は常に0
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## What's Two Compliment?
x => ~x + 1 (x + (~x + 1) = 0)
2の補数は、符号を入れ替えるだけ
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## What's One Compliment?
x => ~x (x + ~x = -1)
すべてのbitを反転したもの
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 1の2の補数は?
-1 = (0xFFFF)
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 13の2の補数は?
`13 = 8 + 4 + 1 = ^3 + ^2 + ^0 = 0b0000 1101` よって
-13 = ~(13) + 1 = 0b0010 + 1 = 0b1111 0011
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"## 2の補数をその場で思い出すには?
1 = 0b00000001と-1 = 0b11111111の二つの関係より
2の補数は`NUM = ~NUM + 1`という関係性がすぐ思い出せる。
なお、0の場合も当てはまる0b0000 = (0b1111) + 1
",/Users/mbp/workspace/sandbox/math/tex/bit.md
-->,"# べき乗
Xを集合とする。 Xの部分集合全体を2^xとし、異なるn個の中で構成される全ての組み合わせ
f(0) &=& {$phi}
f(n) &=& ${ {a_n} $cup x $mid x $in f(n-1) $} $cup f(n-1)
",/Users/mbp/workspace/sandbox/math/tex/cases/index.md
-->,"## (e^x)'
e^x
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (x^n)'
nx^(n-1)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (sinx)'
cosx
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (cosx)'
-sinx
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## (logx)'
1/x
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## {f(x)g(x)}'
f(x)'g(x) + f(x)g(x)'
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Gamma関数
F(n) = I[0,inf] t^(n-1)e^(-t) dt
階乗を自然数でない正の実数にまで拡張
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Gamma(n+1)=n!の証明
F(1) = I[0,inf] e^(-t) dt = [-e^(-t)] = 1
F(n+1) = - ([t^(n-1)e^(-t)] - I[0,inf] nt^n e^(-t) dt)
 = 0 + n F(n) = n F(n) = n (n-1) F(n-1) = n! F(1) = n!
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Gamma(1/2)
root(pi)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Beta関数
B(x,y) = I[0,1] t^(x-1) (1-t)^(y-1) dt
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Beta関数(整数)
B(a,b) = (a-1)!(b-1)!/(a+b-1)! = F(a)F(b)/F(a+b)
beta関数はgammna関数で表せる
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Sigmoid関数
f(x) = 1 / (1 + e^(-ax)) (a>0)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## Sigmoid関数が点対称であることを示せ
f(x) + f(-x) = 1より、(0, 1/2)で点対称
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## ガウス積分
I[-inf,inf] e^(-x^2) = root(pi)
I^2 = II e^(-r2) dxdy = I[0,inf]I[0,2pi] e^(-r^2) r dsdr
= piI 2e^(-r^2) r = pi [-e^(-r^2)] = pi(0 - (-e^0)) = pi
よって I^2=pi より、I = root(pi)
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## ヤコビアンによる置換積分の公式
J = d(x,y)/d(u,v) = det [[dx/du, dx/dv],[dy/du, dy/dv]] とし
II f(x,y) dxdy = II g(u,v) |J| dudv
つまり、変数変換すると面積とその領域も変換する必要がある.
要するにヤコビアンは微小面積比のこと
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"## ヤコビアンによる置換積分(-inf<x, y<inf)のrとシータaの領域
(x, y) = (rcosa, rsina) とすると、領域はxyの平面全域 (円状に領域が増加)
よって、0<r<inf, 0<a<2pi
J = det [[cosa, -rsina], [sina, rconsa]] = rcosa^2 + rsina^2 = r 
",/Users/mbp/workspace/sandbox/math/tex/func.md
-->,"# 固有値
**n次正方行列Aの固有値aは、x != 0に対して、Ax=axを満たすxが存在するときのaとする。またxを固有ベクトルと呼ぶ**
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/eigenvalue.md
-->,"## 固有空間
```math
aがAの固有値 $Leftrightarrow det(A-aE)=0
```
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/eigenvalue.md,math,
-->,"## 対角化の性質
- Aが対角化可能 <=> n個の1次独立な固有ベクトルをもつ
- n個の異なる固有値をもつ => Aは対角化可能
- 行列AとBが対角化可能 <=> AB=BA
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/eigenvalue.md
-->,"## 群の定義
- (a X b) X c = a X (b X c) (結合法則)
- a X e = e X a = a (単位元の存在)
- a X x = x X a = e (逆元xの存在)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 可換群(アーベル群)
群の性質に加えて可換も成立. a X b = b X a
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 写像
集合AからBへの写像f: A -> B とは、$a \in A$ と $f(a) \in B$ 対応させるもの
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 単射
fが単射とは、 $a \ne b => f(a) \ne f(b)$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 全射
fが全射とは  $\forall b \in B, \exists a \in A$ について $f(a) = b$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 全単射の性質
- $全単射 <=> 逆写像f^{-1}が存在$
- $全単射 <=> 単射かつ全射$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## Aが有限個の元からなる集合の時AからAの写像fは、単射であれば、全単射になることを示せ
A = {a1, ... an}とおき、それぞれfで変換すると、A'={f(a1), ... f(an)}なるが、
単射の性質より、全て異なるものに対応する、かつ要素数がnなので、A'=Aが言えるため全射である.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## Aが有限個の元からなる集合の時AからAの写像は、全射であれば、全単射になることを示せ
もし、単射でないならば、a!=b => f(a)=f(b)となるような、aとbが存在することになるが、
これは、n個の要素から、(n-1)いかに対応づけられたことを意味する。
(関数は入力1つに対して出力1つだけ. つまり、減ることはあっても増えることは絶対ないので、)
全射であるので、n個に対応づくことに矛盾する。よって単射である。
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## (全)単射の関数の例
- 全単射 => f(x) = ax + b
- 単射   => f(x) = e^x
- 全射   => f(x) = x^2 (ただしf(x)>=0)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 行列の積
$l \times m$ 行列Aと $m \times n$ 行列Bの積は、$l $times n$ 行列AB となり、
$AB_{ij} = \sum_{k=1}^m a_{ik} b_{kj}$ と定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### A^{-k}= (A^k)^{-1} = (A^{-1})^k
(AA...A)(A^{-1}...A^{-1})=E
A^k(A^{-1})^k=E より
(A^k)^{-1} = (A^{-1})^k
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 対角行列の逆行列
diag (a1, ..., an) diag (1/a1, ..., 1/an) = E より明らか
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### (AB)C = A(BC) (結合法則) の証明
$ab_{ij}  = \sum_{p=1}^m a_{ip} b_{pj}$ より、j -> qと置き換えて
$(ab)c_{ij} = \sum_{q=1}^n ab_{iq} c_{qj} = \sum_{q=1}^n (\sum_{p=1}^m a_{ip} b_{pq} \c_{qj})$ としcをsumの内側にして、 sumを入れ替える.
$\sum_{p=1}^m a_{ip} (\sum_{q=1}^n  b_{pq} \c_{qj}) $ さらにaはqに無関係なので、２つ目のsumの外側へ.
$= \sum_{p=1}^m a_{ip} bc_{pj} = a(bc)_{ij}$ よって、 $(AB)C = A(BC)$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### A = AE = EA を示せ
$ae_{ij} = \sum_{k=1}^m a_{ik} e_{kj} = a_{i1} e_{1j} + ... + a_{ij} e_{jj} + ... + a_{im} e_{mj}$ より、1つを除いて0になるので、
$ae_{ij} = a_{ij}$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 転置行列
${}^t A = a_{ji}$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 対角行列AのA^k
AA[ij]
 = sum a[ik]a[kj] = a[ii]a[ij] + a[ij]a[jj] = 0 (i!=j)
 = a[ii]a[ii] = a[ii]^2 (i==j)
(a[ii]とa[jj]以外は0)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size xy^t
(n*1)(1*n)なので(n*n)の行列 (xとyは縦ベクトル)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size x^ty
(1*n)(n*1)なので(1*1)の定数
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size xy
(n*1)(n*1)なので未定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size x^ty^t
(1*n)(1*n)なので未定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size x^tE
(1*n)(n*n)なので(1*n)のベクトル
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### size xE
(n*1)(n*n)なので未定義
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### ${}^t (AB) = {}^t B {}^t A$ の証明
$AB_{ij} = \sum_{p=1}^m a_{ip} b_{pj}$ として、ABの転置をとると
${}^t (AB_{ij}) = AB_{ji} = \sum_{p=1}^m a_{jp} b_{pi} = \sum_{p=1}^m b_{pi} a_{jp}$ となるが、
$b_{pi}={}^t b_{ip}, a_{jp} = {}^t a_{pj}$ より
$\sum_{p=1}^m {}^t b_{ip} {}^t a_{pj} = {}^t B {}^t A$ が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 対象行列(symmetric matrix)
${}^t A = A$ を満たす正方行列A
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 交代行列(skew symmetric matrix)
${}^t A = -A$ を満たす正方行列A
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## エルミート行列
$A^{*} = A$ を満たす複素数正方行列A
A^{*}は、Aの転置かつ共役複素数にしたもの
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 正則行列定義
n次正方行列Aに対してXが存在し XA = AX = E を満たせば、XはAの逆行列
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 正則行列と同値(9)
正則行列は正方行列でもある.
また、正則行列は単射の条件を満たせば全射でもある(逆も然り)
- 逆行列 $A^{-1}$ が存在
- det A !=0
- rankA=n
- dim Im A = n (全射)
- dim Ker A = 0 (単射)
- 線形写像 $T_A(x)=Ax$ は全単射
- $\sum_i^n x_i a_i$ が一次独立
- 斎次方程式 $Ax=0$ は自明の解のみ
- Aが固有値0を持たない 
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 逆行列は一意に決まることの証明
Aの逆行列をX, Yとして、 $AY = E, XA = E$ を用いて
$X=XE=X(AY)=(XA)Y=EY=Y$ よって $X=Y$ より一意であることが示せた
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### $(AB)^{-1} = B^{-1} A^{-1}$ を示せ
$E = A A^{-1} = A (B B^{-1}) A^{-1} = (AB)(B^{-1} A^{-1})$
$AX=E$ の形にできれば、Xが逆行列となる。
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 正方行列Aのある列が0ベクトルならば、Aは正則ではない
$XA = (Xa_1, ..., X*0, ..., Xa_n) != E$ よって逆行列は存在しない
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 置換
{1..n}から{1..n}への全単射の集合を $S_n$ とし、その要素を置換と呼ぶ
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 互換
{1..n}のうち2のみを動かし残りは、そのままな置換を互換と呼ぶ
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 置換$s -> s^{-1}$ により与えられる写像Sn->Snは全単射
(意味: ある置換に対して、その逆写像を対応づける関数)
それぞれの置換は{1..n}->{n!通り}に対応づけるが、s1!=s2であれば、s1^{-1}!=s2^{-1}が成立(単射)
またSnの要素sはn!通りあり、単射であるので、要素数が減ることはない。
Sn->Snと同じ集合に対応づけているので、全射も成立する.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### ある置換tについて、s -> st により与えられる写像Sn->Snは全単射
$s1!=s2 => s1t!=s2t$ であるから
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### sgn
$sgn(\sigma) = \prod_{i,j} \frac{\sigma(i) - \sigma(j)}{i-j}$
分母は正にできるので、s(i)>s(j)の転倒数が偶数なら1(+1 or -1のみとる)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### sgn関数の性質
- sgn(e) = 1
- sgn(互換) = -1
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の定義
$|A| = det A = \sum_{s \in S_n} sgn(s) a_{1s(1)} a_{2s(2)} ... a_{ns(n)}$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の多重線形性
- $det (a_1, ..., a_j + a_J, ..., a_n) = det (a_1, ..., a_j, ..., a_n) + det (a_1, ..., a_J, ..., a_n)$
- $det (a_1, ..., ca_j, ..., a_n) = c det (a_1, ..., a_j, ..., a_n)$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 多重線形性の証明
定義より簡単に
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の交代性
det(a_{t(1)}, ... a_{t(n)}) = sgn(t) det(a_1, ... , a_n)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の交代性の証明
集合を全単射した集合の和は順番が変わっただけなので等しいことを利用して、
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### $det AB = det A det B$を示せ
多重線形性より、$det(AB) = \sum b_{i_1,1} ... b_{i_n,n} det (a_{i_1},...a_{i_n})$ と記述できる.
同一の列が存在するときは、det A = 0になるので、その項を除外すると、i1...inが全て異なる項のみ残る.
置換t{1..n}={i(1)..i(n)}を利用して
$$
det(AB) = \sum b_{t(1)1} ... b_{t(n)n} det (a_{t(1)},..., a_{t(n)})
 = \sum sgn(t) b_{t(1)1} ... b_{t(n)n} det (a_1,..., a_n)
 = det B * det A
$$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 0を含む列 or 行が存在するならば|A|=0を示せx
行列式の定義より、 $\sum_{s} \p a_{is(i)}$ 少なくとも1つが0になるので、合計も0となる
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### $det {}_t A = det A$ の証明
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 行列式の多重線形性+交代性から導ける定理
ある列に他の列の定数倍を加えてもよい
$det (a_1, ..., a_i, ..., a_j, ... a_n) = det (a_1, ... a_i + k a_j, ..., a_j, ... a_n$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### あるXについて、AX = Eを満たすならば、Aは正則行列であり、XはAの逆行列である
$det A det X = det AX = det E = 1$ より、$det A != 0$ が言えるので、正則.
逆行列が存在し、$X = A^{-1}$ となるので、XはAの逆行列.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### あるXについて、AX = Eを満たすならば、XA = Eが成立することを示せ
$AX=E => X=A^{-1} => XA = A^{-1}A = E$ よって、 $XA = E$が成立 (Aを右から掛けるとこがミソ)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 第1列に関する|A|の余因子展開
$det A = $sum_{i=1}^n (-1)^{i-1} a_{i1} |i行目以外| = $sum_{i=1} a_{i1} $tilde{a_{i1}}$
$tilde{a_{ij}} = (-1)^{i+j} $Delta_{ij}"" :msg ""行列Aからi行j列を除いた行列を第(i,j)小行列D_{ij}と表す.(i,j)余因子
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"## 逆行列の存在の証明
逆行列は、 $A^{-1} = \frac{1}{|A|} \tilde{A}$ より $det A=0$ でなければ、Aの余因子行列と行列式で表せる.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 余因子行列
$\overline{A} = \overline{a_{ji}}$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
"### matrixとi,jの関係をイメージする","### matrixとi,jの関係をイメージする
- i==jの時は、対角線
- i > j => 左下
- i < j => 右上
iが大きいほど、下側に
jが大きいほど、右側に
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/index.md
-->,"### 一次結合(線形結合)
$\sum k_i a_i$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 一次独立
```math
$sum k_i a_iが一次独立 $leftrightarrow $forall k_i $ne 0 S.T. $sum k_i a_i = 0
一次従属 $leftrightarrow ベクトルを別の基底の線形結合で表現可能
```
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md,math,
-->,"### 基底の定義
e_iがVの基底であるとは、 Vの任意のベクトルがe_iの一次結合として一意に表せる
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
:Q:基底の定義 -->,"\forall y $subseteq V \exists x_i (1 <= i <= n) s.t. y = \sum_{i=1}^n a_i x_i
\sum_{i=1}^n a_i x_i = 0 => a_1 = a_2 = ... = a_n = 0

",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md,math,
-->,"### 基底の性質
- $e_iがVの基底 \rightarrow e_i \in V#
- 基底の個数はdim V個だが、組みは、V上で任意にとることが可能
- n個のベクトルa_iが一次独立 <=> a_iは、n次元ベクトル空間Vの基底
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### dim Vの定義
Vがn個からなる基底をもつとき、nをVの次元と呼び、$dim V = n$と表す
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 次元の公式
n = dim V = dim Ker(T) + dim Im (T)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列P
aとb行(列)を入れ替える
P(a,b)
 = a[ab] = a[ba] = 1
 = a[aa] = a[bb] = 0
 = a[ii] = 1
 = 0 (else)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列P(a,b)の証明
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列Q
k行(列)目をc(!=0)倍する
Q(k;c)
 = a[kk] = c
 = a[ii] = 1 (i!=k)
 = 0 (else)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列Q(k;c)の証明
AB[ij]= sum a[ik]b[kj] = a[ii]b[ij] (a[ii]以外は0)
 = b[ij]  (i!=k)
 = cb[ij] (else)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列R
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 基本行列の性質
- 正則行列
- また逆行列も基本行列
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 左基本変形
**連立方程式を解く手法**
- 行と行を入れ替える
- 行に0でない定数をかける
- 別の行の程数倍を加える
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 斎次方程式
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### (全)単射の場合のAの形状
m*n n*1より、nからm次元への写像
- 全単射<=> 正方行列(m=n)
- 単射  <=> 縦長の長方形(m>n)
- 全射  <=> 横長の長方形(m<n)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 写像とrankAの関係
- 全単射<=> rankA = m = n
- 単射  <=> rankA = n
- 全射  <=> rankA = m
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### (全)単射の場合のAの次元
- 全単射<=> 1to1なので、同じ次数
- 単射  <=> 全ての要素が被らないようにする必要があるので、次数の増える方向
- 全射  <=> 全ての要素に行き着く必要があるので、次数の減る方向
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### n次正方行列AのAx=0の解
- rankA=n => 自明な解(x=0)
- rankA<n => 任意の解 (実質的な式の数よりも未知数が多い)
rankA=ImA=n(全射)=>全単射なので、2通りのみ
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 行列Ax=0の解
- 全単射 <=> n個
- 全射 <=> 任意の解
- 単射 <=> 解なし
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 「Aが正則 <=> Ax = 0の解は自明な解のみ」を証明
(十分)正則なのでA^{-1}が存在し、x=0が解となる。
(必要)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"###  単射 => Ker A={0}
Ax=0とする。一方A0=0でもあるので、
単射よりx=0が唯一の解
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"###  単射 <= Ker A={0}
任意のxとyがAx=Ay を満たすとすると =>
A(x-y)=0 => (仮定より)
(x-y)=0
よって単射の定義が成立
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### Ker(T)の定義
Ker(T)={x in K^m | TA(x)=0} (ただしTA(x)=Ax)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 表現行列
$A' = Q^{-1}AP$
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 一次変換の定義
線形写像T:V->V'において、V=V'の場合、Tを一次変換と呼ぶ.
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"### 線形写像におけるrank Tの定義
線形写像T:V->V'に対し、rank T := dim (Im (T))
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/matrix.md
-->,"## 正則<=>一次独立
正則ならば `Ax=0` において、xは自明な解0しかもたない。
`Ax = (a1, a2, ..., an)x = (x1 a1, x2 a2, ..., xn an) = 0`
よって上記式が成立するのは、x_i=0の時のみなので
a_iは一次独立と言える
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/product.md
-->,"## det Aの解
Ax=axにおいて、固有ベクトルを持つ場合、
定義よりx!=0が条件である. そのため
(A-aE)x=0よりdet(A-aE)=0が条件となる
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/product.md
-->,"# 内積
VをR上のベクトル空間とし、Vの任意のベクトルa,bについて、実数(a,b)が定義されるとき、(,)をV上の内積という
(a,b) = (b,a) (対称性)
(a_1+a_2,b) = (a_1,b)+(a_2,b) (線形性(和))
(la,b) = l(a,b) (線形性(定数倍))
(a,a) $ge 0 and (a,a)=0 $Rightarrow a=0 (正値性)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/product.md
-->,"## AとBが正則ならばABも正則
$E = (AB)B^{-1}A^{-1}$より、逆行列$B^{-1}A^{-1}$が存在するので、正則
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/prove/regular.md
-->,"## Aが正則ならばA^2も正則
E = (AA)A^{-1}A{-1}より正則
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/prove/regular.md
-->,"# ベクトル空間
$forall x, y $in V S.T. x + y $in V (+について可換群)
$forall x $in V, $forall l $in K S.T. l x $in V (2種分配法則, 結合法則, 1の存在)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md
-->,"## 線形写像
V, V'をK上のベクトル空間とし、写像T:V->V'が以下を満たすときTを線形写像と呼ぶ
T(x+y) = T(x) + T(y) (x, y $in V)
T(lx) = lT(x) (x $in V, l $in K)
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md
:Q:線形写像Tの性質 -->,"T(0) = 0 (l=0のとき必ず成立)
Tが全単射 <=> V $cong V' (ただし、VとV'は同型)
Tが全単射 <=> dim V = dim V'
Tが単射 $Leftrightarrow T(x)=0 $rightarrow x=0

",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md,math,
:Q:全単射と同値 -->,"Tが全単射 <=> V $cong V' (VとV'は同型)
Tが全単射 <=> dim V = dim V'

",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md,math,
-->,"## 部分空間
```math
W $subset V, $forall x,y $in W, $forall m,n $in K S.T. m x + n y $in W
```
",/Users/mbp/workspace/sandbox/math/tex/liner-algebra/vector.md,math,
-->,"## 事象AとBが起こる確率
P(A) + P(B)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## 事象AとB同時に確率
P(A) * P(B)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## 独立の定義
P(A, B) = P(A) * P(B)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## ベイズの定理
P(B|A) = P(A|B)P(B)/P(A)
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## ２事象のみのベイズ
B=全体-Aの時
P(E) = P(A)P(E|A) * P(B)P(E|B) が成立するため、
P(E|A) = \frac{P(A|E)P(E)}{P(E)}
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"### 陽性の場合に、癌である確率(癌患者とそれ以外の場合における陽性の確率を既知トスる)
癌患者に対して陽性である確率P(p|c)
癌患者以外に対して陽性である確率P(p|-c)
$P(c|p) = P(c, p) / (P(p|c) + P(p|-c))$
",/Users/mbp/workspace/sandbox/math/tex/probability/bayes.md
-->,"## Monty Hall Problemを条件つき確率で表せ
X={A,B,C}  # 正解の扉
Y={A,B,C}  # 挑戦者が選ぶ扉
Z={A,B,C}  # 司会者が選ぶ扉
P(X=C |Y=C, Z=B)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## Monty Hall Problem (三つの扉に一つだけヤギがいる状態で、一つ挑戦者は選び司会者は正解でない方の扉を開ける。さて選び直すべきか？)
ヤギがどの扉にいるか3通りある。それぞれにつき、挑戦者が扉を選ぶ場合が3通りある。同様に確かとみなせるので、世界を9等分できる。
この条件(GIVEN)のもと司会者が不正解の扉を選択するが、(A)挑戦者が正解を選んだ場合(3/9)は、司会者は外れの扉を2通りで選べる。
既に9等分された世界から移るので、1/18ずつの世界となる。一方で(B)挑戦者が不正解を選んだ場合(6/9)は、司会者は1通りの外れの扉しか選べないので、
世界のサイズは9等分されたままの状態になる。よって選び直さない場合は、1/3で正解となる。(司会者関係ない)。
選び直す場合は、(A)の続きで1/18ずつの世界では、残りの扉を1通りで選び直すので、どちらも外れることになる。
(B)の場合は、残っている正解の扉を1通りで選び直すので世界のサイズは変わらず1/9のままになり、2/3で正解となる。
(分岐が発生すると今いる世界を小さくする必要がある。分割のサイズは確率で決める。)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# (Ω, F , P) の意味
- 大文字オメガ(標本空間)
- 小文字オメガ(標本) (=それぞれの場合. 人間は知覚できない世界の1つ. ROOTから分岐した世界のノード)
- 標本空間の部分集合AをP(A)で表す
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# 確率変数(random variable)とは
- 標本aを引数に取る関数Xのこと. X(a)
- 人間にはaを知覚できないのでX自体が変数となる
- X={A,B,C}とは確率変数Xのとる値を集合で表記
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# 確率分布(random variable)とは
確率変数Xが取るそれぞれの値に対する確率
標本を特定する必要なし
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"# P(X=k)の意味
X(標本) = kとなるような標本の面積の割合
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## P(a <= X < b) の意味
a <= X(標本) < bとなるような標本の集合をAとしたときのP(A) 
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## I.I.D (独立同一分布)
- independent and identically distributed
- ここの周辺分布がどれも同じ
- 各々独立
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 期待値の定義
E[g(X)] = sum g(xi) P(X = xi)
特に、g(x) = xの時
E[X] = sum xi P(X = xi)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 分散の定義
V[X]=E[(X-E[X])^2]=E[(X-u)^2] (ただしu = E[X])
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## P(X=a)の言い換え
- sum{y} P(X=a|Y=y) P(Y=y)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## sum P(X=x)の言い換え
- sum{y} P(X=x, Y=y)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X]の言い換え
- E[E[Y|X]]
- sum{a}E[X|Y=a] P(Y=a)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 条件つき期待値の定義
E[g(Y)|X=a] = sum{b}g(b)P(Y=b|X=a)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 条件つき分散の定義
V[Y|X=a]=E[(Y-u(a))^2|X=a]
ただし u(a)=E[Y|X=a]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[{Y-g(X)}^2]が最小となるgは?
g(a)=E[Y|X=a]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 基本性質
- sum P(X=x) = 1
- P(X=x) >= 0
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X+c] = E[X]+c
E[X+c] = sum (x+c)P(X=x) = sum xP(X=x) + sum cP(X=x) = E[x] + c
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[cX] = cE[X]
E[X+c] = sum (xc)P(X=x) = c sum xP(X=x) = cE[x]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X+Y] = E[X] + E[Y]
E[X+Y] = sum{x,y}(x + y)P(X=x, Y=y) = sum xP(X=x,Y=y) + sum yP(X=x,Y=y)
第一項 = sum{x}sum{y}xP(X=x,Y=y) = sum{x}xP(X=x) (第二項も同様)
E[X+Y] = sum{x}xP(X=x) + sum{y}yP(Y=y) = E[X]+E[Y]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[XY] = E[X]E[Y]
XとYが独立であるならば, P(xy)=P(x)P(y)なので
E[X+Y] = sum{x,y}(xy)P(X=x, Y=y) = sum{x}sum{y}(xy)P(X=x)P(Y=y) = sum{x}xP(X=x)sum{y}P(Y=y) E[X]E[Y]
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## V[X+c] = V[X]
V[X+c]=V[Y]=E[(Y-v)^2]=E[{(X+c)-(u+c)}^2]=E[(X-u)^2]=V[X]
ただし, v=E[Y]=E[X+c]=E[X]+c=u+c
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## V[cX] = (c^2)V[X]
V[cX]=E[(cX-v)^2]=E[c^2(X-u)^2]=(c^2)E[(X-u)^2]=(c^2)V[X]
v=E[cX]=cE[X]=cu
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 確率変数の正規化
W=(X-u)/s
E[W]=(1/s)(E[X]-u)=0
V[W]=(1/s^2)(V[X])=1
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## V[X+Y] = V[X]+V[Y]
V[X+Y] = V[X]+V[Y]+2E[(X-u)(Y-v)]
XとYが独立であるならば, 
E[(X-u)(Y-v)]=E[X-u]E[Y-v]=(u-u)(v-v)=0
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## E[X^2] = V[X] + E[X]^2 = s^2 + u^2
V[X] = E[(X-u)^2] = E[X^2+u^2-2uX] = E[X^2]+E[u^2]-2Eu[X] = E[X^2]+u^2-2u^2= E[X^2]-u^2
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## Bn(n,p)の分散
s^2=np(1-p)
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## P(X=-1)=1/3, P(X=1)=2/3, V[X]?
1-(1/3)^2=8/9
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## I.I.Dの平均値の期待値
Z = sum Xi / n とすると
E[Z] = E[sum Xi / n] = (sum E[Xi]) / n 
iidなので、それぞれの期待値をuとおけて
E[Z] = nu / n = u
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## I.I.Dの平均値の分散
Z = sum Xi / n とすると
V[Z] = V[sum Xi / n] = (sum V[Xi]) / n^2
iidなので、それぞれの分散をs^2とおけて
V[Z] = ns / n^2 = s^2/n
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 大数の法則
iidな確率変数XiについてZ=sum Xi/nとすると
E[Z]=u, V[Z]=s^2/nとおけるので、n=>infとするとV[Z]=0となる
これは試行回数nを無限に増やせば、バラつきがなくなることを意味する
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## nonparametric
分布の具体的な関数を仮定しない
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## parametric
分布の具体的な関数を仮定する(正規分布)
ただし期待値や分散は未知
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## MCMC
解析的に解けないからシミュレーションで事後分布を求めることになった。その方法がMCMCなんだ
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## Bin(m|N,u) の読み方
試行回数Nと起きる確率uが与えられた場合(既知)の、確率変数mの確率分布
",/Users/mbp/workspace/sandbox/math/tex/probability/probability.md
-->,"## 極大値(非連続)
x[i-1] < x[i] > x[i+1] について i \in \[1, n-1\]
",/Users/mbp/workspace/sandbox/math/tex/seq/1.md
-->,"## y = \sum_{i=0}^{n} a_i x^i
$$
S_n &=& a_0 x^n + a_1 x^{n-1} + ... + a_{n-1} x + a_n
    &=& $sum_{i=0}^{n} a_i x^{n-i}
    &=& $sum_{i=0}^{n-1} a_i x^{n-i} + a_n
    &=& x $sum_{i=0}^{n-1} a_i x^{(n-1)-i} + a_n
    &=& x S_{n-1} + a_n
$$
ようは、a_n除外して、xで括ったらS_{n-1}の項が出現する
",/Users/mbp/workspace/sandbox/math/tex/seq/1.md
-->,"## one byte offset
last - first = n - 1
$\sum_{i=1}^{n} a_i = $sum_{i=0}^{n-1} a_{i+1} = $sum_{i=2}^{n+1} a_{i-1}$
",/Users/mbp/workspace/sandbox/math/tex/seq/1.md
:Q:分割数 -->,"  dp(1, _) = 1
  dp(i, n) = dp(i-1, n) + dp(i, n-i)

",/Users/mbp/workspace/sandbox/math/tex/seq/seq.md,math,
-->,"## 配列A[x,y]範囲に1の要素がいくつあるか?
```math
S_n      = \sum_{i=0}^n A_i
A[0,y]   = S[y]
A[0,x-1] = S[x-1]
A[x,y]   = a_x + a_{x+1} + ... + a_y = A[0,y] - A[0,x-1] = S[y] - S[x-1] (x > 0)
         = a_0 (x = 0)
```
",/Users/mbp/workspace/sandbox/math/tex/seq/seq.md,math,
-->,"## パラメータのチューニング方法
小さいtrainデータでパラメタを最適化してから、全てのデータを適用させる
",/Users/mbp/workspace/sandbox/math/tex/svm.md
-->,"## Entropyの定義
E = -sum (pi)log2(pi)
",/Users/mbp/workspace/sandbox/math/tex/svm.md
-->,"## Entropy
0
",/Users/mbp/workspace/sandbox/math/tex/svm.md
-->,"## 互いに素とは
`gcd(a, b) = 1`
つまり最大公約数が1
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"## 互いに素の例
- (35, 48)
- (素数, 別の素数)
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"## GCDの性質
- GCD(a, a) = a
- GCD(x, 1) = 1
- GCD(pa, qa) = a (p,qは素数)
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"## totient
Euler's Totient Functionは、1 から n までの整数の中で、n と互いに素な数の個数を表します。
n が素数 p ならば、1からp-1までの全ての数とpは互いに素なので, t(p) = p - 1 が成り立ちます。
t(n)=n * PI (1-1/p) (pはnの素因数)
",/Users/mbp/workspace/sandbox/math/tex/z/gcd.md
-->,"### A <= i <= B に含まれる整数の数
B - A + 1
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### A < i < B に含まれる整数の数
B - A - 1
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### A <= i < B に含まれる整数の数
B - A
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### A < i <= B に含まれる整数の数
B - A
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### #${i| A $leqq i $leqq B, i $bmod K = 0 $}
ある0<=n<A, 0<=n'<Bについて
A = Km + n <= i = K*j <= B = Km' + n' & <=> (Kで割る)
    m + n/K    <= j       <= m' + n'/K < m' + 1 
また次を考慮し `0 $leqq & n/K, n'/K & < 1`、Kの倍数から整数に帰着
m <= j <= m' (n/K = 0)
m <  j <= m' (else)
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### #${i| 3 <= i <= 110, i % 3 = 0 $}
3 = 3 * 1, 110 = 3 * 36 + 2より
1 <= (1, 2, ... 36) <= 36なので、16通り
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### min x >= a/b
- [a/b] & (a % b = 0)
- [a/b] + 1 & (else)
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"### 数列Snを２分割した数列の差の最小値
S_{N0} & = & a_N + a_{N-1} + ... + a_2 + a_1
S_{N1} & = & a_N + a_{N-1} + ... + a_2 - a_1
...
S_{Nx}     & = & a_N + a_{N-1} + ... + a_{x+1} - a_x ... - a_2 - a_1
S_{N(x+1)} & = & a_N + a_{N-1} + ... - a_{x+1} - a_x ... - a_2 - a_1
...
S_{NN}     & = & - a_N - a_{N-1} + ... - a_2 - a_1
よって、２項間の差は以下のとおり
S_{N(x+1)} - S_{Nx} & = & - 2 a_{x+1} 
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"## newton法(簡易証明)
収束しそうな点(初項)を探す必要あり
f(x)の $x_n$ における接戦は次の通り $y = f'(x_n)(x - x_n) + f(x_n)$
この接線は、(x_{n+1}, 0)を通過するので $0 = f'(x_n)(x_{n+1} - x_n) + f(x_n)$
すなわち $x_{n+1} = x_n - f(x_n)/f'(x_n)$ として、
|$frac{x_{n+1} - x_n}{x_n}| < $epsilon を満たすまで繰り返す
",/Users/mbp/workspace/sandbox/math/tex/z/index.md
-->,"## 暗黙のロック
- UPDATEとDELETEは暗黙的にXLOCKが必要
- CREATEする場合にも、挿入される行にXLOCKする必要がある
- unique, foreignのチェックにもロック必要みたい
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## ギャップロックとは?
インデックスとインデックスの間にかけられるロック。
範囲指定での処理 存在しない行への処理
(ex) idとstrがあるだけのシンプルなテーブル。idがPKで1~5までは順番に、その後、10,20と飛んで行が入っている
http://qiita.com/kenjiszk/items/05f7f6e695b93570a9e1
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## SHARE LOCKとは?
- READ => CREATE (間でREADした情報がUPDATE、DELETEされないことを保証したい, 親のテーブル情報)
- insertのロックは、ネクストキーロックではなくインデックスレコードロックである (つまり、ギャップロックが存在しない) 
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>22に変更する処理
1(R) 10 -> 1(U) 11 -> 2(R) 11 -> 2(U) -> 22
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>21に変更する処理
2(R) 10 -> 2(U) 20 -> 1(R) 20 -> 1(U) -> 21
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>20に変更する処理
1(R) 10 -> 2(R) 10 -> 1(U) 11 -> 2(U) -> 20
2(R) 10 -> 1(R) 10 -> 1(U) 11 -> 2(U) -> 20
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"### (+1)と(*2)のプロセスで10=>11に変更する処理
2(R) 10 -> 1(R) 10 -> 2(U) 20 -> 1(U) -> 11
1(R) 10 -> 2(R) 10 -> 2(U) 20 -> 1(U) -> 11
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"# ダーティリードとは?
- ロック中のテーブルを参照すること
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## 楽観的ロック
明示的なロックをかけない
更新したデータを行に書き戻す前に、その行を読み取った後に他の誰かがその行に変更を加えていないか確認する方法
Version パターンと呼ばれる
INSERTによって発生する不整合を防止することはできない
バージョン番号を表すカラムをテーブルに追加
SELECTした時のバージョン番号を記憶しておく
UPDATE時に、
バージョン番号が2で取得した番号と等しいかチェックする(UPDATE ... WHERE ... AND lock_version = 1;)
バージョン番号をインクリメントする
更新された行数が、
0だったらエラー。行を読んでから更新する前に他の誰かが行を更新したということ
1だったら更新成功
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
-->,"## 悲観的ロック
明示的にロックをかける
ロックが開放されるまで、ロックを保持していないユーザはデータを操作できない
場合によっては処理が長時間滞ってしまい、アプリケーションのパフォーマンスを著しく低下させる
MySQL では、LOCK TABLES、SELECT ... LOCK IN SHARE MODE, SELECT ... FOR UPDATE 等によって実現
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/README.md
:Q:SLOCKが必要となる例(親の名前で子供を作成),"mysql db -e '
BEGIN;
-- set @pname = (select name from parent where id = 1);  -- SLOCKしないとFK errorとなる
set @pname = (select name from parent where id = 1 lock in share mode);
select sleep(2);
insert into child (name, parent_id) values (@pname, 1);
COMMIT;
' &
sleep 1
mysql db -e 'delete from parent where id = 1;' &
wait
",/Users/mbp/workspace/sandbox/mid/mysql/sql/lock/slock.sh
# Get a lock for 10 sec,"# Get a lock for 10 sec
redis-cli flushall > /dev/null
f() {
    echo ""TRY TO GET A LOCK $1""
    if redis-cli set LOCK_KEY 1 NX PX 10000 | grep OK > /dev/null; then
        echo ""SUCCESS $1""
        sleep 1; redis-cli del LOCK_KEY > /dev/null
        echo ""DONE $1""
    else
        echo ""FAILURE $1""
    fi
}
f 1 & f 2 & wait
# single instanceの時は、setnxの戻り値を利用して排他的制御が可能.
# ただし、ロックを取得したプロセスがクラッシュしてデッドロックしないよう
# ロックを確保できる時間を設定する必要があるのに注意.
",/Users/mbp/workspace/sandbox/mid/redis/single_redis_lock.sh
-->,"## Materialized view
- 参照のみ: 更新することはできないが、複雑な定義のビューに利用
- Mysql5.7の場合、viewにindexを指定することはできない
",/Users/mbp/workspace/sandbox/sql/README.md
-->,"## slow queryの対処
- `slow_query_log_file` をセットして、遅いクエリを検知する
- eager load (N+1 query)
",/Users/mbp/workspace/sandbox/sql/README.md
insertによるdeadlockの例,"# unique key + bulk insertはdeadlockの可能性がある(解決方法はソート)
mysql db -e '
drop table if exists p;
CREATE TABLE p (`id` bigint(20) unsigned NOT NULL primary key);
'
q1=`perl -E '$a=join "", "", map {""($_)""} 1..999 ; say qq#insert into p (id) values $a ;#'`
q2=`perl -E '$a=join "", "", map {""($_)""} reverse 2..1000 ; say qq#insert into p (id) values $a ;#'`
echo $q1 | mysql db &
echo $q2 | mysql db &
wait
",/Users/mbp/workspace/sandbox/sql/bulkInsert.sh
-- cascadeとは？,"-- cascadeとは？
alter table child add foreign key (parent_id) references parent (id)
on delete cascade on update cascade;
-- update: 親の主キーが変更された場合に、子の参照keyを親の値に更新
-- delete: 親のレコードを削除した場合に、子ののレコードも削除
",/Users/mbp/workspace/sandbox/sql/cascade/cascade.sql
restrictとは？,"alter table child add foreign key (parent_id) references parent (id)
on delete restrict on update restrict;
-- 子供が参照した状態で、削除更新しようとするとエラー
-- ""SET CONSTRAINTS ALL DEFERRED""というコマンドを使うことで
-- 外部キー制約に限ってトランザクションの終わりまで制約の検査を遅延させることができる
",/Users/mbp/workspace/sandbox/sql/cascade/restrict.sql
-- set nullとは？(parent/childで説明),"-- set nullとは？(parent/childで説明)
alter table child add foreign key (parent_id) references parent (id)
on delete set null on update set null;
-- update: 親の主キーが変更された場合に、子の参照keyをNULLにする
-- delete: 親のレコードを削除した場合に、子の参照keyをNULLにする
",/Users/mbp/workspace/sandbox/sql/cascade/setNull.sql
:Q:テーブルの削除,"DROP TABLE IF EXISTS child, attribute, parent CASCADE;
-- CASCADEはposgresqlのみ(mysqlの時は親を最後に記述)
",/Users/mbp/workspace/sandbox/sql/createTable.sql
:Q:childにおける外部参照KEYの定義,"  id int(4) unsigned,
  FOREIGN KEY (id) REFERENCES parent (id) ON DELETE CASCADE ON UPDATE CASCADE
",/Users/mbp/workspace/sandbox/sql/createTable.sql
:Q:parentが持つ属性table,"CREATE TABLE IF NOT EXISTS attribute (
  -- 1to1となるように、PKまたは、uniqueの指定が必要
  parent_id int AUTO_INCREMENT,
  PRIMARY KEY (parent_id)
);
",/Users/mbp/workspace/sandbox/sql/createTable.sql
:Q:member_id=1に関する友達の友達,"select m.id from member m
join contact c1 on c1.user_id = m.id
join contact c2 on c2.user_id = c1.other_id
-- join contact c3 on c3.user_id = c2.other_id  -- さらに友達
where c2.other_id = 1;
",/Users/mbp/workspace/sandbox/sql/friendsFriends.sql
:Q:最も良い成績を選択,"select * from grade where score = (select max(score) from grade);
",/Users/mbp/workspace/sandbox/sql/getMaxAgePerson.sql
:Q:最も良い成績を選択(ただし結果は1recordのみ),"-- 重複した値をもたず、結果が1レコードのみで良ければ、order byが使える
select * from grade order by score desc limit 1;
",/Users/mbp/workspace/sandbox/sql/getMaxAgePerson.sql
":Q:varchar(5)の時の""abcdef""の挙動","insert into size_test (n1) values (""abcdef"");
-- strictの場合は、エラーとなる。
-- 警告の場合は、truncateされる(""abcdef"" => ""abcde"")
",/Users/mbp/workspace/sandbox/sql/size.sql
":Q:varchar(5)の時の""あabc""の挙動","insert into size_test (n1) values (""あabc"");
-- 「あ」は、3bytesなので、残り2bytes格納できる(""あabc"" => ""あab"")
-- 文字数でカウントされない
",/Users/mbp/workspace/sandbox/sql/size.sql
:Q:tinytextに格納てきる日本語,"-- tinytextは、255 (2^8−1) bytesまで格納できる。utf-8の「あ」は、3byteなので、85文字格納できる。
insert into size_test (n2) values (repeat(""あ"", 85));
",/Users/mbp/workspace/sandbox/sql/size.sql
:Q:成績の平均が上位3までの学生のSQL,"select s.id, AVG(g.score) from student s join grade g
on s.id = g.student_id group by s.id order by AVG(g.score) desc limit 3;
",/Users/mbp/workspace/sandbox/sql/top10StudentsAboutScore.sql
-- 異なるデータを一つのリストに混在させる方法,"-- 異なるデータを一つのリストに混在させる方法
-- 1. １つのテーブルにまとめる. (非正規化。余計なカラムが多くなる)
-- 2. 親に共通部分をまとめる. 子供で別々のカラムを定義 (継承問題)
-- 3. union. sortするのでoffsetのコストが高い. 予めtableをfilterしておく
-- 4. マテリアルview. データのためのリソースとindexの再計算処理のコスト
",/Users/mbp/workspace/sandbox/sql/union.sql
int main() ,"int main() {
  short int word = 0x0001;  // 2byte
  char *byte = (char *) &word;
  if (*byte) printf(""Little endian\n"");  // 01 00
  else printf(""big endian\n""); // 00 01
}
",/Users/mbp/workspace/sandbox/unix/checkEndian.c
# O(N)のパターン(ただし、２重ループ),"# O(N)のパターン(ただし、２重ループ)
# ルートNまでの総和はO(N): 1 + 2 + ... $sqrt[]{N} = $frac{1 + $sqrt[]{N}}{2} = O(N)
def ON(N, i=1):
    while i * i <= N:
        for j in range(i):
            pass
        i += 1
",/Users/mbp/workspace/sandbox/unix/order.py
# O(logN)のパターン,"# O(logN)のパターン
# 2で割る場合や余りの場合: 1 -> 2 -> 4 -> 8 -> ... 2^(n-1)
def OlogN(N):
    while N > 0:
        N /= 2
",/Users/mbp/workspace/sandbox/unix/order.py
# O(MN)のパターン,"# O(MN)のパターン
# 掛け算の場合はどちらが外側のループになるか、2通り考えられる
def OMN(N, M):
    for _ in range(M):
        for _ in range(N):
            pass
",/Users/mbp/workspace/sandbox/unix/order.py
# O(M+N)のパターン,"# O(M+N)のパターン
def OMON(N, M):
    for _ in range(M):
        pass
    for _ in range(N):
        pass
",/Users/mbp/workspace/sandbox/unix/order.py
