
==================
vector
==================

.. contents::
    :depth: 2



clear.scm
===========================


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; v.clear(); PE(v);' 
    
    



copy.scm
========================


.. code-block:: sh
   

    $ cpe 'vector<int>v(3, 7); vector<int> c(v); PE(c)' 
    7, 7, 7, 
    



count.scm
===========================


.. code-block:: sh
   

    $ cpe 'VI v{1,1,1,2,2,3}; P(count(v.begin(), v.end(), 1));' 
    count(v.begin(), v.end(), 1) = 3
    


.. code-block:: sh
   

    $ cpe 'VI v{1,1,1,2,2,3}; P(count(ALL(v), 2));' 
    count(ALL(v), 2) = 2
    


.. code-block:: sh
   

    $ cpe 'VI v{1,1,1,2,2,3}; P(count(ALL(v), 10));' 
    count(ALL(v), 10) = 0
    



enumerate.scm
=======================================



equal.scm
===========================


.. code-block:: sh
   

    $ cpe 'VI v1(10, 1), v2(10, 1); P(v1 == v2)' 
    v1 == v2 = 1
    


.. code-block:: sh
   

    $ cpe 'VI v1(10, 1), v2(10, 0); P(v1 == v2)' 
    v1 == v2 = 0
    



find.scm
========================


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(find(v.begin(), v.end(), 3) != v.end());' 
    find(v.begin(), v.end(), 3) != v.end() = 1
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(find(ALL(v), 3) != v.end());' 
    find(ALL(v), 3) != v.end() = 1
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(find(v, v + v.size(), 3) != v.end());' 
    <stdin>:45:30: error: invalid operands to binary expression ('VI' (aka 'vector<int>') and 'size_type' (aka 'unsigned long'))
        VI v{1,2,3}; P(find(v, v + v.size(), 3) != v.end());
                               ~ ^ ~~~~~~~~
    /home/me/lib/cpp/myutils.h:64:38: note: expanded from macro 'P'
    #define P(x) cout << #x << " = " << (x) << endl;
                                         ^
    /usr/include/c++/v1/iterator:614:1: note: candidate template ignored: could not match 'reverse_iterator<type-parameter-0-0>' against 'unsigned long'
    operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
    ^
    /usr/include/c++/v1/iterator:1009:1: note: candidate template ignored: could not match 'move_iterator<type-parameter-0-0>' against 'unsigned long'
    operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
    ^
    /usr/include/c++/v1/iterator:1245:5: note: candidate template ignored: could not match '__wrap_iter<type-parameter-0-0>' against 'unsigned long'
        operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;
        ^
    /usr/include/c++/v1/string:3858:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
    ^
    /usr/include/c++/v1/string:3871:1: note: candidate template ignored: could not match 'const _CharT *' against 'VI' (aka 'vector<int>')
    operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
    ^
    /usr/include/c++/v1/string:3883:1: note: candidate template ignored: could not match 'basic_string<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2>' against 'unsigned long'
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
    ^
    /usr/include/c++/v1/string:3894:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
    ^
    /usr/include/c++/v1/string:3906:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
    ^
    /usr/include/c++/v1/string:3920:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
    ^
    /usr/include/c++/v1/string:3928:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
    ^
    /usr/include/c++/v1/string:3936:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
    ^
    /usr/include/c++/v1/string:3944:1: note: candidate template ignored: could not match 'const _CharT *' against 'VI' (aka 'vector<int>')
    operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
    ^
    /usr/include/c++/v1/string:3952:1: note: candidate template ignored: could not match 'basic_string<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2>' against 'unsigned long'
    operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
    ^
    /usr/include/c++/v1/string:3961:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
    ^
    /usr/include/c++/v1/string:3969:1: note: candidate template ignored: could not match 'basic_string' against 'vector'
    operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
    ^
    1 error generated.
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(find(v.begin(), v.end(), 100) != v.end());' 
    find(v.begin(), v.end(), 100) != v.end() = 0
    


.. warning::

    Don't forget != v.end()


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(find(v.begin(), v.end(), 3));' 
    <stdin>:45:18: error: invalid operands to binary expression ('basic_ostream<char, std::__1::char_traits<char> >' and 'std::__1::__wrap_iter<int *>')
        VI v{1,2,3}; P(find(v.begin(), v.end(), 3));
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    /home/me/lib/cpp/myutils.h:64:34: note: expanded from macro 'P'
    #define P(x) cout << #x << " = " << (x) << endl;
                 ~~~~~~~~~~~~~~~~~~~ ^  ~~~
    /usr/include/c++/v1/ostream:175:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'std::__1::basic_ostream<char> &(*)(std::__1::basic_ostream<char> &)' for 1st argument
        basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));
                       ^
    /usr/include/c++/v1/ostream:176:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'basic_ios<char_type, traits_type> &(*)(basic_ios<char_type, traits_type> &)' for 1st argument
        basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                       ^
    /usr/include/c++/v1/ostream:178:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'std::__1::ios_base &(*)(std::__1::ios_base &)' for 1st argument
        basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));
                       ^
    /usr/include/c++/v1/ostream:179:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'bool' for 1st argument
        basic_ostream& operator<<(bool __n);
                       ^
    /usr/include/c++/v1/ostream:180:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'short' for 1st argument
        basic_ostream& operator<<(short __n);
                       ^
    /usr/include/c++/v1/ostream:181:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'unsigned short' for 1st argument
        basic_ostream& operator<<(unsigned short __n);
                       ^
    /usr/include/c++/v1/ostream:182:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'int' for 1st argument
        basic_ostream& operator<<(int __n);
                       ^
    /usr/include/c++/v1/ostream:183:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'unsigned int' for 1st argument
        basic_ostream& operator<<(unsigned int __n);
                       ^
    /usr/include/c++/v1/ostream:184:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'long' for 1st argument
        basic_ostream& operator<<(long __n);
                       ^
    /usr/include/c++/v1/ostream:185:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'unsigned long' for 1st argument
        basic_ostream& operator<<(unsigned long __n);
                       ^
    /usr/include/c++/v1/ostream:186:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'long long' for 1st argument
        basic_ostream& operator<<(long long __n);
                       ^
    /usr/include/c++/v1/ostream:187:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'unsigned long long' for 1st argument
        basic_ostream& operator<<(unsigned long long __n);
                       ^
    /usr/include/c++/v1/ostream:188:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'float' for 1st argument
        basic_ostream& operator<<(float __f);
                       ^
    /usr/include/c++/v1/ostream:189:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'double' for 1st argument
        basic_ostream& operator<<(double __f);
                       ^
    /usr/include/c++/v1/ostream:190:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'long double' for 1st argument
        basic_ostream& operator<<(long double __f);
                       ^
    /usr/include/c++/v1/ostream:191:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'const void *' for 1st argument
        basic_ostream& operator<<(const void* __p);
                       ^
    /usr/include/c++/v1/ostream:192:20: note: candidate function not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'basic_streambuf<char_type, traits_type> *' for 1st argument
        basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);
                       ^
    /usr/include/c++/v1/ostream:760:1: note: candidate function [with _CharT = char, _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'char' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
    ^
    /usr/include/c++/v1/ostream:793:1: note: candidate function [with _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'char' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __os, char __c)
    ^
    /usr/include/c++/v1/ostream:825:1: note: candidate function [with _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'signed char' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
    ^
    /usr/include/c++/v1/ostream:857:1: note: candidate function [with _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'unsigned char' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
    ^
    /usr/include/c++/v1/ostream:922:1: note: candidate function [with _CharT = char, _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'const char *' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
    ^
    /usr/include/c++/v1/ostream:968:1: note: candidate function [with _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'const char *' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
    ^
    /usr/include/c++/v1/ostream:1001:1: note: candidate function [with _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'const signed char *' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
    ^
    /usr/include/c++/v1/ostream:1034:1: note: candidate function [with _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'const unsigned char *' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
    ^
    /usr/include/c++/v1/ostream:1259:1: note: candidate function [with _CharT = char, _Traits = std::__1::char_traits<char>] not viable: no known conversion from 'std::__1::__wrap_iter<int *>' to 'const std::__1::error_code' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
    ^
    /usr/include/c++/v1/ostream:728:1: note: candidate template ignored: deduced conflicting types for parameter '_CharT' ('char' vs. 'std::__1::__wrap_iter<int *>')
    operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
    ^
    /usr/include/c++/v1/iomanip:348:1: note: candidate template ignored: could not match '__iom_t8' against '__wrap_iter'
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)
    ^
    /usr/include/c++/v1/iomanip:463:5: note: candidate template ignored: could not match '__iom_t10' against '__wrap_iter'
        operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);
        ^
    /usr/include/c++/v1/ostream:1210:5: note: candidate template ignored: disabled by 'enable_if' [with _Stream = std::__1::basic_ostream<char> &, _Tp = std::__1::__wrap_iter<int *>]
        !is_lvalue_reference<_Stream>::value &&
        ^
    /usr/include/c++/v1/ostream:889:1: note: candidate template ignored: could not match 'const _CharT *' against 'std::__1::__wrap_iter<int *>'
    operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
    ^
    /usr/include/c++/v1/ostream:1224:1: note: candidate template ignored: could not match 'basic_string' against '__wrap_iter'
    operator<<(basic_ostream<_CharT, _Traits>& __os,
    ^
    /usr/include/c++/v1/ostream:1267:1: note: candidate template ignored: could not match 'shared_ptr' against '__wrap_iter'
    operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
    ^
    /usr/include/c++/v1/ostream:1274:1: note: candidate template ignored: could not match 'bitset' against '__wrap_iter'
    operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
    ^
    1 error generated.
    



index.scm
===========================



front
---------------


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v.front());' 
    v.front() = 1
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v[0]);' 
    v[0] = 1
    



back
------------


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v.back());' 
    v.back() = 3
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v[v.size() - 1]);' 
    v[v.size() - 1] = 3
    



at
------


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v.at(0));' 
    v.at(0) = 1
    


.. warning::

    If at(i) access out of range, error occurs


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v.at(10));' 
    v.at(10) = アボートトラップ
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; try{v.at(10);} catch(out_of_range& e){P("out of range");}' 
    "out of range" = out of range
    



refer out of index
------------------------------------------------------


.. warning::

    [] can access index out of range


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v[100000000]);' 
    セグメンテーション違反
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; P(v[100]);' 
    v[100] = 0
    


.. code-block:: sh
   

    $ py 'P([1,2,3][1])' 
    2
    



init.scm
========================

Declare a variable but it's empty.

.. code-block:: sh
   

    $ cpe 'vector<int>v; P(v.empty())' 
    v.empty() = 1
    


.. warning::

    pointerとして初期化できない


.. code-block:: sh
   

    $ cpe 'vector<int>* x =  {1,2,3};' 
    <stdin>:45:18: error: excess elements in scalar initializer
        vector<int>* x =  {1,2,3};
                     ^      ~~~~~
    1 error generated.
    


.. warning::

    pointerとして初期化できない


.. code-block:: sh
   

    $ cpe 'vector<int>* x = &{1,2,3};' 
    <stdin>:45:23: error: expected expression
        vector<int>* x = &{1,2,3};
                          ^
    1 error generated.
    

変数を介せばOK

.. code-block:: sh
   

    $ cpe 'vector<int> x = {1,2,3}; vector<int>* y = &x;' 
    

Create a vector of [0, 0, 0] 

.. code-block:: sh
   

    $ cpe 'vector<int>v(3); PE(v)' 
    0, 0, 0, 
    


.. code-block:: sh
   

    $ cpe 'vector<int>v(3, 7); PE(v)' 
    7, 7, 7, 
    


.. code-block:: sh
   

    $ cpe 'vector<int>v{1,2,3,4,5}; PE(v)' 
    1, 2, 3, 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'int a[]={1,2,3,4,5}; vector<int> v(a, a+5); PE(a)' 
    <stdin>:45:49: error: member reference base type 'int [5]' is not a structure or union
        int a[]={1,2,3,4,5}; vector<int> v(a, a+5); PE(a)
                                                    ^~~~~
    /home/me/lib/cpp/myutils.h:66:28: note: expanded from macro 'PE'
      {for (int i = 0 ; i < (x).size(); i++){       \
                            ~~~^~~~~
    1 error generated.
    

10 * 10 vector

.. code-block:: sh
   

    $ cpe 'VI v1(3, 1); vector<vector<int>> v2(3, v1); PE2(v2)' 
    1, 1, 1, 
    1, 1, 1, 
    1, 1, 1, 
    


.. code-block:: sh
   

    $ cpe 'vector<vector<int>> v2(3, vector<int>(3, 1)); PE2(v2)' 
    1, 1, 1, 
    1, 1, 1, 
    1, 1, 1, 
    


.. code-block:: sh
   

    $ zsh -c 'typeset -a s; s=(1 2 3 4 1 2); echo $s' 
    1 2 3 4 1 2
    


.. code-block:: sh
   

    $ ce 'int a[10];' 
    


.. code-block:: sh
   

    $ ce 'static int a[10];' 
    


.. code-block:: sh
   

    $ ce 'int a[] = {1,2,3};' 
    


.. code-block:: sh
   

    $ ce 'int a[] = {1,2,3}; int *b=a;' 
    


.. warning::

    However you can't assign a vector to a pointer directly.


.. code-block:: sh
   

    $ ce 'int *a  = {1,2,3};' 
    <stdin>:3:16: warning: incompatible integer to pointer conversion initializing 'int *' with an expression of type 'int' [-Wint-conversion]
        int *a  = {1,2,3};
                   ^
    <stdin>:3:18: warning: excess elements in scalar initializer
        int *a  = {1,2,3};
                     ^
    2 warnings generated.
    

Initialize a 2D array

.. code-block:: sh
   

    $ ce 'int a[10][10] = {10}; p("%d", a[0][0]);' 
    10

Initialize a 2D array

.. code-block:: sh
   

    $ ce 'int a[10][10] = {{ 0 }}; p("%d", a[0][0]);' 
    0

valc. so you can allocate memroy dynamically even if it is an array

.. code-block:: sh
   

    $ ce 'int k=10; int a[k];' 
    

But with static, an error occurs

.. code-block:: sh
   

    $ ce 'int k=10;static int a[k];' 
    <stdin>:3:25: error: variable length array declaration can not have 'static' storage duration
        int k=10;static int a[k];
                            ^ ~
    1 error generated.
    



Initialize
------------------------------


.. code-block:: sh
   

    $ ce 'int i[30] = {0};' 
    


.. code-block:: sh
   

    $ ce 'int i; for(int k=0; k<30; k++)i[k]=0;' 
    <stdin>:3:36: error: subscripted value is not an array, pointer, or vector
        int i; for(int k=0; k<30; k++)i[k]=0;
                                      ~^~
    1 error generated.
    


.. code-block:: sh
   

    $ ce 'int i[30]; memset(i, 0, sizeof(i));' 
    

You need to initialize each item.

.. code-block:: c
   

    void a(int range){
      int c[range] = {0};
    }
    int main() {a(10);}

.. code-block:: sh
   

    <stdin>:2:9: error: variable-sized object may not be initialized
      int c[range] = {0};
            ^~~~~
    1 error generated.
    

You need to initialize each item.

.. code-block:: c
   

    void a(int range){
      
    int c[range];
    for (int i = 0; i < range; i++) c[i] = 0;
    
    }
    int main() {a(10);}

.. code-block:: sh
   

    



insert.scm
==============================


.. warning::

    Even if you don't alocate memroy, you can set it


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; v[100] = 1; P(v[100]);' 
    v[100] = 1
    



iter.scm
========================


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; for(int i=0; i<v.size(); i++)P(v[i]);' 
    v[i] = 1
    v[i] = 2
    v[i] = 3
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; for(vector<int>::iterator it=v.begin(); it!=v.end(); it++)P(*it);' 
    *it = 1
    *it = 2
    *it = 3
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; for(vector<int>::reverse_iterator rit=v.rbegin(); rit!=v.rend(); rit++)P(*rit);' 
    *rit = 3
    *rit = 2
    *rit = 1
    



length.scm
==============================


.. warning::

    iはマクロで使われているので別の変数にすること


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; REP(i, v.size()) PE(v[i]);' 
    <stdin>:45:35: error: member reference base type 'value_type' (aka 'int') is not a structure or union
        VI v{1,2,3}; REP(i, v.size()) PE(v[i]);
                                      ^~~~~~~~
    /home/me/lib/cpp/myutils.h:66:28: note: expanded from macro 'PE'
      {for (int i = 0 ; i < (x).size(); i++){       \
                            ~~~^~~~~
    <stdin>:45:35: error: subscripted value is not an array, pointer, or vector
        VI v{1,2,3}; REP(i, v.size()) PE(v[i]);
                                      ^~~~~~~~
    /home/me/lib/cpp/myutils.h:67:16: note: expanded from macro 'PE'
        cout << (x)[i] << ", "; \
                ~~~^~
    2 errors generated.
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3}; REP(a, v.size()) PE(v[a]);' 
    <stdin>:45:35: error: member reference base type 'value_type' (aka 'int') is not a structure or union
        VI v{1,2,3}; REP(a, v.size()) PE(v[a]);
                                      ^~~~~~~~
    /home/me/lib/cpp/myutils.h:66:28: note: expanded from macro 'PE'
      {for (int i = 0 ; i < (x).size(); i++){       \
                            ~~~^~~~~
    <stdin>:45:35: error: subscripted value is not an array, pointer, or vector
        VI v{1,2,3}; REP(a, v.size()) PE(v[a]);
                                      ^~~~~~~~
    /home/me/lib/cpp/myutils.h:67:16: note: expanded from macro 'PE'
        cout << (x)[i] << ", "; \
                ~~~^~
    2 errors generated.
    



slice.scm
===========================



begin, end
------------------------------


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.end())' 
    v.begin() ~ v.end() => 1, 2, 3, 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.begin())' 
    v.begin() ~ v.begin() => 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.begin() + 1)' 
    v.begin() ~ v.begin() + 1 => 1, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.begin() + 2)' 
    v.begin() ~ v.begin() + 2 => 1, 2, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.begin() + 3)' 
    v.begin() ~ v.begin() + 3 => 1, 2, 3, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.begin() + 4)' 
    v.begin() ~ v.begin() + 4 => 1, 2, 3, 4, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin(), v.begin() + 5)' 
    v.begin() ~ v.begin() + 5 => 1, 2, 3, 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.end(), v.end())' 
    v.end() ~ v.end() => 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.end() - 1, v.end())' 
    v.end() - 1 ~ v.end() => 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.end() - 2, v.end())' 
    v.end() - 2 ~ v.end() => 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.end() - 3, v.end())' 
    v.end() - 3 ~ v.end() => 3, 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.end() - 4, v.end())' 
    v.end() - 4 ~ v.end() => 2, 3, 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.end() - 5, v.end())' 
    v.end() - 5 ~ v.end() => 1, 2, 3, 4, 5, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.begin() + 1, v.end() - 1)' 
    v.begin() + 1 ~ v.end() - 1 => 2, 3, 4, 
    



rbegin, rend
------------------------------------


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.rbegin(), v.rend())' 
    v.rbegin() ~ v.rend() => 5, 4, 3, 2, 1, 
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; PIT(v.rbegin() + 1, v.rend() - 1)' 
    v.rbegin() + 1 ~ v.rend() - 1 => 4, 3, 2, 
    



compare (r)begin and (r)end
---------------------------------------------------------------------------------


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; P(v.begin() == v.end() - 5)' 
    v.begin() == v.end() - 5 = 1
    


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; P(v.rbegin() == v.rend() - 5)' 
    v.rbegin() == v.rend() - 5 = 1
    


.. warning::

    error


.. code-block:: sh
   

    $ cpe 'VI v{1,2,3,4,5}; P(v.rbegin() == v.end() - 5)' 
    <stdin>:45:35: error: invalid operands to binary expression ('reverse_iterator' (aka 'reverse_iterator<iterator>') and 'std::__1::__wrap_iter<int *>')
        VI v{1,2,3,4,5}; P(v.rbegin() == v.end() - 5)
                           ~~~~~~~~~~ ^  ~~~~~~~~~~~
    /home/me/lib/cpp/myutils.h:64:38: note: expanded from macro 'P'
    #define P(x) cout << #x << " = " << (x) << endl;
                                         ^
    1 error generated.
    

