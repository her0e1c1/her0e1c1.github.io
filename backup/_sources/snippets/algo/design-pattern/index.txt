
==========================================
design-pattern
==========================================

.. contents::
    :depth: 2



composite.scm
=======================================


Component * --<> 1 Composite
Component + operation() <- Leaf 
Component + operation() <- Composite

Composite Patternでは、箱をその中身と同様に扱う。
今回はファイルシステムを例にするため,
箱がDirectoryで、中身がFileとする。(Directoryは箱と中身の両方の役割を担う)

このパターンが有効なのは、再帰構造をしたデータである。
TreeのNodeがDirectoryで、LeafがFileとなる。

このパターンで必要となるものは
親子共通メソッドとCompositeにインスタンスを格納する容器

木構造の例
ツリーの関係(Node/Leaf)
DOM(html)
Parent/Children

以下のようなクラス
   class Node:
       children = []


.. code-block:: java
   

    import java.util.*;
    interface EntryInterface {
     public String name = "";
     public void remove();
    }
    class Directory implements EntryInterface {
     public String name;
     Directory(String name) { this.name = name; }
     ArrayList<EntryInterface> entries = new ArrayList<>();
     public void add(EntryInterface e) { entries.add(e); }
     public void remove() {
      for (EntryInterface e: entries) { e.remove(); }
      System.out.printf("Remove a %s directory\n", name);
     }
    }
    class File implements EntryInterface {
     public String name;
     File(String name) { this.name = name; }
     public void remove() { System.out.printf("Remove a %s file\n", name); }
    }
    public class Main {
     public static void main (String[] args) {
      Directory root = new Directory("root");
      for (int i: Arrays.asList(1,2,3,4,5))
       root.add(new File(String.format("text%d.txt", i)));
    
      Directory sub = new Directory("sub dir");
      for (int i: Arrays.asList(1,2,3,4,5))
       sub.add(new File(String.format("music%d.mp3", i)));
      root.add(sub);
    
      System.out.println("Call a remove method of a root directory...");
      root.remove();
     }
    }

.. code-block:: sh
   

    Call a remove method of a root directory...
    Remove a text1.txt file
    Remove a text2.txt file
    Remove a text3.txt file
    Remove a text4.txt file
    Remove a text5.txt file
    Remove a music1.mp3 file
    Remove a music2.mp3 file
    Remove a music3.mp3 file
    Remove a music4.mp3 file
    Remove a music5.mp3 file
    Remove a sub dir directory
    Remove a root directory
    



index.scm
===========================


区分方法(生成・振る舞い・構造/Encapsulation, polymorphism, inheritance)
- 継承(クラスの関係)
- 委譲と多重度(クラスの関係)
- キャッシュ
- ポリモーフィズム（共通メソッド==同一視）
  - 振る舞い
  - データ生成
  - クラスの条件分岐(全て、１つ)
- インターフェイス(使い手側がどう見えるか)
  - 既存コード修正必要・修正不要
  - wrapper(同一視+機能追加、インターフェイス改善-引数)
  - 状態(mutable/imutable)
  - 条件分岐(client側で分岐?implementer側で分岐?)

親と子供達（委譲）に共通のメソッドを用意
- composite(親子同一視)

親達(委譲)に共通のメソッドを用意
- state(親の差し替え前提)
- strategy(behavior、インスタンス時のみに選択できるが、差し替えしない)
- bridge(structure、選択させない、差し替えしない)

直系先祖達(委譲)に対して共通のメソッドを用意
- decorator(親子同一視)
- Chain of Responsibility(条件分岐==クラスの選択)

子供達に対して共通のメソッドを用意
- observer(subjectの状態変更通知, 1:N?)
- command(interfaceと実装の分離。実装１つ、インターフェイス複数、N:Mの関係)

Treeに対する評価
- visitor(動的にメソッド切り替える)

Listに対する評価
- iterator

別クラスのメソッドを呼び出す(一人委譲の親の委譲あり、逆参照なし)
- adaptor(一つのクラスをラップして、使いやすいインターフェイスを提供)
- proxy(別クラスと同一視、別クラスとプロキシクラスに同じメソッドが必要)
- facade(複数のクラスをラップして、使いやすいインターフェイスを提供)

N:Nの関係をN:1にする
- mediator(多重度の修正)


継承した子供の共通メソッド(データ生成)
- factory method(単一クラス)
- abstract factory(複数クラス)


関数型としての比較
- strategy (関数オブジェクト)
- visitor (foldable)
- composit (recursive data)



iterator.scm
====================================


# Aggregate +iterator() <- ConcreteAggregate
# Iterator +next(), hasNext() <- ConcreteIterator
# Aggregate -- create --> ConcreteAggregate
# ConcreteAggregate --<> ConcreteIterator
# オブジェクトを繰り返して取得する場合の実装方法


.. code-block:: java
   

    import java.util.*;
    public class Main {
     public static void main (String[] args) {
      Pack p = new Pack();
      p.add(new Candy(100));
      p.add(new Candy(200));
      p.add(new Candy(300));
      Iter i = p.iter();
      while (i.hasNext()) {
       Candy c = i.next();
       System.out.println(c);
      }
     }
    }
    
    class Candy {
     private int price;
     Candy(int price) { this.price = price; }
     @Override
     public String toString() { return String.format("candy(%d)", price); };
    }
    
    class Pack {
     private LinkedList<Candy> pack = new LinkedList<Candy>();
     public void add(Candy c) { pack.add(c);}
     public Iter iter() { return new Iter(this.pack); }
    }
    
    class Iter {
     private LinkedList<Candy> pack;
     Iter(LinkedList<Candy> p) { this.pack = p; }
     Candy next() { return this.pack.pop(); }
     boolean hasNext() { return this.pack.size() == 0 ? false : true; }
    }

.. code-block:: sh
   

    candy(100)
    candy(200)
    candy(300)
    



state.scm
===========================


stateパターンは状態によって、呼び出すメソッドを変更させる

context <>-- state
context +method1
state +method1 <- state1
state +method1 <- state2


.. code-block:: java
   

    interface State {
     public void hello();
    }
    class Fine implements State {
     public void hello() { System.out.println("Hello I'm file :D"); };
    }
    class Angry implements State {
     public void hello() { System.out.println("):"); };
    }
    class Human {
     private State state;
     Human(State s) { state = s; }
     public void hello() { state.hello(); };
    }
    class Main {
     public static void main (String[] args) {
      (new Human(new Fine())).hello();
      (new Human(new Angry())).hello();
     }
    }

.. code-block:: sh
   

    Hello I'm file :D
    ):
    



クラスの状態(Normal, Fast, Slow)に合わせてプレイヤーの移動速度が変わる
---------------------------------------------------------------------------------------------------------------------------------------


.. code-block:: py
   

    # URL: http://nekogata.hatenablog.com/entry/2013/02/09/233540
    
    def add(p1, p2):
        x1, y1 = p1
        x2, y2 = p2
        return (x1 + x2, y1 + y2)
    
    class Normal(object):
        def move(self, dx, dy):
            return (dx * 1, dy * 1)
    
    class Fast(object):
        def move(self, dx, dy):
            return (dx * 2, dy * 2)
    
    class Slow(object):
        def move(self, dx, dy):
            return (dx * 0.5, dy * 0.5)
    
    class Player(object):
    
        def __init__(self):
            self.position = (0, 0)
            self.state = Normal()
    
        def change(self, state):
            self.state = state
    
        def up(self):
            self.move(1, 0)
    
        def down(self):
            self.move(-1, 0)
    
        def left(self):
            self.move(0, 1)
    
        def right(self):
            self.move(0, -1)
    
        def move(self, dx, dy):
            self.position = add(self.state.move(dx, dy), self.position)
            print("(%s, %s)" % self.position)
    
    def main():
        p = Player()
        p.up()
        p.left()
        p.change(Fast())
        p.down()
        p.right()
        p.change(Slow())
        p.up()
        p.left()
    
    if __name__ == "__main__":
        main()

.. code-block:: sh
   

    (1, 0)
    (1, 1)
    (-1, 1)
    (-1, -1)
    (-0.5, -1.0)
    (-0.5, -0.5)
    

