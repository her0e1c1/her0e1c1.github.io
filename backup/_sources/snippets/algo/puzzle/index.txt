
==================
puzzle
==================

.. contents::
    :depth: 2



hanoi.scm
===========================


- srcにある(n-1)個をbufへ移動
- srcにある残りのn個目をdstに移動(実際に1つ動かすのはここのみ)
- bufにある(n-1)個をdstに移動


.. code-block:: py
   

    
    def move(n, src, buf, dst):
     if n > 0:
      move(n-1, src, dst, buf)
      dst.append(src.pop())
      assert len(dst) <= 1 or dst[-1] < dst[-2], 'move wrong'
      print(s, b, d)
      move(n-1, buf, src, dst)
    s, b, d = [5, 4, 3, 2, 1], [], []
    move(len(s), s, b, d)
    print(s, b, d)
    

.. code-block:: sh
   

    ([5, 4, 3, 2], [], [1])
    ([5, 4, 3], [2], [1])
    ([5, 4, 3], [2, 1], [])
    ([5, 4], [2, 1], [3])
    ([5, 4, 1], [2], [3])
    ([5, 4, 1], [], [3, 2])
    ([5, 4], [], [3, 2, 1])
    ([5], [4], [3, 2, 1])
    ([5], [4, 1], [3, 2])
    ([5, 2], [4, 1], [3])
    ([5, 2, 1], [4], [3])
    ([5, 2, 1], [4, 3], [])
    ([5, 2], [4, 3], [1])
    ([5], [4, 3, 2], [1])
    ([5], [4, 3, 2, 1], [])
    ([], [4, 3, 2, 1], [5])
    ([1], [4, 3, 2], [5])
    ([1], [4, 3], [5, 2])
    ([], [4, 3], [5, 2, 1])
    ([3], [4], [5, 2, 1])
    ([3], [4, 1], [5, 2])
    ([3, 2], [4, 1], [5])
    ([3, 2, 1], [4], [5])
    ([3, 2, 1], [], [5, 4])
    ([3, 2], [], [5, 4, 1])
    ([3], [2], [5, 4, 1])
    ([3], [2, 1], [5, 4])
    ([], [2, 1], [5, 4, 3])
    ([1], [2], [5, 4, 3])
    ([1], [], [5, 4, 3, 2])
    ([], [], [5, 4, 3, 2, 1])
    ([], [], [5, 4, 3, 2, 1])
    



n-queen.scm
=================================

全ての駒を斜め上(左右両方)に移動させる。枠から出てもよい。

.. code-block:: py
   

    
    from itertools import permutations
    n = 4
    queens = range(n)
    for pos in permutations(queens):
        if (n == len(set(pos[i] + i for i in queens))
              == len(set(pos[i] - i for i in queens))):
            print pos
    

.. code-block:: sh
   

    (1, 3, 0, 2)
    (2, 0, 3, 1)
    


.. code-block:: ghc
   

    canAttack :: [Int] -> Int -> Bool
    canAttack queens x = go queens 1 where
      go [] _ = False
      go (q:qs) n = q == x + n || q == x - n || go qs (n + 1)
    solve :: Int -> [[Int]]
    solve boardSize = go [] where
      go queens = if (length queens) == boardSize
                  then [queens]
                  else concatMap (go . flip (:) queens) $ filter f [0 .. (boardSize - 1)]
        where
          f x = not $ (elem x queens) || (canAttack queens x) 
    main = print $ solve 4

.. code-block:: sh
   

    [[2,0,3,1],[1,3,0,2]]
    

