
============
list
============

.. contents::
    :depth: 2



AddEachDigitOf2Lists.scm
========================================================================

(1 1 1) (2 3 4) => (3 4 5)のように、左側を一桁とした足し算

.. code-block:: gosh
   

    ; point: 空かそうでない場合をnext-Xとしておく
    (define (add list1 list2)
      (let loop ((a list1) (b list2) (carry 0))
        (let* ((sum (+ (if (null? a) 0 (car a))
                       (if (null? b) 0 (car b))
                       carry))
               ; 0 <= sum <= 9 + 9 + 1 = 19
               (digit (mod sum 10))
               (next-carry (if (>= sum 10) 1 0))
               (next-a (if (null? a) '() (cdr a)))
               (next-b (if (null? b) '() (cdr b))))
          (cond ((and (null? a) (null? b))
                 (if (= carry 1) '(1) '()))
                (else (cons digit (loop next-a next-b next-carry)))))))
    
    (define (main args)
      (print (add '(1 2 3 4 5) '(5 4 3 2 1)))
      (print (add '(7 7 7) '(3 2 2)))
      (print (add '(7 7 7) '(3)))
      (print (add '() '()))
      (print (add '() '(1 2 3)))
      0)

.. code-block:: sh
   

    



anagram.scm
=================================

anagramは、ある文字列の文字の順番を入れ替えて作成した別の文字列を作る
Statue of Liberty = built to stay free
.. todo:: 文字列の配列を受け取り、anagram同士が隣に並ぶようにソート

.. code-block:: c
   

    #include <stdio.h>
    
    int anagram(char* p, char* q) {
      // 256文字までと仮定
      char counter[256] = {0};
      int pl, ql;
      pl = ql = 0;
    
      // pにおけるそれぞれの文字数をカウント
      // Also get the length of p here
      for (char* it = p; *it; it++) {
        char c = *it - 'a';
        counter[c]++;
        pl++;
      }
    
      // qで上で取得したカウンタを減算
      // 別文字が存在、あるいは
      for (char* it = q; *it; it++) {
        char c = *it - 'a';
        counter[c]--;
        ql++;
        if (counter[c] < 0)
          return 0;
      }
    
      // p, qの長さが等しいも満たす必要あり
      if (pl == ql)
        return 1;
      return 0;
    }
    
    int main() {
      printf("%d\n", anagram("abacb", "aacbb"));  // 1
      printf("%d\n", anagram("abacb", "abcde"));  // 0
      printf("%d\n", anagram("abacb", "aabb"));   // 0
      printf("%d\n", anagram("abacb", "aabbcc")); // 0
    }

.. code-block:: sh
   

    <stdin>:12:20: error: use of undeclared identifier 'a'
        char c = *it - a;
                       ^
    <stdin>:20:20: error: use of undeclared identifier 'a'
        char c = *it - a;
                       ^
    2 errors generated.
    


.. code-block:: gosh
   

    (define (anagram? p q)
      (equal? (sort p) (sort q)))
    (print (anagram? "ababc" "cbbaa"))
    (print (anagram? "ababc" "abcde"))
    (print (anagram? "ababc" "cbbaaa"))
    (print (anagram? "ababc" "caaa"))

.. code-block:: sh
   

    #t
    #f
    #f
    #f
    



floyd-cycle-finding.scm
=====================================================================



find the start point of a cycled list
---------------------------------------------------------------------------------------------------------------


循環リストは以下のようなもの (startは円外の端)
(start)----------
            |___|
円の開始位置を結果として返す問題

速度が1と2のかめとうさぎを考える
startから円の開始位置までの距離をkとおくと
かめがk進んだときに、ウサギはk(mod=n)の位置にいる
このとき、ウサギからみたかめの位置はn - k(mod=n)先にいることになる
速度差は1なので、n-k(mod=n)だけかめが移動した位置で合流する
合流位置から開始までの距離は、n - (n-k(mod=n)) = k(mod=n)となる
かめをスタート位置に戻し、k(mod=n)だけ進めると（うさぎもここからは速度1）
うさぎは開始位置に到着(nごとに開始位置へ戻る)
k - k(mod=n) = nの倍数 (kをnで割った余りをk(mod=n)と置いた.kからその余りを引けば、それはnの倍数)
よって、開始位置で合流できる


.. code-block:: c
   

    #include <myc.h>
    #include <mystruct.h>
    
    list_t* find(list_t* node) {
      if (node == NULL)
        return NULL;
    
      list_t *fast, *slow;
      fast = slow = node;
    
      // find a point where both of two meet
      while (fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
          break;
      }
    
      // node is not cycled
      if (fast->next == NULL)
        return NULL;
    
      slow = node;
      while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
      }
      return slow;
    }
    int main() {
      list_t *n1 = inits(7, 0, 1, 2, 3, 4, 5, 6);
      indexAt(n1, 6)->next = indexAt(n1, 3);
      printf("start at %d\n", find(n1)->data);
    }

.. code-block:: sh
   

    start at 3
    



gfg.scm
=====================



minimun-stack.scm
===================================================


10 3 7 1 11 0
10 3 1 0と最小値をstackしていく
min O(1)となる


.. code-block:: cpp
   

    #include <myutils.h>
    class MinStack : public stack<int>{
    private:
      stack<int> cache;
    
    public:
      MinStack(){};
      void push(int);
      int pop(void);
      int getMin(void);
    };
    
    void MinStack::push(int value) {
      int min = getMin();
      if (min > value){
        cache.push(value);
      }
      stack::push(value);
    }
    
    int MinStack::pop() {
      int value = stack::top();
      stack::pop();
      if (getMin() == value)
        cache.pop();
      return value;
    }
    
    int MinStack::getMin() {
      if (cache.empty())
        return 1 << 30;
      return cache.top();
    }
    
    int main() {
      MinStack s;
      for (int i: {10, 3, 7, 1, 11, 0})
        s.push(i);
    
      while(! s.empty()){
        cout << s.getMin() << endl;
        s.pop();
      }
    }

.. code-block:: sh
   

    0
    1
    1
    3
    3
    10
    



yates-shuffle.scm
===================================================

末尾と取り替えるインデックスを決めて、それと末尾を入れ替え

.. code-block:: c
   

    #include <myc.h>
    void swap(int *x, int *y) { int t=*x; *x=*y; *y=t; }
    void shuffle(int *a, int size) {
     for (int i = size - 1; i >= 1; i--) {
       int j = rand() % (i + 1);
       assert (0 <= j && j <= i);
       swap(&a[i], &a[j]);
     }
    }
    int main() {
     srand(time(NULL));
     int a[] = {1,2,3,4,5};
     shuffle(a, SIZE(a));
     PVI(a);
    }

.. code-block:: sh
   

    2, 5, 1, 4, 3, 

