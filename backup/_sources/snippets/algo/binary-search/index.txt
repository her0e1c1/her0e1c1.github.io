
=======================================
binary-search
=======================================

.. contents::
    :depth: 2



count-k.scm
=================================

長さnのソート配列に含まれるkの個数

.. warning::

    upper_bound/lower_boundは、有限な配列に対してのみ有効


.. code-block:: sh
   

    $ cpe 'upper_bound(a, a + n, k) - lower_bound(a, a + n, k);' 
    <stdin>:45:17: error: use of undeclared identifier 'a'
        upper_bound(a, a + n, k) - lower_bound(a, a + n, k);
                    ^
    <stdin>:45:44: error: use of undeclared identifier 'a'
        upper_bound(a, a + n, k) - lower_bound(a, a + n, k);
                                               ^
    2 errors generated.
    



find-min-x.scm
==========================================



Compute the square root
---------------------------------------------------------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        n \in N  \quad s.t. \quad  \min_{x} f(x) = x^2 - n \ge 0
    \end{eqnarray}

min f(x) >= 0の場合は、foldを使えないが、whileによる解法あり.
foldが使えるのは、high側が常に失敗する場合のみ。今回はhigh側がTrueの場合
[0, 2^30]の範囲で探索

.. code-block:: py
   

    
    def g(n):
        def f(x):
            return x * x - n >= 0
        lo = rv = 0
        hi = 2 ** 30
        while lo <= hi:
            mi = (lo + hi) / 2
            if f(mi):
                hi = mi - 1
                rv = mi
            else:
                lo = mi + 1
        return rv
    print(g(15241578750190521))
    

.. code-block:: sh
   

    123456789
    



findSqrtN.scm
=======================================



Compute the square root
---------------------------------------------------------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        n \in N s.t. \max_{x} f(x) = x^2 - n \le 0
    \end{eqnarray}

f(x) <= 0の場合に、+ 2^xを大きい方から累積する。単調増加関数である必要あり 

.. code-block:: ghc
   

    
    h n = foldl g 0 (map (2^) [64,63..0]) where
     f x = x * x - n <= 0
     g acc a = let x = a + acc in if f x then x else acc
    main = print $ h 15241578750190521
    

.. code-block:: sh
   

    123456789
    

[0, 2^30]の範囲で探索

.. code-block:: py
   

    
    def g(n):
        def f(x):
            return x * x - n <= 0
        lo = rv = 0
        hi = 2 ** 30
        while lo <= hi:
            mi = (lo + hi) / 2
            if f(mi):
                lo = mi + 1
                rv = mi
            else:
                hi = mi - 1
        return rv
    print(g(15241578750190521))
    

.. code-block:: sh
   

    123456789
    

目的の値を取得したところで探索終了

.. code-block:: py
   

    
    def g(n):
        def f(x):
            return x * x - n
        lo = 0
        hi = 2 ** 30
        while lo <= hi:
            mi = (lo + hi) / 2
            rv = f(mi)
            if rv == 0:
                return mi
            elif rv < 0:
                lo = mi + 1
            else:
                hi = mi - 1
    print(g(15241578750190521))
    

.. code-block:: sh
   

    123456789
    



index.scm
===========================



基本的な考え方
---------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\区間[low, high]を探索
    \\
    \\中点を取る際に、以下の２通りが考えられる(k \ge 0)
    \\high & = & low + 2k
    \\high & = & low + 2k + 1
    \\
    \\中点について
    \\mid & = & (low + high) / 2
    \\より、いずれの場合も、以下となる
    \\mid & = & low + k
    \\
    \\midが解でない場合は、区間を狭める必要がある. 
    \\midは解ではないので、区間に含めない.
    \\
    \\以下の範囲に狭めて探索を続ける
    \\区間[low, mid - 1] (midよりも左側)
    \\区間[mid + 1, high] (else)
    \\
    \end{eqnarray}



終了条件をlow<highにすることの問題点
------------------------------------------------------------------


k=0のとき、以下のいずれかとなる

- high = low (探索終了)
- high = low + 1 (ループ続ける)

しかし、ループを続けても、ともに終了条件となる

- [low, low+1] => [low+1, low+1] (右側探索)
- [low, low+1] => [low, low-1] (左側探索)

双方の場合、mid = lowなので、lowの探索はするが、low+1の探索はしない.
つまり、low<highの終了条件の場合、[low, low+1)の範囲しか探索しない.

.. todo:: ここから、1bit目が0のもの全てが探索されないといいたい


midで更新することの問題点
------------------------------------------


k = 0 かつ、終了条件がlow<=high のとき、mid = lowなので、

右側探索で更新する時、mid+1せず、midで更新すると、以下のように無限ループになる.

- [low, low]   => 右側探索 => [mid, low]   = [low, low]
- [low, low+1] => 右側探索 => [mid, low+1] = [low, low+1]

左側探索で更新する時、mid-1せず、midで更新すると、同様に無限ループになる.

- [low, low]   => 左側探索 => [low, mid] = [low, low]
- [low, low+1] => 左側探索 => [low, mid] = [low, low]

つまり、解ではないことが判明したmidを区間に含めないように、mid+1, mid-1して区間を狭める必要がある。

.. todo:: minを取得する場合は、若干工夫する必要あり
ビット演算でのイメージ
======================
``f(x) = -x^2 + 10*x + 1`` の ``max x in N st f(x) > 0`` を考える。
答えは、 ``f(10) = 1, f(11) = -10`` よりx=10である。

``f(2^4) < 0`` なので、4乗は境界線を超えている(当然f(2^5)なども、この関数では同様)。
これは、 ``x < 16`` と値域が狭まったことを意味している。
2進数で言うと、0b0XXXXと5桁目以降が0bitであることを意味している。

``f(2^3) >= 0`` なので、 ``8 <= x < 16`` となり、
2進数で言うと、0b01XXXと4桁目が1bitを意味する。

``f(2^3 + 2^2) < 0`` なので、 ``8 <= x < 12`` となり、 0b010XXとなる。
xは8以上なので、ここで ``f(2^2)`` などを計算することに意味はない。

同様に
``f(2^3 + 2^1) >= 0`` なので、 ``10 <= x < 12`` となり、 0b0101Xとなる。

``f(2^3 + 2^1 + 2^0) < 0`` なので、 ``10 <= x < 11`` となり、 0b01010が答えとなる。

::

    f = lambda x: -(x * x) + 10 * x + 1

    def p(n):
        print("f(%s) = %s" % (n, f(n)))

    p(pow(2, 5))  # f() < 0
    p(pow(2, 4))  # f() < 0
    p(pow(2, 3))  # f() >= 0
    p(pow(2, 3) + pow(2, 2))
    p(pow(2, 3) + pow(2, 1))
    p(pow(2, 3) + pow(2, 1) + pow(2, 0))
   
アルゴリズムのイメージは、
ジャンプの飛び幅を徐々に小さくしながら目的地に到達するイメージとなる。
つまり、大きい方から範囲を徐々に狭めるイメージ。

.. warning:: bit演算の問題点は、負の数には対応できないので、注意すること。


使えない場合の例
------------------------

[5,6,5,6,1,1,1,1,6,5,6,5]の数列の極大値を各グループごとに含むようにして、できるだけ多く分割したい場合
n=3で失敗するからといって、n=4も失敗するとは限らない


minimize-sum-sequence.scm
===========================================================================

ある配列をK個に区分したときの、区分配列のうち最大和の最小値を求める
[max(A), sum(A)]の範囲で2分探索することで、SUMの最小値がもとまる

.. code-block:: cpp
   

    #include "myutils.h"
    bool f(int SUM, int K, vector<int> A) {
      int s = 0;
      int k = 0;
      for (int i = 0; i < A.size(); i++) {
        if (s + A[i] <= SUM) {
          s += A[i];
        } else {
          k++;
          s = A[i];
        }
        if (k == K) return false;
      }
      return true;
    }
    int main() {
      P(f(7, 3,{2, 1, 5, 1, 2, 2, 2}));
      P(f(6, 3,{2, 1, 5, 1, 2, 2, 2}));
      P(f(5, 3,{2, 1, 5, 1, 2, 2, 2}));
      P(f(1000, 1,{0, 1000, 0}));
    }

.. code-block:: sh
   

    f(7, 3,{2, 1, 5, 1, 2, 2, 2}) = 1
    f(6, 3,{2, 1, 5, 1, 2, 2, 2}) = 1
    f(5, 3,{2, 1, 5, 1, 2, 2, 2}) = 0
    f(1000, 1,{0, 1000, 0}) = 1
    



rotate.scm
==============================



k-roteated increasing order array
---------------------------------------------------------------------------------------------------


-- A -- left -- B -- mid -- C -- right -- D --

本来 left <= mid <= rightが成立する
ただし、lotateしているため、その開始位置がmidの右か左か特定する必要がある。

a[left] < a[mid]のときは、左側が順番に並んでいるので、Cに開始位置がある.
leftとmidの間にtargetがあるか、ないかで区間を狭めることができる。


.. code-block:: c
   

    
    #include <stdio.h>
    int search(int *a, int left, int right, int target) {
      while (left <= right) {
        int mid = left + (right - left) / 2;
        if (a[mid] == target)
          return mid;
        else if (a[left] > a[mid]) {
          if (a[mid] <= target && target <= a[right])
            left = mid + 1;
          else
            right = mid - 1;
        } else {
          if (a[left] <= target && target <= a[mid])
            right = mid - 1;
          else
            left = mid + 1;
        }
      }
      return -1;
    }
    int main() {
      int A[] = {/* TEST-DATA */};
      int arr_size = sizeof(A)/sizeof(A[0]);
      for (int i = 0; i <= 9; i++)
        printf("%d, ", search(A, 0, arr_size - 1, i));
      return 0;
    }
    

TEST-DATA = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

.. code-block:: sh
   

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 

TEST-DATA = 1, 2, 3, 4, 5, 6, 7, 8, 9, 0

.. code-block:: sh
   

    9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 

TEST-DATA = 2, 3, 4, 5, 6, 7, 8, 9, 0, 1

.. code-block:: sh
   

    8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 

TEST-DATA = 2,2,2,2,2,2,2,3,2,2
linerでなくても求まる!

.. code-block:: sh
   

    -1, -1, 4, 7, -1, -1, -1, -1, -1, -1, 



zero.scm
========================

interspersedWithZero (0が途中に混ざった場合のbinary search)
CI 9.5

- 終了条件low<=high
- 更新mid+1,mid-1

の場合の探索は
区間[low, high]となるため、
0を無視するようmidを移動する。
lowは探索ずみなので、low<midの条件入れておく


.. code-block:: cpp
   

    
    #include <myutils.h>
    int find(vector<int> a, int target) {
      int lo=0, hi=a.size()-1;
      while (lo<=hi){
       int mi=(lo+hi)/2;
       while (a[mi] == 0 && lo < mi) mi--;  // ADD
       if (a[mi] == target) return mi;
       else if (a[mi] < target) lo=mi+1;
       else hi=mi-1;
      }
      return -1;
    }
    
    int main() {
      for (int i = 0; i <= 10; i++)
        //      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
        P(find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i));
    
    }
    

.. code-block:: sh
   

    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 0
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 1
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 4
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 6
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 14
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 19
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 20
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 22
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 25
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 26
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = -1
    

