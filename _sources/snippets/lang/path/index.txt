
============
path
============

.. contents::
    :depth: 2



basename.scm
====================================



basename
------------------------


.. code-block:: sh
   

    $ ruby -e 'puts File.basename("/path/to/file.txt")' 
    file.txt
    


.. code-block:: sh
   

    $ he 'System.FilePath.takeFileName "/path/to/file.txt"' 
    
    /tmp/tmp.2ghMo65s:7:15:
        Not in scope: ‘System.FilePath.takeFileName’
    


.. code-block:: sh
   

    $ perl -M'File::Basename' -E 'say basename qq#/path/to/text.txt#'
    text.txt
    


.. code-block:: sh
   

    $ perl -M"File::Basename" -E 'say basename "/path/to/file.txt"'
    file.txt
    


.. code-block:: sh
   

    $ s '(sys-basename "foo/bar/bar.z")' 
    bar.z
    


.. code-block:: sh
   

    $ ee '(f-filename "/root/file/text.txt")' 
    
    "text.txt"
    


.. code-block:: sh
   

    $ ee '(f-base "/root/file/text.txt")' 
    
    "text"
    



dirname.scm
=================================


.. code-block:: sh
   

    $ ee '(f-dirname "/root/file/text.txt")' 
    
    "/root/file"
    


.. code-block:: sh
   

    $ ee '(file-name-directory "/path/to/file.txt")' 
    
    "/path/to/"
    


.. code-block:: sh
   

    $ s '(sys-dirname "/path/to/file.txt")' 
    /path/to
    



end.scm
=====================


.. code-block:: sh
   

    $ perl -E 'say 1
    __END__
    say2' 
    1
    



expand.scm
==============================


.. code-block:: sh
   

    $ ee '(f-expand "~/work")' 
    
    "/home/me/work"
    


.. code-block:: sh
   

    $ ee '(locate-user-emacs-file ".cask")' 
    
    "~/.emacs.d/.cask"
    



ext.scm
=====================


.. code-block:: sh
   

    $ s '(path-extension "/path/to/text.txt")' 
    txt
    

parse only one dot

.. code-block:: sh
   

    $ s '(path-extension "/foo/bar.c.a")' 
    a
    


.. code-block:: sh
   

    $ ee '(f-ext "/root/file/text.txt")' 
    
    "txt"
    


.. code-block:: sh
   

    $ ee '(f-ext "/root/file/text.tar.gz")' 
    
    "gz"
    


.. code-block:: sh
   

    $ s '(path-swap-extension "/path/to/text.txt" "csv")' 
    /path/to/text.csv
    


.. code-block:: sh
   

    $ s '(path-swap-extension "/path/to/text.txt" #f)' 
    /path/to/text
    



glob.scm
========================


.. code-block:: sh
   

    $ python -c 'import os; print("
    ".join(os.listdir(".")))'
      File "<string>", line 1
        import os; print("
                         ^
    SyntaxError: EOL while scanning string literal
    


.. code-block:: sh
   

    $ ghc -e 'System.Directory.getDirectoryContents "." >>= return . unlines >>= putStr'
    .
    ..
    process
    set
    byte
    char
    op
    async
    module
    math
    index.sh
    bit
    tuple
    class
    hook.sh.tmp
    elisp
    html
    regex
    number
    index.rst
    memory
    macro
    exception
    special_variables
    hash
    index.scm
    var
    string
    lazy
    range
    java.scm
    stack
    list
    ifdef.c
    test.tmp
    test
    .gitignore
    a.out
    char-set
    cmd
    pointer
    sys
    io
    vector
    type
    http
    date
    func
    path
    haskell.scm
    


.. code-block:: sh
   

    $ perl -E 'say for glob("*")'
    a.out
    async
    bit
    byte
    char
    char-set
    class
    cmd
    date
    elisp
    exception
    func
    hash
    haskell.scm
    hook.sh.tmp
    html
    http
    ifdef.c
    index.rst
    index.scm
    index.sh
    io
    java.scm
    lazy
    list
    macro
    math
    memory
    module
    number
    op
    path
    pointer
    process
    range
    regex
    set
    special_variables
    stack
    string
    sys
    test
    test.tmp
    tuple
    type
    var
    vector
    


.. code-block:: sh
   

    $ s '(glob "*")' 
    (haskell.scm path func date http type vector io sys pointer cmd char-set a.out test test.tmp ifdef.c list stack java.scm range lazy string var index.scm hash special_variables exception macro memory index.rst number regex html elisp hook.sh.tmp class tuple bit index.sh math module async op char byte set process)
    


.. code-block:: sh
   

    $ s '(glob "../.*")' 
    (../.gitignore ../.. ../.)
    


.. code-block:: sh
   

    $ s '(glob "**/*.h")' 
    (module/c/1/sample.h module/c/double-quote/same-dir.h module/c/2/util.h module/c/sharedLibrary/hello.h)
    


.. code-block:: sh
   

    $ ee '(f-glob "./*.scm")' 
    
    ("/usr/home/me/github/her0e1c1.github.io/.rst/snippets/lang/haskell.scm" "/usr/home/me/github/her0e1c1.github.io/.rst/snippets/lang/index.scm" "/usr/home/me/github/her0e1c1.github.io/.rst/snippets/lang/java.scm")
    



join.scm
========================


.. code-block:: sh
   

    $ perl -M'File::Spec' -E 'say File::Spec->catfile(q#/path/to#, q#file.txt#)'
    /path/to/file.txt
    


.. code-block:: sh
   

    $ ee '(f-join "/path" "to" "file.txt")' 
    
    "/path/to/file.txt"
    


.. code-block:: sh
   

    $ s '(build-path "/path" "to" "file.txt")' 
    /path/to/file.txt
    



normalize.scm
=======================================

Normalize path. I think return value is the same as a buff-stored value.

.. code-block:: sh
   

    $ ce 'char s[PATH_MAX]; p("%s", realpath("/home/../home/././.", s));' 
    /usr/home


.. code-block:: sh
   

    $ s '(sys-normalize-pathname "~//a/./d/b" :expand #t :absolute #t :canonicalize #t)' 
    /home/me/a/d/b
    



sep.scm
=====================



split.scm
===========================


.. code-block:: sh
   

    $ ee '(f-split "/path/to/file.txt")' 
    
    ("/" "path" "to" "file.txt")
    


.. code-block:: sh
   

    $ s '(receive (dir base ext) (decompose-path "/path/to/file.txt") (list dir base ext))' 
    (/path/to file txt)
    



stat.scm
========================



mount info
------------------------------


.. code-block:: sh
   

    $ ce 'struct statfs s; statfs("/home", &s); p("%s", s.f_mntonname);' 
    /



tmpdir.scm
==============================

