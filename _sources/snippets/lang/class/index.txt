
===============
class
===============

.. contents::
    :depth: 2



advice.scm
==============================

afterを定義したので、(echo)を実行した後に呼びだされる

.. code-block:: sh
   

    $ ee '(progn (defun echo () (print "echo")) (defadvice echo (after after-echo activate) (print "after echo!")) (echo))' 
    
    "echo"
    
    "after echo!"
    
    "echo"
    



.. code-block:: sh
   

    $ ee '(progn (defun f1 () 1) (defadvice f1 (before before-f1 activate) (print "before") ad-return-value) (f1))' 
    
    "before"
    
    1
    



get.scm
=====================

*A->Bの評価のされ方は、*(A->B)となる. つまり、A->Bは、Bのpointerを表す(->の方が結合力ある)

.. code-block:: c
   

    #include <stdio.h>
    int main() {
      typedef struct _t {int* B;} t;
      int value = 1;
      t data;
      data.B = &value;
      t* A = &data;
      printf("%d == %d\n", *A->B, *(A->B));
    }

.. code-block:: sh
   

    1 == 1
    

(*A)->Bは、pointer->Bと評価(Bの値が返る). **A = &pointer (つまり、Aはpointerのpointer)

.. code-block:: c
   

    #include <stdio.h>
    int main() {
      typedef struct _t {int B;} t;
      t data;
      data.B = 1;
      t* pointer = &data;
      t** A = &pointer;
      printf("%d\n", (*A)->B);
      // printf("%d\n", *A->B);
    }

.. code-block:: sh
   

    1
    



init.scm
========================


.. code-block:: sh
   

    $ php -r 'class A {public $v = '\''val'\'';} $a=new A(); echo "$a->v";' 
    val


.. code-block:: ruby
   

    class Human
      def initialize(name="")
        @name = name
      end
      attr_accessor :name
    end
    puts (Human.new "Bob").name

.. code-block:: sh
   

    Bob
    


.. code-block:: cpp
   

    #include <myutils.h>
    class Human {
    private:
     string name;
    public:
     Human(string name) {
      this->name = name;
     }
     void say() {
      cout << this->name << endl;
     }
    };
    int main() {Human h("Bob"); h.say();}

.. code-block:: sh
   

    Bob
    



isinstance.scm
==========================================


.. code-block:: sh
   

    $ py 'P(isinstance(1, int))' 
    True
    



prototype.scm
=======================================



struct.scm
==============================


.. code-block:: sh
   

    $ ce 'typedef struct {char name[64];}S; S s; strcpy(s.name, "Bob"); p("%s", s.name);' 
    Bob


.. code-block:: sh
   

    $ ce 'typedef struct {unsigned bool: 1;}Bool; Bool b; b.bool=0; p("%d", b.bool);' 
    0


.. code-block:: sh
   

    $ ce 'typedef struct {unsigned bool: 1;}Bool; Bool b; b.bool=1; p("%d", b.bool);' 
    1


.. code-block:: sh
   

    $ ce 'typedef struct {unsigned bool: 1;}Bool; Bool b; b.bool=2; p("%d", b.bool);' 
    <stdin>:3:59: warning: implicit truncation from 'int' to bitfield changes value from 2 to 0 [-Wbitfield-constant-conversion]
        typedef struct {unsigned bool: 1;}Bool; Bool b; b.bool=2; p("%d", b.bool);
                                                              ^~
    1 warning generated.
    0

