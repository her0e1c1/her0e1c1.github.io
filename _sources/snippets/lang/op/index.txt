
==
op
==



add.scm
=======


.. warning::

    ``(i + j) / 2`` becomes overflow. use ``i + (j - i) / 2``


.. code-block:: sh
   

    $ ce 'unsigned char s=200, t=200; p("%d", (unsigned char) (s + t) / 2);' 
    72


.. code-block:: sh
   

    $ ce 'unsigned char s=200, t=200; p("%d", (unsigned char) s + (t - s) / 2);' 
    200



set.scm
=======



assign
======


.. code-block:: sh
   

    $ sh -c ': ${A=1} && echo $A' 
    1
    

${NAME:=VAL} if variable is undefined, then set a value.

.. code-block:: sh
   

    $ sh -c ': ${NULL:='\''NULL'\''} && echo $NULL' 
    NULL
    

${NAME:-VAL} if variable is undefined, then evaluate a value but not set it.

.. code-block:: sh
   

    $ sh -c 'echo ${NULL:-'\''NULL'\''}' 
    NULL
    


.. code-block:: sh
   

    $ sh -c ': ${NULL:-'\''NULL'\''}; echo $NULL' 
    
    


.. code-block:: sh
   

    $ sh -c 'NULL='\''HOGE'\'' && echo ${NULL:-'\''NULL'\''}' 
    HOGE
    

${NAME:=VAL} if variable is defined, then evaluate a value but not set it.

.. code-block:: sh
   

    $ sh -c 'echo ${NULL:+'\''NULL AGAIN'\''}' 
    
    


.. code-block:: sh
   

    $ zsh -c ': ${a::=1}; echo $a' 
    1
    



false.scm
=========



false
=====


.. code-block:: sh
   

    $ perl -E 'say $a || "" || 0'
    0
    


.. code-block:: sh
   

    $ ne 'undefined || null || "" || 0 || false' 
    


.. code-block:: sh
   

    $ ce 'if(!0)p("false");' 
    false


.. code-block:: sh
   

    $ ce 'if(!NULL)p("false");' 
    false


.. code-block:: sh
   

    $ ce 'char *s=""; if(!*s)p("false");' 
    false


.. code-block:: sh
   

    $ ce 'if("")p("true");' 
    true



eq.scm
======


.. code-block:: sh
   

    $ ne 'typeof "s" === "string"' 
    

NaN stands for Not a Number

.. code-block:: sh
   

    $ ne 'isNaN(NaN)' 
    


.. code-block:: sh
   

    $ ne '(NaN === 1)' 
    


.. code-block:: sh
   

    $ ne '(NaN === NaN)' 
    


.. code-block:: sh
   

    $ ne '1 == "1"' 
    

=== needs strict type

.. code-block:: sh
   

    $ ne '1 === "1"' 
    


.. code-block:: sh
   

    $ ne '1 / 0 === Infinity' 
    

= --  値が等しい

.. code-block:: sh
   

    $ ne '1 == "1"' 
    


.. code-block:: sh
   

    $ ne '1 == 1' 
    


.. code-block:: sh
   

    $ ne '1 === 1' 
    


.. code-block:: sh
   

    $ ne '1 === "1"' 
    


.. code-block:: sh
   

    $ ne '{} == {}' 
    [eval]:7
    {} == {}
       ^^
    
    SyntaxError: Unexpected token ==
        at Object.exports.runInThisContext (vm.js:53:16)
        at Object.<anonymous> ([eval]-wrapper:6:22)
        at Module._compile (module.js:435:26)
        at node.js:576:27
        at doNTCallback0 (node.js:417:9)
        at process._tickCallback (node.js:346:13)
    


.. code-block:: sh
   

    $ ne '[] == []' 
    

Infinity

.. code-block:: sh
   

    $ ne '1/0 === 2/0' 
    

NaNvar

.. code-block:: sh
   

    $ ne '0/0 === 0/0' 
    



pass.scm
========



colon
=====

colon(:) is similar to pass in Python

.. code-block:: sh
   

    $ sh -c 'if true; then :; fi' 
    


.. warning::

    代入式などに使用する. コマンドを実行しないようにする


.. code-block:: sh
   

    $ sh -c '${A=1} && echo $A' 
    1: not found
    



undefined.scm
=============


.. code-block:: sh
   

    $ ne 'P(typeof a === '\''undefined'\'')' 
    true
    

変数が未定義であることを確認

.. code-block:: sh
   

    $ perl -E 'say "undefined" if !defined($a)'
    undefined
    

未定義の場合に代入

.. code-block:: sh
   

    $ perl -E '$a//=1; say $a'
    1
    


.. warning::

    shの注意 # 文字列として認識させるため"$VAR"とすること


.. code-block:: sh
   

    $ sh -c 'test -z "$__THIS__IS__NOT__DEFINED" && echo "undefined"' 
    undefined
    

定義を確認

.. code-block:: sh
   

    $ sh -c 'test -n "$PATH" && echo "defined"' 
    defined
    


.. code-block:: sh
   

    $ sh -c 'test -n a a && echo 1' 
    test: a: unexpected operator
    


.. code-block:: sh
   

    $ sh -c 'test -n "a a" && echo 1' 
    1
    

if a variable is defiend, then return 1

.. code-block:: sh
   

    $ zsh -c 'echo ${+PATH}' 
    1
    


.. code-block:: sh
   

    $ zsh -c 'echo ${+HOGEHOGE}' 
    0
    



enum.scm
========


.. code-block:: sh
   

    $ ce 'enum E{A,B}; enum E e=A; p("%d", e);' 
    0


.. code-block:: sh
   

    $ ce 'enum E{A,B}; enum E e=B; p("%d", e);' 
    1


.. code-block:: sh
   

    $ ce 'enum E{A=10,B}; enum E e=A; p("%d", e);' 
    10


.. code-block:: sh
   

    $ ce 'enum E{A=10,B}; enum E e=B; p("%d", e);' 
    11

alias enum

.. code-block:: sh
   

    $ ce 'typedef enum E{A,B}F; F e=A; p("%d", e);' 
    0


.. code-block:: sh
   

    $ ce 'typedef enum E{A,B}F; F e=B; p("%d", e);' 
    1

create a variable

.. code-block:: sh
   

    $ ce 'enum E{A,B}e; e=A; p("%d", e);' 
    0


.. code-block:: sh
   

    $ ce 'enum E{A,B}e; e=B; p("%d", e);' 
    1



typeof.scm
==========



typeof
======


.. code-block:: sh
   

    $ ne 'typeof(true)' 
    


.. code-block:: sh
   

    $ ne 'typeof(123)' 
    


.. code-block:: sh
   

    $ ne 'typeof('\''abc'\'')' 
    


.. code-block:: sh
   

    $ ne 'typeof({})' 
    


.. code-block:: sh
   

    $ ne 'typeof([])' 
    


.. code-block:: sh
   

    $ ne 'typeof /regexp/' 
    


.. code-block:: sh
   

    $ ne 'typeof function(){}' 
    


.. code-block:: sh
   

    $ ne 'typeof null' 
    


.. code-block:: sh
   

    $ ne 'typeof undefined' 
    



eval.scm
========


.. code-block:: sh
   

    $ sh -c 'eval "echo $HOME"' 
    /home/me
    



for.scm
=======


.. code-block:: sh
   

    $ sh -c 'for i in 1 2 3; do echo $i; done' 
    1
    2
    3
    

001.csv ... 010.csvまでの空ファイルを作成

.. code-block:: sh
   

    $ sh -c 'for i in $(seq -f "%03g" 1 10); do printf "%s.csv " $i; done' 
    001.csv 002.csv 003.csv 004.csv 005.csv 006.csv 007.csv 008.csv 009.csv 010.csv 

区切り文字を$IFSとして、配列を生成し、行つきの結果を表示

.. code-block:: sh
   

    $ sh -c 'cnt=0; for i in `ls`; do echo "$cnt $i"; cnt=$((cnt + 1)); done' 
    0 bit
    1 char
    2 char-set
    3 class
    4 cmd
    5 date
    6 exception
    7 func
    8 hash
    9 index.rst
    10 index.scm
    11 index.sh
    12 io
    13 list
    14 math
    15 memory
    16 number
    17 op
    18 path
    19 pointer
    20 range
    21 regex
    22 set
    23 special_variables
    24 stack
    25 string
    26 tuple
    27 type
    28 vector
    



instanceof.scm
==============



instanceof
==========


.. code-block:: sh
   

    $ ne '[] instanceof Array' 
    


.. code-block:: sh
   

    $ ne '/regexp/ instanceof RegExp' 
    


.. code-block:: sh
   

    $ ne '/regexp/ instanceof Function' 
    


.. code-block:: sh
   

    $ ne '(function(){}) instanceof Function' 
    


.. code-block:: sh
   

    $ ne 'undefined instanceof Object' 
    


.. code-block:: sh
   

    $ ne 'null instanceof Object' 
    



let.scm
=======



if.scm
======


.. code-block:: sh
   

    $ ne 'true && "ok" || "no"' 
    


.. code-block:: sh
   

    $ perl -E 'say 1 ? "ok" : "no"'
    ok
    


.. code-block:: sh
   

    $ php -r 'if (1) {echo "true";}' 
    true


.. code-block:: sh
   

    $ sh -c 'if true  ; then echo '\''true'\''; else echo '\''false'\''; fi' 
    true
    


.. code-block:: sh
   

    $ sh -c 'if false ; then echo '\''true'\''; else echo '\''false'\''; fi' 
    false
    

Multi liners

.. code-block:: sh
   

    $ sh -c '
    if true; then
        echo '\''if'\'';
    elif false; then 
        echo '\''elif'\'';
    else
        echo '\''else'\'';
    fi
    ' 
    if
    


.. code-block:: sh
   

    $ sh -c '
    if false; then
        echo '\''if'\'';
    elif true; then 
        echo '\''elif'\'';
    else
        echo '\''else'\'';
    fi
    ' 
    elif
    


.. code-block:: sh
   

    $ sh -c '
    if false; then
        echo '\''if'\'';
    elif false; then 
        echo '\''elif'\'';
    else
        echo '\''else'\'';
    fi
    ' 
    else
    



using var
=========


.. code-block:: sh
   

    $ sh -c 'A=true && if $A ; then echo true; fi' 
    true
    


.. code-block:: sh
   

    $ sh -c 'A=true && $A && echo true' 
    true
    


.. code-block:: sh
   

    $ sh -c 'A=false && if $A ; then echo true; fi' 
    


.. code-block:: sh
   

    $ sh -c '$A && echo true' 
    true
    

# With test, [ ] or [[ ]] operators,
bash conditions evaluate as true in case of an exit code of 0

.. code-block:: sh
   

    $ sh -c 'if [ 0 ] ; then echo true; fi' 
    true
    


.. code-block:: sh
   

    $ sh -c 'if [ $(echo 0) ] ; then echo true; fi' 
    true
    


.. code-block:: sh
   

    $ sh -c 'if [ -z "" ] ; then echo true; fi' 
    true
    



apply.scm
=========


.. code-block:: sh
   

    $ ne 'Math.min.apply(null, [1,2,-1,3])' 
    



case.scm
========


.. code-block:: sh
   

    $ sh -c 'case '\''apple'\'' in a*) echo '\''starts with a'\'';; esac' 
    starts with a
    


.. code-block:: sh
   

    $ sh -c 'case '\''apple'\'' in a*) echo '\''starts with a'\'';; esac' 
    starts with a
    

? is any one char

.. code-block:: sh
   

    $ sh -c 'case '\''Xapple'\'' in ?a*) echo '\''starts with a'\'';; esac' 
    starts with a
    


.. code-block:: sh
   

    $ sh -c 'case '\'''\'' in '\'''\'') echo '\''empty string'\'';; esac' 
    empty string
    


.. code-block:: sh
   

    $ sh -c 'case '\''banana'\'' in apple|banana) echo '\''I want banana'\'';; esac' 
    I want banana
    

