
=====
regex
=====



name.scm
========


.. code-block:: sh
   

    $ perl -E '$_=shift; say qq/$+{name}/ if /(?P<name>a)/ ' a
    a
    


.. code-block:: sh
   

    $ perl -E '$_=shift; say if /(?P<name>a)bg{name}/ ' aba
    


.. code-block:: sh
   

    $ perl -E '$_=shift; say if /(?P<name>a)b(?P=name)/ ' aba
    aba
    


.. code-block:: sh
   

    $ python -c "import re; print(re.match(r'(?P<name>a)b(?P=name)', 'aba').group())"
    aba
    



pos.scm
=======

$-[]マッチ開始位置かな, $+[]マッチ終了位置. /path/to => /path/to/

.. code-block:: sh
   

    $ perl -E '$_=shift; m#<a.*?href=(["''])(.*?)1.*?>#; $a=$2; substr($_, $-[2], $+[2] - $-[2]) = $a."/"; say' "<a href='/path/to'>"
    /<a href='/path/to'>
    



dotall.scm
==========


.. code-block:: sh
   

    $ python -c 'import re; print(re.match(r".", "
    ", re.DOTALL))'
      File "<string>", line 1
        import re; print(re.match(r".", "
                                        ^
    SyntaxError: EOL while scanning string literal
    

. matches also dot character

.. code-block:: sh
   

    $ perl -E 'say q/./ =~ /./'
    1
    


.. warning::

     . doesn't match 
     character Ignore white words( 
    	) 


.. code-block:: sh
   

    $ perl -E 'say "
    " =~ /./'
    
    



group.scm
=========


.. code-block:: sh
   

    $ python -c 'import re; print(re.match(r'''(["''])abc1''', '''"abc"''').group())'
    Syntax error: "(" unexpected
    


.. code-block:: sh
   

    $ python -c 'import re; print(re.match(r"((((1)2)3)4)", "1234").groups())'
    ('1234', '123', '12', '1')
    


.. code-block:: sh
   

    $ perl -E '$_=shift; say if /(["''])abc1/ ' '"abc"'
    


.. code-block:: sh
   

    $ perl -E '$_=shift; say if /(["''])abcg1/ ' '"abc"'
    


.. code-block:: sh
   

    $ perl -E '$_=shift; say if /(["''])abcg{1}/ ' '"abc"'
    

順番は左から

.. code-block:: sh
   

    $ perl -E 'qq/1234/ =~ /((((1)2)3)4)/; say qq/$1 $2 $3 $4/'
    1234 123 12 1
    



sub.scm
=======


.. code-block:: sh
   

    $ zsh -c 'a='\''hoge'\''; echo ${a/ho/HO}' 
    HOge
    



word.scm
========



replace.scm
===========


.. code-block:: sh
   

    $ ne 'replace(/aaa/g, '\''bbb'\'');' 
    [eval]:7
    replace(/aaa/g, 'bbb');
    ^
    
    ReferenceError: replace is not defined
        at [eval]:7:1
        at Object.exports.runInThisContext (vm.js:54:17)
        at Object.<anonymous> ([eval]-wrapper:6:22)
        at Module._compile (module.js:435:26)
        at node.js:576:27
        at doNTCallback0 (node.js:417:9)
        at process._tickCallback (node.js:346:13)
    



greedy.scm
==========

remove if it's matched from the left side(greedy)

.. code-block:: sh
   

    $ zsh -c 'f=/home/usr/test.txt; echo ${f##*/}' 
    test.txt
    

remove if it's matched from the left side(non greedy)

.. code-block:: sh
   

    $ zsh -c 'f=/home/usr/test.txt; echo ${f#*/}' 
    home/usr/test.txt
    

remove if it's matched from the right side(greedy)

.. code-block:: sh
   

    $ zsh -c 'f=/home/usr/test.txt; echo ${f%%*/}' 
    /home/usr/test.txt
    

remove if it's matched from the right side(non greedy)

.. code-block:: sh
   

    $ zsh -c 'f=/home/usr/test.txt; echo ${f%*/}' 
    /home/usr/test.txt
    



after.scm
=========



noCapture.scm
=============

use : for no capture

.. code-block:: sh
   

    $ perl -E 'shift =~ /(a)(?:b)(c)/; say $1.$2' abc
    ac
    


.. code-block:: sh
   

    $ py 'P(match(r"(a)(?:b)(c)", "abc").groups())' 
    ('a', 'c')
    



lookbehind.scm
==============


.. warning::

    Variable length lookbehind not implemented in regex


.. code-block:: sh
   

    $ perl -E 'qq/test/ =~ m#(?<=.*?)e#'
    Variable length lookbehind not implemented in regex m/(?<=.*?)e/ at -e line 1.
    


.. code-block:: sh
   

    $ perl -E 'q/abcde/ =~ /(?<=.*?c).*/; say $&'
    Variable length lookbehind not implemented in regex m/(?<=.*?c).*/ at -e line 1.
    

You can subsutitute lookbind with K option

.. code-block:: sh
   

    $ perl -E 'q/abcde/ =~ /(.*?c)K.*/; say $&'
    
    



match.scm
=========


.. code-block:: sh
   

    $ ne ''\''ABCDEF'\''.match(/DEF/i)' 
    


.. code-block:: sh
   

    $ ne ''\''abc'\''.match(/a.c/)' 
    



findall.scm
===========



g.scm
=====



g
=

gは、全てマッチ
With g option it match more than once
マッチ位置はマッチするごとに動くので、loopできる
*は0文字とマッチするので空文字が含まれる


for
===


.. code-block:: sh
   

    $ perl -E '$_="abc"; print "$_," for (/.*?/g)'
    ,a,,b,,c,,


.. code-block:: sh
   

    $ perl -E '$_="abc"; print "$_," for /.+?/g'
    a,b,c,



while
=====

With s option . matches also 
 character

.. code-block:: sh
   

    $ perl -E '$_="abc"; while(/.(?=(.*))/g){print $&.$1.","}'
    abc,bc,c,


.. code-block:: sh
   

    $ perl -E 'say "
    " =~ /./s'
    1
    



lookahead.scm
=============

後に続く文字列が条件に合致した場合に、その手前にマッチさせる


whitespace.scm
==============


.. warning::

    Don't use -l option, which chomps "
    " , "
    " or ""


.. code-block:: sh
   

    $ perl -pE 's/
    /
    /' << EOS
    aaa
    bbb
    ccc
    EOS
    aaa
    bbb
    ccc
    

