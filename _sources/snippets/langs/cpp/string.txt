
======
string
======

.. contents::
    :depth: 2



string
======



Declare
=======


.. code-block:: sh
   

    $ cpe 'string s = "test"; P(s)'
    s = test
    


.. code-block:: sh
   

    $ cpe 'string s("test"); P(s)'
    s = test
    


.. code-block:: sh
   

    $ cpe 'char s[] = "test"; string t(s); P(t)'
    t = test
    

指定した文字で初期化します。

.. code-block:: sh
   

    $ cpe 'string s(5, '\''0'\''); P(s)'
    s = 00000
    



char
====


.. code-block:: sh
   

    $ cpe 'string s; s=char('\''A'\'' + 1); P(s)'
    s = B
    


.. code-block:: sh
   

    $ cpe 'string s; s='\''A'\''+1; P(s)'
    s = B
    


.. warning::

    cannot declare with char


.. code-block:: sh
   

    $ cpe 'string s='\''A'\''+1;'
    <stdin>:44:12: error: no viable conversion from 'int' to 'string' (aka 'basic_string<char, char_traits<char>, allocator<char> >')
        string s='A'+1;
               ^ ~~~~~
    /usr/include/c++/v1/string:1186:5: note: candidate constructor not viable: no known conversion from 'int' to 'const std::__1::basic_string<char> &' for 1st argument
        basic_string(const basic_string& __str);
        ^
    /usr/include/c++/v1/string:1190:5: note: candidate constructor not viable: no known conversion from 'int' to 'std::__1::basic_string<char> &&' for 1st argument
        basic_string(basic_string&& __str)
        ^
    /usr/include/c++/v1/string:1195:31: note: candidate constructor not viable: no known conversion from 'int' to 'const value_type *' (aka 'const char *') for 1st argument
        _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);
                                  ^
    /usr/include/c++/v1/string:1216:5: note: candidate constructor not viable: no known conversion from 'int' to 'initializer_list<value_type>' for 1st argument
        basic_string(initializer_list<value_type> __il);
        ^
    1 error generated.
    


.. code-block:: sh
   

    $ cpe 'string s="hoge"; P((s[0]-'\''0'\'')+(s[1]-'\''0'\'') == (s[0]+s[1]-2*'\''0'\''))'
    (s[0]-'0')+(s[1]-'0') == (s[0]+s[1]-2*'0') = 1
    



set!
====

一文字だけ書き換えることができます。

.. code-block:: sh
   

    $ cpe 'string s="abcdefg"; s[3]='\''z'\''; P(s)'
    s = abczefg
    



append
======


.. code-block:: sh
   

    $ cpe 'string s; for(char ch = '\''a'\''; ch <= '\''z'\''; ch++) s += ch; P(s)'
    s = abcdefghijklmnopqrstuvwxyz
    



substr
======


.. code-block:: sh
   

    $ cpe 'string s = "test"; string t(s,1,2); P(t)'
    t = es
    


.. code-block:: sh
   

    $ cpe 'string s = "test"; string t(s.begin()+1, s.begin()+2); P(t)'
    t = e
    


.. code-block:: sh
   

    $ cpe 'string s="abcdefghi"; P(s.substr(0, 5));'
    s.substr(0, 5) = abcde
    


.. code-block:: sh
   

    $ cpe 'string s="abcdefghi"; P(s.substr(5, 10));'
    s.substr(5, 10) = fghi
    


.. warning::

    開始位置が範囲外の場合は例外を出します。


.. code-block:: sh
   

    $ cpe 'string s="abcdefghi"; P(s.substr(10, 5));'
    s.substr(10, 5) = アボートトラップ
    


.. code-block:: sh
   

    $ cpe 'string s="abcdefghi"; P(s.substr(10, 1000));'
    s.substr(10, 1000) = アボートトラップ
    



辞書による比較が可能
==========


.. code-block:: sh
   

    $ cpe 'P("aaa" < "bbb")'
    "aaa" < "bbb" = 1
    


.. code-block:: sh
   

    $ cpe 'P("aaa" <= "aaa")'
    "aaa" <= "aaa" = 1
    


.. code-block:: sh
   

    $ cpe 'P("aaa" < "aab")'
    "aaa" < "aab" = 1
    


.. warning::

    長さが異なる場合は、なぜか短い方が大きいと判断される???


.. code-block:: sh
   

    $ cpe 'P("aaa" < "a")'
    "aaa" < "a" = 1
    



find
====


.. code-block:: sh
   

    $ cpe 'P(string::npos == -1)'
    string::npos == -1 = 1
    


.. code-block:: sh
   

    $ cpe 'string s = "this is a test."; P(s.find("is") != string::npos)'
    s.find("is") != string::npos = 1
    


.. code-block:: sh
   

    $ cpe 'string s = "this is a test."; P(s.find("IS") != string::npos)'
    s.find("IS") != string::npos = 0
    

char is also available

.. code-block:: sh
   

    $ cpe 'string s = "this is a test."; P(s.find('\''.'\'') != string::npos)'
    s.find('.') != string::npos = 1
    



count
=====


.. code-block:: sh
   

    $ cpe 'string s="abcaba"; P(count(s.begin(), s.end(), '\''a'\''));'
    count(s.begin(), s.end(), 'a') = 3
    

count up each charactor

.. code-block:: sh
   

    $ cpe 'vector<int>d('\''Z'\''-'\''A'\''+1,0); string s="AAABBC"; for(char c = s;c;c++) d[c-'\''A'\'']++; PE(d)'
    <stdin>:44:60: error: no viable conversion from 'string' (aka 'basic_string<char, char_traits<char>, allocator<char> >') to 'char'
        vector<int>d('Z'-'A'+1,0); string s="AAABBC"; for(char c = s;c;c++) d[c-'A']++; PE(d)
                                                               ^   ~
    1 error generated.
    



toString
========


.. code-block:: sh
   

    $ cpe 'std::ostringstream oss; oss << 12345; P(oss.str());'
    oss.str() = 12345
    

