
==================
coding
==================

.. contents::
    :depth: 2



comment.scm
=================================


不要だと思ったら、コメントアウトしておくこと。
そうすれば、どこからか参照されている場合はエラーがでる。

とくに、動的ではコンパイラが参照関係を実行前にチェックしないので、
不要コードを残しておくと、影響範囲が後から分かりにくくなる。

最後にまとめて削除すると、テスト後になってしまうので、二度手間となってしまう。



duck-typing.scm
=============================================


If it walks like a duck and quacks like a duck, it must be a duck.

javaのようにinterfaceを宣言しなくても、
同様のメソッドがあれば、同じような振る舞いを期待した実装をすること。
オブジェクト間に継承などの関係を一切もつ必要は無い。

読みやすい・安全ということではなく、柔軟であることが特徴


.. code-block:: py
   

    class Duck(object):
        def sound(self):
            print("quack")
    
    
    class Cat(object):
        def sound(self):
            print("myaa")
    
    
    def main():
        for animal in [Duck(), Cat()]:
            animal.sound()  # ここで同じメソッド名という理由だけで、soundの呼び分けができる
    
    if __name__ == "__main__":
        main()

.. code-block:: sh
   

    quack
    myaa
    



global.scm
==============================


ネストされた関数の内側で値が必要になることがある。
その場合の対応としては、

- 設定ファイルとして定義しておいて、値を読み出す。
  これは設定ファイルなので、変更されないことが前提

- クラスを用意して、そのメンバ変数にする

こうしないと、関数の引数に毎回、指定しないといけなくなるので、
冗長だし、変更に弱くなる。



if.scm
==================


if文は、正直ないほうが好ましい。

OOPではif文の代わりにクラスを用意する。
Haskellでは、型で分岐させる。
MVCでは、URLで分岐させる。

このようにして、入り口で分岐させておくのが良い。



import.scm
==============================


依存関係を緩く設定する
-----------------------
インポートするライブラリがないからといって、すぐにエラーにしなくてもよい。
なぜなら、必要最低限の機能にそのライブラリを必要としていないから。
その場合は、実行時に読み込むライブラリがなければエラーにすればよい。



index.scm
===========================

apply min to 3 args

.. code-block:: sh
   

    $ cpe 'int a=3,b=1,c=2; P(min(a,min(b,c)));' 
    min(a,min(b,c)) = 1
    



metaclass.scm
=======================================


metaclassはnewの挙動を変えたい時に使います。

ブジェクトの生成とは以下とします。

* allocation(クラスのメモリ割り当て)
* initialization(クラスの初期化)

オブジェクトの生成は、クッキーの型を作ること?



mixin.scm
===========================


インスタンス変数 (属性) を継承するスーパークラスはひとつだけに限定して、
あとのスーパークラスはメソッド (実装) だけを継承するという方法があります。
この方法を Mix-in といいます。(といっても、mixin側で属性を持つ例もある)

継承には2つの異なる概念が含まれています。
一つは、「どのようなメソッドを持っているか」
あるいは「どのように振る舞うか」ということに着目した「仕様の継承」

通常の継承は単一継承に限る

2つめ以降の継承は、Mix-inと呼ばれる抽象クラスからに限定する

Mix-inクラスは以下のような特徴を備えた抽象クラスです。

* 単独でインスタンスを作らない

* 通常のクラスから継承しない

interfaceの実装も共有したい場合の手段

MIX-IN
抽象クラス
__init__を定義しない
メンバ変数を使わない

インスタンス変数 (属性) を継承するスーパークラスはひとつだけに限定して、あとのスーパークラスはメソッド (実装) だけを継承するという方法があります。この方法を Mix-in といいます。

インターフェイスを統一するだけなのがjavaで、各実装はクラス毎です。
bridgeして実装を共有する手立てはある。



move.scm
========================

if文を使うと冗長になりやすい場合は、配列を使うと簡潔になる
左右上下に動く物体の遷移先を計算するときなどに使える

.. code-block:: cpp
   

    #include <myutils.h>
    void move(int *x, int *y, int d) {
     if (d == 0)
        *x += 1;
     else if (d == 1)
        *x -= 1;
     else if (d == 2)
        *y += 1;
     else
        *y -= 1;
    }
    int main() {
     int x=0,y=0;
     move(&x,&y,0);
     cout << x << ", " << y <<endl;
    }

.. code-block:: sh
   

    1, 0
    


.. code-block:: cpp
   

    #include <myutils.h>
    void move(int *x, int *y, int d) {
      int dx[] = {1, -1, 0,  0};
      int dy[] = {0,  0, 1, -1};
      *x += dx[d]; 
      *y += dy[d];
    }
    int main() {
     int x=0,y=0;
     move(&x,&y,0);
     cout << x << ", " << y <<endl;
    }

.. code-block:: sh
   

    1, 0
    

methodにして、関数名で分岐させるのが、読みやすい

.. code-block:: cpp
   

    #include <myutils.h>
    class O {
    private:
     int x,y;
    public:
     O() {this->x = this->y = 0;}
     void up() {this->x += 1;}  
     void down() {this->x -= 1;}  
     void left() {this->y += 1;}  
     void right() {this->y -= 1;}  
     friend ostream& operator<<(ostream& os, const O& o);
    };         
    ostream& operator<<(ostream& os, const O& o) {
     os << o.x << ", " << o.y;
     return os;
    }
    int main() {
     O o; o.up();
     cout << o <<endl;
    }

.. code-block:: sh
   

    1, 0
    



multi-thread.scm
================================================



null.scm
========================

pointerを受け取ったときはNULLチェックを忘れない
原則はじめにガードする

void t(node_t* node) {
  // node->value としていいのは、nodeがNULLでないことを確認した後
  if (node != NULL) {
    // この中では、node->valueと参照してよい
    // node->nextも同様
  }
}

void t2(node_t* node) {
  // node->next->value としていいのは、以下の条件
  if (node != NULL && node->next != NULL) {
    // この中では、node->next->valueと参照してよい
  }
}



oop.scm
=====================



isa
---------

A is a Bとは、AはBのサブクラス(Bが親, Aが子)であることをいう。(つまり継承)


has a
---------------


A has a Bとは、Aの属性にBがあることをいう。(包含関係A-)B)
このとき、AはBに機能を委譲している。またBは集約と呼ぶ。
一般的には、親がB, 子がAとなる。
継承したくない場合には、委譲をするのも一つの手段。

メリット
- 必要な親クラスのメソッドを選択的に使用できる。 (継承だと、全て公開される。)

デメリット
- 記述量が多くなる。(継承は明示しない)

以下の多重度を考慮する必要がある。

0..1  無しか一つ
1     確実に一つ
0..* または *   ゼロ個以上
1..* 1個以上

0ということは、親なしで子供が存在できることを意味する。



static method
---------------------------------------


- 属性の値を使用するものは、メソッドとして実装
- 属性の値を使用しないのであれば、静的なメソッドとして実装

pythonのstatic methodと通常関数の区別については、
サブクラスでオーバーライドしたい場合に、static methodを使用すると意図が明確になる

値を返さないメソッドは、副作用をもつ.
この副作用は、オブジェクトの属性に影響を与えるものになる(あるいはIOなどの処理)



difference between instance and object
------------------------------------------------------------------------------------------------------------------


An object is an instance of a class.

結論
どちらも同じものとみなして良さそう。



setter/getter
---------------------------------------


メリット
- setする前にバリデーションが可能
- get/setする前にログが可能
- set/get時の権限チェック
- 関数かすることで、引数に応じた処理が可能になり、柔軟性向上
- javaの慣習に従う
- カプセル化

デメット
- 単純なデータ構造には冗長すぎる
- 内部状態を渡すと、クラス外で状態が変更される危険性がある ::

     public class Store {
       private List<String> books = new ArrayList<String>();
       List<String> get_books(){
           return books;
       }
     }



AOP (Aspect Oriented Programming)
---------------------------------------------------------------------------------------------------

cross-cuttingするような機能を提供
ログなどを関数内に直接記述しないで、本体から分離するなど



OCP
---------


かいほうへいさげんそく(open/closed principle,OCP)とは、
オブジェクト指向プログラミングにおいて,クラス(およびその他のプログラム単位)は

- 拡張に対して開いて (open) いなければならず,
- 修正に対して閉じて (closed) いなければならない

という設計上の原則

つまり、あるクラスが一度コードレビューやユニットテストなどの品質検査を通過し実際の運用に入ったならば
そのクラスを修正してはならず、拡張によって対処しなければならない.


DIP
---------


依存関係逆転の原則（DIP:the Dependency Inversion Principle）

上位レイヤーは下位レイヤーを参照してはならない



データと実装の分離
---------------------------

データを決めてそれを処理する関数を実装します。
例えば、プログラムの設定は、外部ファイルに記述します。
プログラムの実行中に、その設定ファイルを読み込んで反映させます。


pointer.scm
=================================



値渡しと参照渡しの違い
---------------------------------


結論: 値渡しは低速だが安全で、 参照渡しは高速だが危険

値渡し
------
- データのコピーを渡す 
- 関数に値を渡すときのコピーの処理は、データが大きいほど遅くなる
- 呼び出し先でデータを書き換えても、呼び出し元も書き変わらない

参照渡し
--------
- c言語でいうpointer
- 関数に値を渡すときのコピーの処理は一定
- 呼び出し先でデータを書き換えると、呼び出し元も書きかわる



polymorphism.scm
================================================



stack.scm
===========================



unit.scm
========================


.. code-block:: py
   

    
    def show(n):
     sign = ''
     if n < 0:
      n *= -1
      sign = '-'
     def to_s(x, unit, label=''):
      return '%s%.1f%sB' % (sign, x / float(unit), label)
     for index, label in enumerate(['', 'K', 'M', 'G']):
      start = 10 ** (3 * index)
      end = start * (10 ** 3)
      if start <= n < end:
       return to_s(n, start, label)
     else:
      return to_s(n, 1)
    print(show(0))
    print(show(1))
    print(show(1440))
    print(show(-1440))
    print(show(1444))
    print(show(1444000))
    print(show(1444000 * 10 ** 3))
    print(show(1444000 * 10 ** 6))
    

.. code-block:: sh
   

    0.0B
    1.0B
    1.4KB
    -1.4KB
    1.4KB
    1.4MB
    1.4GB
    1444000000000.0B
    



write.scm
===========================



class = data + methods
------------------------------------------------------------------


オブジェクトは型、インスタンスは実体（変数などの値をもつもの）
構造体と、構造体変数みたいな関係です。

データの型を決める

obj.method(args)
(method obj args)

基本は、インスタンスの状態を決めるものを属性にする
何でもかんでも、アクセスしやすい変数として使うのではない.

