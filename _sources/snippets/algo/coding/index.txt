
==================
coding
==================

.. contents::
    :depth: 2



duck-typing.scm
=============================================


If it walks like a duck and quacks like a duck, it must be a duck.

javaのようにinterfaceを宣言しなくても、
同様のメソッドがあれば、同じような振る舞いを期待した実装をすること。
オブジェクト間に継承などの関係を一切もつ必要は無い。

読みやすい・安全ということではなく、柔軟であることが特徴


.. code-block:: py
   

    class Duck(object):
        def sound(self):
            print("quack")
    
    
    class Cat(object):
        def sound(self):
            print("myaa")
    
    
    def main():
        for animal in [Duck(), Cat()]:
            animal.sound()  # ここで同じメソッド名という理由だけで、soundの呼び分けができる
    
    if __name__ == "__main__":
        main()

.. code-block:: sh
   

    quack
    myaa
    



index.scm
===========================

apply min to 3 args

.. code-block:: sh
   

    $ cpe 'int a=3,b=1,c=2; P(min(a,min(b,c)));' 
    min(a,min(b,c)) = 1
    



move.scm
========================

if文を使うと冗長になりやすい場合は、配列を使うと簡潔になる
左右上下に動く物体の遷移先を計算するときなどに使える

.. code-block:: cpp
   

    #include <myutils.h>
    void move(int *x, int *y, int d) {
     if (d == 0)
        *x += 1;
     else if (d == 1)
        *x -= 1;
     else if (d == 2)
        *y += 1;
     else
        *y -= 1;
    }
    int main() {
     int x=0,y=0;
     move(&x,&y,0);
     cout << x << ", " << y <<endl;
    }

.. code-block:: sh
   

    1, 0
    


.. code-block:: cpp
   

    #include <myutils.h>
    void move(int *x, int *y, int d) {
      int dx[] = {1, -1, 0,  0};
      int dy[] = {0,  0, 1, -1};
      *x += dx[d]; 
      *y += dy[d];
    }
    int main() {
     int x=0,y=0;
     move(&x,&y,0);
     cout << x << ", " << y <<endl;
    }

.. code-block:: sh
   

    1, 0
    

methodにして、関数名で分岐させるのが、読みやすい

.. code-block:: cpp
   

    #include <myutils.h>
    class O {
    private:
     int x,y;
    public:
     O() {this->x = this->y = 0;}
     void up() {this->x += 1;}  
     void down() {this->x -= 1;}  
     void left() {this->y += 1;}  
     void right() {this->y -= 1;}  
     friend ostream& operator<<(ostream& os, const O& o);
    };         
    ostream& operator<<(ostream& os, const O& o) {
     os << o.x << ", " << o.y;
     return os;
    }
    int main() {
     O o; o.up();
     cout << o <<endl;
    }

.. code-block:: sh
   

    1, 0
    



oop.scm
=====================



isa
---------

A is a Bとは、AはBのサブクラス(Bが親, Aが子)であることをいう。(つまり継承)


has a
---------------


A has a Bとは、Aの属性にBがあることをいう。(包含関係A-)B)
このとき、AはBに機能を委譲している。またBは集約と呼ぶ。
一般的には、親がB, 子がAとなる。
継承したくない場合には、委譲をするのも一つの手段。

メリット
- 必要な親クラスのメソッドを選択的に使用できる。 (継承だと、全て公開される。)

デメリット
- 記述量が多くなる。(継承は明示しない)

以下の多重度を考慮する必要がある。

0..1  無しか一つ
1     確実に一つ
0..* または *   ゼロ個以上
1..* 1個以上

0ということは、親なしで子供が存在できることを意味する。



static method
---------------------------------------


- 属性の値を使用するものは、メソッドとして実装
- 属性の値を使用しないのであれば、静的なメソッドとして実装

pythonのstatic methodと通常関数の区別については、
サブクラスでオーバーライドしたい場合に、static methodを使用すると意図が明確になる

値を返さないメソッドは、副作用をもつ.
この副作用は、オブジェクトの属性に影響を与えるものになる(あるいはIOなどの処理)



polymorphism.scm
================================================



write.scm
===========================



class = data + methods
------------------------------------------------------------------


オブジェクトは型、インスタンスは実体（変数などの値をもつもの）
構造体と、構造体変数みたいな関係です。

データの型を決める

obj.method(args)
(method obj args)

基本は、インスタンスの状態を決めるものを属性にする
何でもかんでも、アクセスしやすい変数として使うのではない.

