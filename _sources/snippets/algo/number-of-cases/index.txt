
=============================================
number-of-cases
=============================================

.. contents::
    :depth: 2



accumulatedPermutaion.scm
===========================================================================

異なるn個の中から重複を許さずr個以下を取り出す場合の数(nPr (0 <= ALL r <= n))

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\P(n, 0) &=& \{ \phi \}
    \\P(0, r) &=& \phi
    \\P(n, r) &=& \{ a_n \} \cup P(n-1,r) \cup \{cons(a_n, x) \mid x \in P(n-1, r-1) \}
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    p :: [Int] -> Int -> [[Int]]
    p = go where
     go :: [Int] -> Int -> [[Int]]
     go _  0 = [[]]
     go [] r = []
     go (x:xs) r = [x] : (go xs r) ++ [x:ys | ys<-go xs (r-1)]
    main = print $ p [1,2,3] 3

.. code-block:: sh
   

    [[1],[2],[3],[2,3],[1,2],[1,3],[1,2,3],[1,2,3]]
    



all-subsets.scm
=============================================

べき乗
Xを集合とする。 Xの部分集合全体を2^xと表す
異なるn個の中で構成される全ての組み合わせ

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(0) &=& {\phi}
    \\f(n) &=& \{ {a_n} \cup x \mid x \in f(n-1) \} \cup f(n-1)
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\X      &=& \{1,2,3\} のとき
    \\2^X    &=& \{ \phi,\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{3,1\},\{1,2,3\}\ \}
    \\\# 2^X &=& 2^3 = {}_3 C _0 + {}_3 C _1 + {}_3 C _2 + {}_3 C _3 = 8
    \\(つまり、 \sum_{r=0}^n {}_n C _r = 2^n)
    \\
    \end{eqnarray}

一つ前の結果に、新しく要素を加えるか、加えないかで分けて考える.
f(x:xs)は、[[INT]]なので、xを使う場合とそうでない場合に分ける

.. code-block:: ghc
   

    
    comb :: (Num a) => [a] -> [[a]]
    comb = go where
      go []    = [[]]
      go (x:xs) = map (x:) (go xs) ++ go xs
    main = do
      print $ comb [1..3]
      print $ comb [1..5]
    

.. code-block:: sh
   

    [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
    [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,3,4,5],[1,3,4],[1,3,5],[1,3],[1,4,5],[1,4],[1,5],[1],[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
    



cartesian-product.scm
===============================================================

集合直積

.. math::
    :nowrap:

    \begin{eqnarray}
        \prod_{i=0}^n A_i
    \end{eqnarray}


.. code-block:: ghc
   

    f :: [[Int]] -> [[Int]]
    f = go where
     go [] = [[]]
     go (xs:xss) = [x:ys | x<-xs, ys<-go xss] 
    main = print $ f [[1,2], [3], [4,5,6]]

.. code-block:: sh
   

    [[1,3,4],[1,3,5],[1,3,6],[2,3,4],[2,3,5],[2,3,6]]
    



combination.scm
=============================================

異なるn個の中から重複を許さずr個取り出す場合の数(nCr)

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(n, 0) &=& \{\phi\}
    \\f(0, x) &=& \phi
    \\f(n, k) &=& \{ \{a_n\} \cup x \mid x \in f(n-1, k-1) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    comb :: (Num a) => [a] -> Int -> [[a]]
    comb = go where
      go _ 0      = [[]]  -- 先頭に記述すること
      go [] _     = []
      go (x:xs) n = (map (x:) $ go xs (n-1)) ++ go xs n
    main = do
      print $ comb [1..3] 2
      print $ comb [1..5] 4

.. code-block:: sh
   

    [[1,2],[1,3],[2,3]]
    [[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5],[2,3,4,5]]
    

結果を引数に保持する記述方法

.. code-block:: ghc
   

    comb :: (Num a) => [a] -> Int -> [[a]]
    comb = go [] where
      go acc _ 0      = [acc]  -- 先頭に記述すること
      go acc [] _     = []
      go acc (x:xs) n = go (x:acc) xs (n-1) ++ go acc xs n
    main = do
      print $ comb [1..3] 2
      print $ comb [1..5] 4

.. code-block:: sh
   

    [[2,1],[3,1],[3,2]]
    [[4,3,2,1],[5,3,2,1],[5,4,2,1],[5,4,3,1],[5,4,3,2]]
    



nC3(using loop)
---------------------------------------------


.. code-block:: cpp
   

    #include <myutils.h>
    void nC3(vector<int> N){
      int size = N.size();
      for (int i = 0; i < size-2; i++){
        for (int j = i+1; j < size-1; j++){
          for (int k = j+1; k < size; k++){
            cout << N[i] << ", " << N[j] << ", " << N[k] << endl;
          }
        }
      }
    }
    int main() { nC3({1,2,3,4,5}); }

.. code-block:: sh
   

    1, 2, 3
    1, 2, 4
    1, 2, 5
    1, 3, 4
    1, 3, 5
    1, 4, 5
    2, 3, 4
    2, 3, 5
    2, 4, 5
    3, 4, 5
    



nCr
---------


.. warning::

    be careful of overflow


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\{}_n C _0 &=& 1
    \\{}_n C _n &=& 1
    \\{}_n C _r &=& {}_{n-1} C _r + {}_{n-1} C _{r-1}
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    
    comb :: (Integral a) => a -> a -> a
    comb n r
      | r == 0 || n == r = 1
      | 0 <= r && r <= n = comb (n-1) r + comb (n-1) (r-1)
    main = print $ comb 5 2
    

.. code-block:: sh
   

    10
    



next-permutaion.scm
=========================================================



permutation.scm
=============================================

異なるn個の中から、r個並べる場合の数(nPr)

.. warning::

    n!は大きな数になりやすいのでdoubleを使って極力桁溢れしないように工夫する。


.. code-block:: ghc
   

    -- [1,2,3] => [(1, [2,3]), (2, [1,3]), (3, [1,2])] のように分割
    -- repeatedPermutation.hsとの違いは、使った要素を使用しないようにするところ
    split = go [] where
      go acc []     = []
      go acc (x:xs) = [(x, acc++xs)] ++ go (acc++[x]) xs
    permutation :: (Num a, Eq a) => [a] -> Int -> [[a]]
    permutation = go [] where
      go acc _ 0  = [acc]
      go acc [] _ = []  -- fail
      go acc xs n = concatMap (\(y, ys) -> go (y:acc) ys (n-1)) $ split xs
    main = print $ length $ permutation [1..5] 3  -- 60

.. code-block:: sh
   

    60
    


.. code-block:: cpp
   

    #include <myutils.h>
    template<class T> inline
    void extend(T &a, T &b) {
      a.insert(a.end(), b.begin(), b.end());
    }
    vector<vector<int>> comb (vector<int> vec, int num) {
      function <vector<vector<int>>(int, int, vector<int>)>iter = [&](int index, int n, vector<int> acc) {
        if (n == 0)
          return vector<vector<int>>(1, acc);
        if (index == vec.size())
          return vector<vector<int>>();
        vector<vector<int>> vs;
        vector<int> copy = acc;
        copy.push_back(vec[index]);
        vector<vector<int>> tmp = iter(index + 1, n - 1, copy);
        extend(vs, tmp);
        tmp = iter(index + 1, n, acc);
        extend(vs, tmp);
        return vs;
      };
      return iter(0, num, vector<int>());
    }
    int main() {
      vector<vector<int>> vs = comb({1,2,3,4}, 2);
      PE2(vs);
    }

.. code-block:: sh
   

    1, 2, 
    1, 3, 
    1, 4, 
    2, 3, 
    2, 4, 
    3, 4, 
    



nPn = n!
------------------------


.. code-block:: cpp
   

    #include <myutils.h>
    inline void swap(vector<int> &v, int a, int b) { int t=v[a]; v[a]=v[b]; v[b]=t; }
    void N (vector<int> vec) {
      function <void(vector<int>, int)>iter = [&](vector<int> v, int n) {
        if (n == vec.size()) {
          PE(v);
          return;
        }
        for(int i = n; i < v.size(); i++) {
          swap(v, i, n);
          iter(v, n + 1);
          swap(v, n, i);
        }
      };
      return iter(vec, 0);
    }
    int main() {
      N({1,2,3,4});
    }

.. code-block:: sh
   

    1, 2, 3, 4, 
    1, 2, 4, 3, 
    1, 3, 2, 4, 
    1, 3, 4, 2, 
    1, 4, 3, 2, 
    1, 4, 2, 3, 
    2, 1, 3, 4, 
    2, 1, 4, 3, 
    2, 3, 1, 4, 
    2, 3, 4, 1, 
    2, 4, 3, 1, 
    2, 4, 1, 3, 
    3, 2, 1, 4, 
    3, 2, 4, 1, 
    3, 1, 2, 4, 
    3, 1, 4, 2, 
    3, 4, 1, 2, 
    3, 4, 2, 1, 
    4, 2, 3, 1, 
    4, 2, 1, 3, 
    4, 3, 2, 1, 
    4, 3, 1, 2, 
    4, 1, 3, 2, 
    4, 1, 2, 3, 
    



repeatedCombination.scm
=====================================================================

異なるn個の中から重複を許してr個取り出す場合の数(nHr)
同じものを使い続けるか、それを使わずに次へいくか
combinationとの違いは、使用しても消費しない

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\H(n, 0) &=& \{ \phi \}
    \\H(0, r) &=& \phi
    \\H(n, r) &=& \{ \{a_n\} \cup x \mid x \in H(n, r-1) \} \cup H(n-1, r)
    \\
    \end{eqnarray}

.. todo:: accを使っているが、末尾再帰の形式になっていなにので遅い(loop版作れる？)

.. code-block:: ghc
   

    
    h = go where
      go xs 0 = [[]]
      go [] _ = []
      go (x:xs) n = [x:ys | ys<-go (x:xs) (n-1)] ++ go xs n
    main = print $ h [1..3] 2
    

.. code-block:: sh
   

    [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
    



nHr
---------


.. math::
    :nowrap:

    \begin{eqnarray}
         {}_n H _r = {}_{n+r-1} C _r
    \end{eqnarray}

n個のボールをr-1個の棒で仕切る並べ方に一致


repeatedPermutation.scm
=====================================================================

異なるn個の中から重複を許してr個取り出す場合の数(nPIr)
permutaionとの違いは、使用しても消費しない

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\PI(n, 0) &=& \{ \phi \}
    \\PI(n, r) &=& \{cons(a_i, x) \mid x \in PI(n, r-1), 1 \le i \le n \}
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    p :: (Num a) => [a] -> Int -> [[a]]
    p = go where
      go xs 0 = [[]]
      go xs n = [x:ys | x<-xs, ys<-go xs (n-1)]
    main = print $ p [1..4] 2

.. code-block:: sh
   

    [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,1],[4,2],[4,3],[4,4]]
    

