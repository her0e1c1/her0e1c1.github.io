
=============================================
number-of-cases
=============================================

.. contents::
    :depth: 2



all-subsets.scm
=============================================

べき乗
Xを集合とする。 Xの部分集合全体を2^xと表す

異なるn個の中で構成される全ての組み合わせ


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(\{ a_0 \}) = {\phi}
    \\f(\{ a_n \}) = \{ {a_n} \cup x \| x \in g \} \cup g
    \\g = f(\{ a_{n-1} \})
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\X = \{1,2,3\} のとき
    \\2^X = \{\phi,{1},{2},{3},{1,2},{2,3},{3,1},{1,2,3}\}
    \\\# 2^X = 2^3 = 3_C_0 + 3_C_1 + 3_C_2 + 3_C_3 = 8
    \\(つまり、 \sum_r^n n_C_r = 2^n)
    \\
    \end{eqnarray}

一つ前の結果に、新しく要素を加えるか、加えないかで分けて考える
f(x:xs)は、[[INT]]なので、xを使う場合とそうでない場合に分ける

.. code-block:: ghc
   

    comb :: (Num a) => [a] -> [[a]]
    comb = go where
      go []    = [[]]
      go (x:xs) = map (x:) (go xs) ++ go xs
    main = do
      print $ comb [1..3]
      print $ comb [1..5]

.. code-block:: sh
   

    [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
    [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,3,4,5],[1,3,4],[1,3,5],[1,3],[1,4,5],[1,4],[1,5],[1],[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
    


.. code-block:: cpp
   

    #include "myutils.h"
    vector<vector<int>> comb(vector<int>& set, int index) {
      if (set.size() == index) {
        return vector<vector<int>>(1, vector<int>());
      }
      vector<vector<int>> r;
      auto q = comb(set, index + 1);
      for (auto x: q)
        r.push_back(x);
      int a = set[index];
      for (auto x: q) {
        x.push_back(a);
        r.push_back(x);
      }
      return r;
    }
    int main() {
      vector<int> x = {1,2,3};
      vector<vector<int>> xs = comb(x, 0);
      REP(i, xs.size()){
        REP(j, xs[i].size())
          cout << xs[i][j] << ", ";
        cout << endl;
      }
    }

.. code-block:: sh
   

    
    3, 
    2, 
    3, 2, 
    1, 
    3, 1, 
    2, 1, 
    3, 2, 1, 
    



cartesian-product.scm
===============================================================

集合直積

.. math::
    :nowrap:

    \begin{eqnarray}
        \prod_{i=0}^n A_i
    \end{eqnarray}


.. code-block:: ghc
   

    f :: [[Int]] -> [[Int]]
    f = go where
     go [] = [[]]
     go (xs:xss) = [x:ys | x<-xs, ys<-go xss] 
    main = print $ f [[1,2], [3], [4,5,6]]

.. code-block:: sh
   

    [[1,3,4],[1,3,5],[1,3,6],[2,3,4],[2,3,5],[2,3,6]]
    



combination.scm
=============================================

異なるn個の中から重複を許さずr個取り出す場合の数(nCr)

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(\{a_n\}, 0) = \{\phi\}
    \\f(\phi, x) = \phi
    \\f(\{a_n\}, k) = \{{a_n} \cup x \| x \in f(\{a_{n-1}, k-1\}) \} \cup f(\{a_{n-1}\}, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    comb :: (Num a) => [a] -> Int -> [[a]]
    comb = go where
      go _ 0      = [[]]  -- 先頭に記述すること
      go [] _     = []
      go (x:xs) n = (map (x:) $ go xs (n-1)) ++ go xs n
    main = do
      print $ comb [1..3] 2
      print $ comb [1..5] 4

.. code-block:: sh
   

    [[1,2],[1,3],[2,3]]
    [[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5],[2,3,4,5]]
    

結果を引数に保持する記述方法

.. code-block:: ghc
   

    comb :: (Num a) => [a] -> Int -> [[a]]
    comb = go [] where
      go acc _ 0      = [acc]  -- 先頭に記述すること
      go acc [] _     = []
      go acc (x:xs) n = go (x:acc) xs (n-1) ++ go acc xs n
      -- 以下がrepeatedPermutation.hs
      -- go acc (x:xs) n = go (x:acc) (x:xs) (n-1) ++ go acc xs n
    main = do
      print $ comb [1..3] 2
      print $ comb [1..5] 4

.. code-block:: sh
   

    [[2,1],[3,1],[3,2]]
    [[4,3,2,1],[5,3,2,1],[5,4,2,1],[5,4,3,1],[5,4,3,2]]
    



nC3(using loop)
---------------------------------------------


.. code-block:: cpp
   

    #include <myutils.h>
    void nC3(vector<int> N){
      int size = N.size();
      for (int i = 0; i < size-2; i++){
        for (int j = i+1; j < size-1; j++){
          for (int k = j+1; k < size; k++){
            cout << N[i] << ", " << N[j] << ", " << N[k] << endl;
          }
        }
      }
    }
    int main() {
    }

.. code-block:: sh
   

    



nCr
---------


.. code-block:: ghc
   

    combination :: (Integral a) => a -> a -> a
    combination n r
      | r == 0 || n == r = 1
      | 0 <= r && r <= n = combination (n-1) r + combination (n-1) (r-1)
      | otherwise = error "bad args"
    main = print $ combination 5 2

.. code-block:: sh
   

    10
    



next-permutaion.scm
=========================================================



permutation.scm
=============================================

異なるn個の中から、r個並べる場合の数(nPr)

.. code-block:: ghc
   

    -- [1,2,3] => [(1, [2,3]), (2, [1,3]), (3, [1,2])] のように分割
    -- repeatedPermutation.hsとの違いは、使った要素を使用しないようにするところ
    split = go [] where
      go acc []     = []
      go acc (x:xs) = [(x, acc++xs)] ++ go (acc++[x]) xs
    permutation :: (Num a, Eq a) => [a] -> Int -> [[a]]
    permutation = go [] where
      go acc _ 0  = [acc]
      go acc [] _ = []  -- fail
      go acc xs n = concatMap (\(y, ys) -> go (y:acc) ys (n-1)) $ split xs
    main = print $ length $ permutation [1..5] 3  -- 60

.. code-block:: sh
   

    60
    


.. code-block:: cpp
   

    #include <myutils.h>
    template<class T> inline
    void extend(T &a, T &b) {
      a.insert(a.end(), b.begin(), b.end());
    }
    vector<vector<int>> comb (vector<int> vec, int num) {
      function <vector<vector<int>>(int, int, vector<int>)>iter = [&](int index, int n, vector<int> acc) {
        if (n == 0)
          return vector<vector<int>>(1, acc);
        if (index == vec.size())
          return vector<vector<int>>();
        vector<vector<int>> vs;
        vector<int> copy = acc;
        copy.push_back(vec[index]);
        vector<vector<int>> tmp = iter(index + 1, n - 1, copy);
        extend(vs, tmp);
        tmp = iter(index + 1, n, acc);
        extend(vs, tmp);
        return vs;
      };
      return iter(0, num, vector<int>());
    }
    int main() {
      vector<vector<int>> vs = comb({1,2,3,4}, 2);
      PE2(vs);
    }

.. code-block:: sh
   

    1, 2, 
    1, 3, 
    1, 4, 
    2, 3, 
    2, 4, 
    3, 4, 
    



nPn = n!
------------------------


.. code-block:: cpp
   

    #include <myutils.h>
    inline void swap(vector<int> &v, int a, int b) { int t=v[a]; v[a]=v[b]; v[b]=t; }
    void N (vector<int> vec) {
      function <void(vector<int>, int)>iter = [&](vector<int> v, int n) {
        if (n == vec.size()) {
          PE(v);
          return;
        }
        for(int i = n; i < v.size(); i++) {
          swap(v, i, n);
          iter(v, n + 1);
          swap(v, n, i);
        }
      };
      return iter(vec, 0);
    }
    int main() {
      N({1,2,3,4});
    }

.. code-block:: sh
   

    1, 2, 3, 4, 
    1, 2, 4, 3, 
    1, 3, 2, 4, 
    1, 3, 4, 2, 
    1, 4, 3, 2, 
    1, 4, 2, 3, 
    2, 1, 3, 4, 
    2, 1, 4, 3, 
    2, 3, 1, 4, 
    2, 3, 4, 1, 
    2, 4, 3, 1, 
    2, 4, 1, 3, 
    3, 2, 1, 4, 
    3, 2, 4, 1, 
    3, 1, 2, 4, 
    3, 1, 4, 2, 
    3, 4, 1, 2, 
    3, 4, 2, 1, 
    4, 2, 3, 1, 
    4, 2, 1, 3, 
    4, 3, 2, 1, 
    4, 3, 1, 2, 
    4, 1, 3, 2, 
    4, 1, 2, 3, 
    

