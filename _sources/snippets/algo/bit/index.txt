
=========
bit
=========

.. contents::
    :depth: 2



bit.scm
=====================


マイナスの表現
---------------

::

   NUM = a1b

とおく。
bは全て0とするので、1が一番最後の桁となる

2の補数表現を使うと ::

   -NUM = (a1b)~ + 1

とおける。

チルダ演算子は、それぞれのbitを反転させるだけなので ::

   -NUM = a~0b~ + 1

bは全て0なので反転させると全て1 ::

   -NUM = a~0(111...1) + 1 = a~1(000...0) = a~1b

よって ::

   -NUM = a~1b


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = \frac2x
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x:x<<1; P(f(10))' 
    20
    


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = \frac{1}{2}x
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x:x>>1; P(f(10))' 
    5
    


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = 2^x
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x:1<<x; P(f(10))' 
    1024
    



check whether a number is even or odd
---------------------------------------------------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = \begin{cases} 1 (if x is odd)
    \\0 (else) \end{cases}
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x: x & 1; P(f(11))' 
    1
    



Check power of 2
------------------------------------------------

2の累乗数は、10...00で表せる。そこから1引いた数は11..11となる。そのため２つの&は常に0

.. code-block:: sh
   

    $ py 'f=lambda x: (x & (x-1)) == 0; P(f(16))' 
    True
    



complement.scm
==========================================


例::

    1 = 0b00000001
   -1 = 0b11111111

この二つの関係より2の補数は::

    NUM = (NUM)~ + 1

という関係性がすぐ思い出せる。

0の場合も当てはまる ::

    0b0000 = (0b1111) + 1

What's Two Compliment?
1の補数+1
a => ~a + 1
符号が入れ替わる
a + (~a + 1) = 0

What's One Compliment?
すべてのbitを判定したもの
a + ~a = -1

