
============
math
============

.. contents::
    :depth: 2



bit.scm
=====================


マイナスの表現
---------------

::

   NUM = a1b

とおく。
bは全て0とするので、1が一番最後の桁となる

2の補数表現を使うと ::

   -NUM = (a1b)~ + 1

とおける。

チルダ演算子は、それぞれのbitを反転させるだけなので ::

   -NUM = a~0b~ + 1

bは全て0なので反転させると全て1 ::

   -NUM = a~0(111...1) + 1 = a~1(000...0) = a~1b

よって ::

   -NUM = a~1b



formula.scm
=================================



配列の３つの積の最大値は?
---------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \max_{i,j,k \in N} a[i] \times a[j] \times a[k]
    \end{eqnarray}


.. code-block:: gosh
   

    (print
        (let1 l (pa$ at (sort '(3 -7 4 6 3 -1 -5 -5 3 2)))
           (max (* (l -1) (l -2) (l -3))
                (* (l 0) (l 1) (l -1)))))

.. code-block:: sh
   

    210
    



特定の区間にある整数
------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i \leqq B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (+ (- B A) 1))) (f 3 9))' 
    7
    


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A < i < B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (+ (- B A) -1))) (f 3 9))' 
    5
    


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A < i \leqq B \}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i < B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (- B A))) (f 3 9))' 
    6
    



特定の区間にあるKの倍数の数
------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i \leqq B, i \bmod K = 0 \}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\A = Km + n \leqq & i = K*j & \leqq B = Km' + n' & <=>
    \\m + n/K    \leqq & j   & \leqq m' + n'/K
    \\
    \\以下を考慮
    \\0 \leqq & n/K, n'/K & < 1
    \\
    \\Kの倍数から整数に帰着
    \\m \leqq & j & \leqq m' & (n/K = 0)
    \\m <     & j & \leqq m' & (else)
    \\
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B K) (+ (- (div B K) (div A K)) (if (= (mod A K) 0) 1 0))) (f 3 10 3))' 
    3
    



不等式の最小値
---------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        min_{x in Z, a>0, b>0 in N} x >= a/b
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\min x =
    \\\begin{cases}
    \\ [a/b]     & (a \bmod b = 0)
    \\ [a/b] + 1 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (a b) (if (= (mod a b) 0) (div a b) (+ (div a b) 1))) (f 8 2))' 
    4
    


.. code-block:: sh
   

    $ s '(let1 f (^ (a b) (if (= (mod a b) 0) (div a b) (+ (div a b) 1))) (f 8 3))' 
    3
    



２分割した数列の差の最小値
---------------------------------------

計算量をO(n^2) => O(n)に減らすことができる。微分みたいに、差を使うことで次元を下げるのに似ている。
TapeEquilibrium (必ず２つに分ける必要がある場合、1<= x <= N-1とする必要あり)

.. math::
    :nowrap:

    \begin{eqnarray}
        S_N_x = \sum_{i=x+1}^{N} ai - \sum_{i=1}^{x} ai  s.t  \min_{x} | S_N_x |
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\S_N_0 & = & a_N + a_{N-1} + ... + a_2 + a_1
    \\S_N_1 & = & a_N + a_{N-1} + ... + a_2 - a_1
    \\S_N_2 & = & a_N + a_{N-1} + ... - a_2 - a_1
    \\...
    \\S_N_x     & = & a_N + a_{N-1} + ... + a_{x+1} - a_x ... - a_2 - a_1
    \\S_N_{x+1} & = & a_N + a_{N-1} + ... - a_{x+1} - a_x ... - a_2 - a_1
    \\...
    \\S_N_{N-1} & = & a_N - a_{N-1} + ... - a_2 - a_1
    \\S_N_N     & = & - a_N - a_{N-1} + ... - a_2 - a_1
    \\
    \\よって、２項間の差は以下のとおり
    \\S_N_{x+1} - S_N_x & = & - 2 a_{x+1} 
    \\
    \\S_N_0から始めて-2 a_xを追加していき、その絶対値をとり、最大値を探す。
    \\S_N_0の和を求めるのと、S_N_0からS_N_Nまでの探索で、計算量はO(2N)となる。
    \\
    \end{eqnarray}


.. code-block:: c
   

    
    #include <myc.h>
    int abs(int x) {return x < 0 ? -x : x;}
    int solution(int *a, int N) {
      int sum = 0;
      for (int i = 0; i < N; i++) sum += a[i];
      int ms = abs(sum);
      for (int i = 0; i < N; i++) {
       sum -= 2 * a[i];
       int s0 = abs(sum);
       if (s0 < ms)
        ms = s0;
     }
     return ms;
    }
    int main() {
     int a[] = {3,1,2,4,3};  // ans=1
     printf("%d", solution(a, SIZE(a))); 
    }
    

.. code-block:: sh
   

    1



gauss.scm
===========================



Gauss == floor
------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \lfloor x \rfloor \leqq x < \lfloor x \rfloor + 1
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        x-1 < [x] \leqq x
    \end{eqnarray}



mod.scm
=====================

