
============
math
============

.. contents::
    :depth: 2



ack.scm
=====================


.. code-block:: gosh
   

    (define (ack m n)
      (cond ((= m 0) (+ n 1))
            ((= n 0) (ack (- m 1) 1))
            (else (ack (- m 1) (ack m (- n 1))))))
    
    (print (ack 1 1))  ; 3
    (print (ack 2 2))  ; 7
    (print (ack 3 3))  ; 61
    (print (ack 3 4))  ; 125

.. code-block:: sh
   

    3
    7
    61
    125
    



bit.scm
=====================


マイナスの表現
---------------

::

   NUM = a1b

とおく。
bは全て0とするので、1が一番最後の桁となる

2の補数表現を使うと ::

   -NUM = (a1b)~ + 1

とおける。

チルダ演算子は、それぞれのbitを反転させるだけなので ::

   -NUM = a~0b~ + 1

bは全て0なので反転させると全て1 ::

   -NUM = a~0(111...1) + 1 = a~1(000...0) = a~1b

よって ::

   -NUM = a~1b


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = \frac2x
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x:x<<1; P(f(10))' 
    20
    


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = \frac{1}{2}x
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x:x>>1; P(f(10))' 
    5
    


.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = 2^x
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x:1<<x; P(f(10))' 
    1024
    

check whether a number is even or odd

.. math::
    :nowrap:

    \begin{eqnarray}
        f(x) = \begin{cases} 1 (if x is odd)
    \\0 (else) \end{cases}
    \end{eqnarray}


.. code-block:: sh
   

    $ py 'f=lambda x: x & 1; P(f(11))' 
    1
    



exponetion.scm
==========================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\a^n = \begin{cases}
    \\ 1 & ({n = 0)
    \\ a^{n/2} * a^{n/2} & (\text{n is even})
    \\ a^{(n-1)/2} * a^{(n-1)/2} * a & (\text{n is odd})
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: cpp
   

    #include <myutils.h>
    int f(int a, int n) {
     if (n == 0)
      return 1;
     else if (n % 2 == 0) {
      int x = f(a, n / 2);
      return x * x;
     } else {
      int x = f(a, (n - 1) / 2);
      return x * x * a;
     }
    }
    int main() {
     P(f(2, 10));
     P(f(3, 2));
     P(f(4, 3));
    }

.. code-block:: sh
   

    f(2, 10) = 1024
    f(3, 2) = 9
    f(4, 3) = 64
    



formula.scm
=================================



配列の３つの積の最大値は?
---------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \max_{i,j,k \in N} a[i] \times a[j] \times a[k]
    \end{eqnarray}


.. code-block:: gosh
   

    (print
        (let1 l (pa$ at (sort '(2 8 4 7 -8 -5 -4 6 4 4)))
           (max (* (l -1) (l -2) (l -3))
                (* (l 0) (l 1) (l -1)))))

.. code-block:: sh
   

    336
    



特定の区間にある整数
------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i \leqq B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (+ (- B A) 1))) (f 3 9))' 
    7
    


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A < i < B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (+ (- B A) -1))) (f 3 9))' 
    5
    


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A < i \leqq B \}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i < B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (- B A))) (f 3 9))' 
    6
    



特定の区間にあるKの倍数の数
------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i \leqq B, i \bmod K = 0 \}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\A = Km + n \leqq & i = K*j & \leqq B = Km' + n' & <=>
    \\m + n/K    \leqq & j   & \leqq m' + n'/K
    \\
    \\以下を考慮
    \\0 \leqq & n/K, n'/K & < 1
    \\
    \\Kの倍数から整数に帰着
    \\m \leqq & j & \leqq m' & (n/K = 0)
    \\m <     & j & \leqq m' & (else)
    \\
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B K) (+ (- (div B K) (div A K)) (if (= (mod A K) 0) 1 0))) (f 3 10 3))' 
    3
    



不等式の最小値
---------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \min_{x \in Z, a>0, b>0 \in N} x >= a/b
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\min_x = \begin{cases}
    \\ [a/b]     & (a \bmod b = 0)
    \\ [a/b] + 1 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (a b) (if (= (mod a b) 0) (div a b) (+ (div a b) 1))) (f 8 2))' 
    4
    


.. code-block:: sh
   

    $ s '(let1 f (^ (a b) (if (= (mod a b) 0) (div a b) (+ (div a b) 1))) (f 8 3))' 
    3
    



２分割した数列の差の最小値
---------------------------------------

計算量をO(n^2) => O(n)に減らすことができる。微分みたいに、差を使うことで次元を下げるのに似ている。
TapeEquilibrium (必ず２つに分ける必要がある場合、1<= x <= N-1とする必要あり)

.. math::
    :nowrap:

    \begin{eqnarray}
        S_{Nx} = \sum_{i=x+1}^{N} a_i - \sum_{i=1}^{x} a_i \quad \text{s.t.} \quad \min_{x} | S_{Nx} |
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\S_{N0} & = & a_N + a_{N-1} + ... + a_2 + a_1
    \\S_{N1} & = & a_N + a_{N-1} + ... + a_2 - a_1
    \\S_{N2} & = & a_N + a_{N-1} + ... - a_2 - a_1
    \\...
    \\S_{Nx}     & = & a_N + a_{N-1} + ... + a_{x+1} - a_x ... - a_2 - a_1
    \\S_{N(x+1)} & = & a_N + a_{N-1} + ... - a_{x+1} - a_x ... - a_2 - a_1
    \\...
    \\S_{N(N-1)} & = & a_N - a_{N-1} + ... - a_2 - a_1
    \\S_{NN}     & = & - a_N - a_{N-1} + ... - a_2 - a_1
    \\
    \\よって、２項間の差は以下のとおり
    \\S_{N(x+1)} - S_{Nx} & = & - 2 a_{x+1} 
    \\
    \\S_{N0}から始めて-2 a_xを追加していき、その絶対値をとり、最大値を探す。
    \\S_{N0}の和を求めるのと、S_{N0}からS_{NN}までの探索で、計算量はO(2N)となる。
    \\
    \end{eqnarray}


.. code-block:: c
   

    
    #include <myc.h>
    int abs(int x) {return x < 0 ? -x : x;}
    int solution(int *a, int N) {
      int sum = 0;
      for (int i = 0; i < N; i++) sum += a[i];
      int ms = abs(sum);
      for (int i = 0; i < N; i++) {
       sum -= 2 * a[i];
       int s0 = abs(sum);
       if (s0 < ms)
        ms = s0;
     }
     return ms;
    }
    int main() {
     int a[] = {3,1,2,4,3};  // ans=1
     printf("%d", solution(a, SIZE(a))); 
    }
    

.. code-block:: sh
   

    1



gauss.scm
===========================



Gauss == floor
------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        \lfloor x \rfloor \leqq x < \lfloor x \rfloor + 1
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        x-1 < [x] \leqq x
    \end{eqnarray}


問題::

 自然数N,Mと整数xがあり、M < N*xを満たしている。
 このとき、xの最小値をガウス記号を用いて求めよ。

解答::

 ガウスの定義により[M/N] <= M/N < [M/N]+1が成立する。
 よってM/N < xを満たす最小のxは[M/N]+1である。



mod.scm
=====================


`答えをMODして出せ`
という指示があれば、答えの途中でもMODして良いという意味です。
(数が大きくなりすぎない様にすることと、巡回するだけなので答えが一定になることが理由)

**Quotient** ::

 N = Q*M + R
 (0 <= R <= M - 1)

MODに関しても分配法則が成立::

 ans %= MOD
 ans = (ans + add) % MOD
 ans = ans % MOD + add % MOD

