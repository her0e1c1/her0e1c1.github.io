
============
math
============

.. contents::
    :depth: 2



ack.scm
=====================


.. code-block:: gosh
   

    (define (ack m n)
      (cond ((= m 0) (+ n 1))
            ((= n 0) (ack (- m 1) 1))
            (else (ack (- m 1) (ack m (- n 1))))))
    
    (print (ack 1 1))  ; 3
    (print (ack 2 2))  ; 7
    (print (ack 3 3))  ; 61
    (print (ack 3 4))  ; 125

.. code-block:: sh
   

    3
    7
    61
    125
    



eq1.scm
=====================

.. todo:: ???



.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\{a_1, a_2, ... a_k}, 1 \le k < i  \quad s.t. \quad 
    \\f(i) = \{ a_1, a_2, ... a_{k'} \} ( \ne \phi, a_{k'} > a_i  \quad s.t. \quad  \max k')
    \\f(i) = \{ a_i \} (else)
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(s, ai):
     while s:
      if s[-1] < ai:
       s.pop()
      else:
      return s
     else:
      return [ai]

.. code-block:: sh
   

      File "<stdin>", line 7
        return s
             ^
    IndentationError: expected an indented block
    



exponetion.scm
==========================================




.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\a^n = \begin{cases}
    \\ 1 & ({n = 0)
    \\ a^{n/2} \times a^{n/2} & (\mbox{n is even})
    \\ a^{(n-1)/2} \times a^{(n-1)/2} \times a & (\mbox{n is odd})
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: cpp
   

    #include <myutils.h>
    int f(int a, int n) {
     if (n == 0)
      return 1;
     else if (n % 2 == 0) {
      int x = f(a, n / 2);
      return x * x;
     } else {
      int x = f(a, (n - 1) / 2);
      return x * x * a;
     }
    }
    int main() {
     P(f(2, 10));
     P(f(3, 2));
     P(f(4, 3));
    }

.. code-block:: sh
   

    f(2, 10) = 1024
    f(3, 2) = 9
    f(4, 3) = 64
    



fib.scm
=====================




.. math::
    :nowrap:

    \begin{eqnarray}
        f(n+2) = f(n+1) + f(n)
    \end{eqnarray}

階段を1段、または2段で上がる場合の組み合わせ

- 1 + 1 + 1 + 1 + 1 = 5
- 2 + 1 + 1 + 1 = 5
- 2 + 2 + 1 = 5


.. warning::

    simple but slow


.. code-block:: ghc
   

    
    f n
     | n == 0 || n == 1 = n
     | otherwise        = f (n-1) + f (n-2)
    main = print $ f 10
    

.. code-block:: sh
   

    55
    


.. code-block:: cpp
   

    
    #include <myutils.h>
    int main() {
     int N = 10;
     vector<int> fib(N+1, 0);
     fib[1] = 1;
     for (int i = 0; i < N-1; i++) {
      fib[i+2] = fib[i+1] + fib[i];
     }
     P(fib[N]);
    }
    

.. code-block:: sh
   

    fib[N] = 55
    


.. code-block:: cpp
   

    
    // f(Sn, Sn-1, n) = f(Sn-1 + Sn-2, Sn-1, n-1) (n >= 2)
    // f(S1, S0, 1) = f(1, 0, 1)
    #include <myutils.h>
    int f(int N) {
     if (N == 0) return 0;
     int s1=1, s0=0;
     for (int i = 0; i < N-1; i++) {
      int t = s1;
      s1 = s1 + s0;
      s0 = t;
     }
     return s1;
    }
    int main() {
     P(f(10));
    }
    

.. code-block:: sh
   

    f(10) = 55
    



formula.scm
=================================



特定の区間にある整数
------------------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i \leqq B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (+ (- B A) 1))) (f 3 9))' 
    7
    




.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A < i < B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (+ (- B A) -1))) (f 3 9))' 
    5
    




.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A < i \leqq B \}
    \end{eqnarray}




.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i < B \}
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B) (if (>= A B) 0 (- B A))) (f 3 9))' 
    6
    



特定の区間にあるKの倍数の数
------------------------------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        \# \{i| A \leqq i \leqq B, i \bmod K = 0 \}
    \end{eqnarray}




.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\A = Km + n \leqq & i = K*j & \leqq B = Km' + n' & <=>
    \\m + n/K    \leqq & j   & \leqq m' + n'/K
    \\
    \\以下を考慮
    \\0 \leqq & n/K, n'/K & < 1
    \\
    \\Kの倍数から整数に帰着
    \\m \leqq & j & \leqq m' & (n/K = 0)
    \\m <     & j & \leqq m' & (else)
    \\
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (A B K) (+ (- (div B K) (div A K)) (if (= (mod A K) 0) 1 0))) (f 3 10 3))' 
    3
    



不等式の最小値
---------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        \min_{x \in Z, a>0, b>0 \in N} x >= a/b
    \end{eqnarray}




.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\min_x = \begin{cases}
    \\ [a/b]     & (a \bmod b = 0)
    \\ [a/b] + 1 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: sh
   

    $ s '(let1 f (^ (a b) (if (= (mod a b) 0) (div a b) (+ (div a b) 1))) (f 8 2))' 
    4
    


.. code-block:: sh
   

    $ s '(let1 f (^ (a b) (if (= (mod a b) 0) (div a b) (+ (div a b) 1))) (f 8 3))' 
    3
    



２分割した数列の差の最小値
---------------------------------------

計算量をO(n^2) => O(n)に減らすことができる。微分みたいに、差を使うことで次元を下げるのに似ている。
TapeEquilibrium (必ず２つに分ける必要がある場合、1<= x <= N-1とする必要あり)



.. math::
    :nowrap:

    \begin{eqnarray}
        S_{Nx} = \sum_{i=x+1}^{N} a_i - \sum_{i=1}^{x} a_i \quad \text{s.t.} \quad \min_{x} | S_{Nx} |
    \end{eqnarray}




.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\S_{N0} & = & a_N + a_{N-1} + ... + a_2 + a_1
    \\S_{N1} & = & a_N + a_{N-1} + ... + a_2 - a_1
    \\S_{N2} & = & a_N + a_{N-1} + ... - a_2 - a_1
    \\...
    \\S_{Nx}     & = & a_N + a_{N-1} + ... + a_{x+1} - a_x ... - a_2 - a_1
    \\S_{N(x+1)} & = & a_N + a_{N-1} + ... - a_{x+1} - a_x ... - a_2 - a_1
    \\...
    \\S_{N(N-1)} & = & a_N - a_{N-1} + ... - a_2 - a_1
    \\S_{NN}     & = & - a_N - a_{N-1} + ... - a_2 - a_1
    \\
    \\よって、２項間の差は以下のとおり
    \\S_{N(x+1)} - S_{Nx} & = & - 2 a_{x+1} 
    \\
    \\S_{N0}から始めて-2 a_xを追加していき、その絶対値をとり、最大値を探す。
    \\S_{N0}の和を求めるのと、S_{N0}からS_{NN}までの探索で、計算量はO(2N)となる。
    \\
    \end{eqnarray}


.. code-block:: c
   

    
    #include <myc.h>
    int abs(int x) {return x < 0 ? -x : x;}
    int solution(int *a, int N) {
      int sum = 0;
      for (int i = 0; i < N; i++) sum += a[i];
      int ms = abs(sum);
      for (int i = 0; i < N; i++) {
       sum -= 2 * a[i];
       int s0 = abs(sum);
       if (s0 < ms)
        ms = s0;
     }
     return ms;
    }
    int main() {
     int a[] = {3,1,2,4,3};  // ans=1
     printf("%d", solution(a, SIZE(a))); 
    }
    

.. code-block:: sh
   

    1



gauss.scm
===========================



Gauss == floor
------------------------------------------




.. math::
    :nowrap:

    \begin{eqnarray}
        \lfloor x \rfloor \leqq x < \lfloor x \rfloor + 1
    \end{eqnarray}




.. math::
    :nowrap:

    \begin{eqnarray}
        x-1 < [x] \leqq x
    \end{eqnarray}


問題::

 自然数N,Mと整数xがあり、M < N*xを満たしている。
 このとき、xの最小値をガウス記号を用いて求めよ。

解答::

 ガウスの定義により[M/N] <= M/N < [M/N]+1が成立する。
 よってM/N < xを満たす最小のxは[M/N]+1である。


//演算子について(python3)
--------------------------
割り切れない場合は、小数点以下を切り捨てる ::

   5 // 2 = 2
   1 // 10 = 0

分配法則が成り立つ ::

   (A + B) // C = A // C + B // C

0<= i < N の場合 ::

    i // N = 0

一般に ::

    (N * i) // N = i



has-other-divisor.scm
===============================================================

共通約数のみ存在する場合はTrue

.. code-block:: ghc
   

    
    f :: Int -> Int -> Bool
    f a b = g a where
      g x = let y = gcd x b in
        if y == 1 then x == 1 else g (div x y)
    main = do
      print $ f 75 15  -- {3 5}
      print $ f 15 75
      print $ f 8 15
    

.. code-block:: sh
   

    True
    True
    False
    



index.scm
===========================



0 or N開始
------------------------

配列は0から開始するので、できるだけ0開始がよい。
f(n)=f(n+1) (配列と同じ、末尾再帰)
f(n)=f(n-1) (再帰したい場合、条件で分岐)



計算量
---------

ルートNまでの総和はN



.. math::
    :nowrap:

    \begin{eqnarray}
        1 + 2 + ... \sqrt[]{N} = \frac{1 + \sqrt[]{N}}{2} = O(N)
    \end{eqnarray}


.. code-block:: py
   

    def f(N):
     i = 1
     s = 0
     while i*i <= N:
      for j in range(i):
       s += j
     i += 1
     return s

.. code-block:: sh
   

    

logNとなるのは、2で割る場合や余りの場合

.. code-block:: py
   

    def f(N):
     while N > 0:
      pass
      N /= 2

.. code-block:: sh
   

    


.. code-block:: py
   

    def f(N):
     for i in range(N):
      if N % i == 0:
       pass

.. code-block:: sh
   

    



O(MN)
---------------

掛け算の場合はどちらが外側のループになるか、2通り考えられる


lcm.scm
=====================

Least Common Multiple

.. code-block:: ghc
   

    
    lcm' a b = div (a * b) (gcd a b)
    main = do
      print $ lcm' 15 5
    

.. code-block:: sh
   

    15
    



mod.scm
=====================


Mod(合同式)
===========

%演算子は、分配法則が成り立つ ::

  (A + B) % C = A % C + B % C

0<= i < N の場合 ::

    i % N = i

iがNの倍数の場合 ::

    i % N = 0
    つまりiはNで割り切れる

交換法則は成り立たない ::

    A % B != B % A

反例 ::

    10 % 3 = 1
    3 % 10 = 3
    よって
    10 % 3 != 3 % 10


`答えをMODして出せ`
という指示があれば、答えの途中でもMODして良いという意味です。
(数が大きくなりすぎない様にすることと、巡回するだけなので答えが一定になることが理由)

**Quotient** ::

 N = Q*M + R
 (0 <= R <= M - 1)

MODに関しても分配法則が成立::

 ans %= MOD
 ans = (ans + add) % MOD
 ans = ans % MOD + add % MOD

