
=======================================
binary-search
=======================================

.. contents::
    :depth: 2



bit.scm
=====================



complement.scm
==========================================



findSqrtN.scm
=======================================



２乗したらnになる整数は？
---------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        n in N s.t. max_{x} f(x) = x^2 - n <= 0
    \end{eqnarray}

f(x) <= 0の場合に、+ 2^xを大きい方から累積する。単調増加関数である必要あり 

.. code-block:: gosh
   

    
    (let* ((n 15241578750190521)
           (f (^x (- (* x x) n)))
           (g (^(a acc)
                (let1 x (+ a acc) (if (<= (f x) 0) x acc)))))
      (print (fold g 0 (map (pa$ expt 2) (reverse (iota 63))))))
    

.. code-block:: sh
   

    123456789
    


.. code-block:: gosh
   

    
    (print
     (let* ((n 15241578750190521)
            (f (^x (- (* x x) n))))
       (let loop ((low 0) (high (expt 2 63)))
         (if (> low high)
             -1
             (let* ((x (div (+ low high) 2))
                    (fx (f x)))
               (cond ((= fx 0) x)
                     ((< fx 0) (loop (+ x 1) high))
                     (else (loop low (- x 1)))))))))
    

.. code-block:: sh
   

    123456789
    



index.scm
===========================



基本的な考え方
---------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\[low, high]の区間を探索
    \\
    \\中点を取る際に、以下の２通りが考えられる(k \ge 0)
    \\high & = low + 2k
    \\high & = low + 2k + 1
    \\
    \\mid & = (low + high) / 2
    \\より、いずれの場合も、以下となる。
    \\mid & = low + k
    \\
    \\midが解でない場合は、区間を狭める必要がある. 
    \\midは解ではないので、区間に含めない.
    \\
    \\以下の範囲に狭めて探索を続ける
    \\[low, mid - 1] & (midよりも左側)
    \\[mid + 1, high] & (else)
    \\
    \\
    \end{eqnarray}



終了条件をlow<highにすることの問題点
------------------------------------------------------------------


k=0のとき、以下のいずれかであるが、
上の場合は探索終了. 下の式は続く範囲に更新
high & = low
high & = low + 1

以下の範囲に更新しても、ともに終了条件となる
[low, low+1] => [low+1, low+1] (右側探索)
[low, low+1] => [low, low-1] (左側探索)

mid = lowなので、lowの探索はするが、low+1の探索はしない.
つまり、low<highの終了条件の場合、[low, low+1)の範囲しか探索しない.

TODO: ここから、1bit目が0のもの全てが探索されないといいたい



midで更新することの問題点
------------------------------------------


k = 0のとき、mid = lowなので、(終了条件は、low<=highとする)

右側探索で更新するとき、mid+1せず、midで更新すると、以下のように無限ループになる.
[low, low]   => 右側探索 => [mid, low]   = [low, low]
[low, low+1] => 右側探索 => [mid, low+1] = [low, low+1]

左側探索でmid-1でなくmidで更新するときも、同様に無限ループになる.
[low, low]   => 左側探索 => [low, mid] = [low, low]
[low, low+1] => 左側探索 => [low, mid] = [low, low]

つまり、解ではないことが判明したmidを区間に含めないように、+1,-1して区間を狭める必要がある。



rotate.scm
==============================



k-roteated increasing order array
---------------------------------------------------------------------------------------------------


-- A -- left -- B -- mid -- C -- right -- D --
本来 left <= mid <= rightが成立する
ただし、lotateしているため、その開始位置がmidの右か左か特定する必要がある。

a[left] < a[mid]のときは、左側が順番に並んでいるので、Cに開始位置がある.
leftとmidの間にtargetがあるか、ないかで区間を狭めることができる。


.. code-block:: c
   

    
    #include <stdio.h>
    int search(int *a, int left, int right, int target) {
      while (left <= right) {
        int mid = left + (right - left) / 2;
        if (a[mid] == target)
          return mid;
        else if (a[left] > a[mid]) {
          if (a[mid] <= target && target <= a[right])
            left = mid + 1;
          else
            right = mid - 1;
        } else {
          if (a[left] <= target && target <= a[mid])
            right = mid - 1;
          else
            left = mid + 1;
        }
      }
      return -1;
    }
    int main() {
      int A[] = {/* TEST-DATA */};
      int arr_size = sizeof(A)/sizeof(A[0]);
      for (int i = 0; i <= 9; i++)
        printf("%d, ", search(A, 0, arr_size - 1, i));
      return 0;
    }
    

TEST-DATA = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

.. code-block:: sh
   

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 

TEST-DATA = 1, 2, 3, 4, 5, 6, 7, 8, 9, 0

.. code-block:: sh
   

    9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 

TEST-DATA = 2, 3, 4, 5, 6, 7, 8, 9, 0, 1

.. code-block:: sh
   

    8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 

TEST-DATA = 2,2,2,2,2,2,2,3,2,2
linerでなくても求まる!

.. code-block:: sh
   

    -1, -1, 4, 7, -1, -1, -1, -1, -1, -1, 

