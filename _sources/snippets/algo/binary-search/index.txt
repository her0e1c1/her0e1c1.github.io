
=======================================
binary-search
=======================================

.. contents::
    :depth: 2



findSqrtN.scm
=======================================



Compute the square root
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        n \in N s.t. \max_{x} f(x) = x^2 - n \le 0
    \end{eqnarray}

f(x) <= 0の場合に、+ 2^xを大きい方から累積する。単調増加関数である必要あり 

.. code-block:: gosh
   

    
    (let* ((n 15241578750190521)
           (f (^x (- (* x x) n)))
           (g (^(a acc)
                (let1 x (+ a acc) (if (<= (f x) 0) x acc)))))
      (print (fold g 0 (map (pa$ expt 2) (reverse (iota 63))))))
    

.. code-block:: sh
   

    123456789
    


.. code-block:: gosh
   

    
    (print
     (let* ((n 15241578750190521)
            (f (^x (- (* x x) n))))
       (let loop ((low 0) (high (expt 2 63)))
         (if (> low high)
             -1
             (let* ((x (div (+ low high) 2))
                    (fx (f x)))
               (cond ((= fx 0) x)
                     ((< fx 0) (loop (+ x 1) high))
                     (else (loop low (- x 1)))))))))
    

.. code-block:: sh
   

    123456789
    



index.scm
===========================



基本的な考え方
---------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\区間[low, high]を探索
    \\
    \\中点を取る際に、以下の２通りが考えられる(k \ge 0)
    \\high & = & low + 2k
    \\high & = & low + 2k + 1
    \\
    \\中点について
    \\mid & = & (low + high) / 2
    \\より、いずれの場合も、以下となる
    \\mid & = & low + k
    \\
    \\midが解でない場合は、区間を狭める必要がある. 
    \\midは解ではないので、区間に含めない.
    \\
    \\以下の範囲に狭めて探索を続ける
    \\区間[low, mid - 1] (midよりも左側)
    \\区間[mid + 1, high] (else)
    \\
    \end{eqnarray}



終了条件をlow<highにすることの問題点
------------------------------------------------------------------


k=0のとき、以下のいずれかとなる

- high = low (探索終了)
- high = low + 1 (ループ続ける)

しかし、ループを続けても、ともに終了条件となる

- [low, low+1] => [low+1, low+1] (右側探索)
- [low, low+1] => [low, low-1] (左側探索)

双方の場合、mid = lowなので、lowの探索はするが、low+1の探索はしない.
つまり、low<highの終了条件の場合、[low, low+1)の範囲しか探索しない.

.. todo:: ここから、1bit目が0のもの全てが探索されないといいたい


midで更新することの問題点
------------------------------------------


k = 0 かつ、終了条件がlow<=high のとき、mid = lowなので、

右側探索で更新する時、mid+1せず、midで更新すると、以下のように無限ループになる.

- [low, low]   => 右側探索 => [mid, low]   = [low, low]
- [low, low+1] => 右側探索 => [mid, low+1] = [low, low+1]

左側探索で更新する時、mid-1せず、midで更新すると、同様に無限ループになる.

- [low, low]   => 左側探索 => [low, mid] = [low, low]
- [low, low+1] => 左側探索 => [low, mid] = [low, low]

つまり、解ではないことが判明したmidを区間に含めないように、mid+1, mid-1して区間を狭める必要がある。

.. todo:: minを取得する場合は、若干工夫する必要あり
ビット演算でのイメージ
======================
``f(x) = -x^2 + 10*x + 1`` の ``max x in N st f(x) > 0`` を考える。
答えは、 ``f(10) = 1, f(11) = -10`` よりx=10である。

``f(2^4) < 0`` なので、4乗は境界線を超えている(当然f(2^5)なども、この関数では同様)。
これは、 ``x < 16`` と値域が狭まったことを意味している。
2進数で言うと、0b0XXXXと5桁目以降が0bitであることを意味している。

``f(2^3) >= 0`` なので、 ``8 <= x < 16`` となり、
2進数で言うと、0b01XXXと4桁目が1bitを意味する。

``f(2^3 + 2^2) < 0`` なので、 ``8 <= x < 12`` となり、 0b010XXとなる。
xは8以上なので、ここで ``f(2^2)`` などを計算することに意味はない。

同様に
``f(2^3 + 2^1) >= 0`` なので、 ``10 <= x < 12`` となり、 0b0101Xとなる。

``f(2^3 + 2^1 + 2^0) < 0`` なので、 ``10 <= x < 11`` となり、 0b01010が答えとなる。

::

    f = lambda x: -(x * x) + 10 * x + 1

    def p(n):
        print("f(%s) = %s" % (n, f(n)))

    p(pow(2, 5))  # f() < 0
    p(pow(2, 4))  # f() < 0
    p(pow(2, 3))  # f() >= 0
    p(pow(2, 3) + pow(2, 2))
    p(pow(2, 3) + pow(2, 1))
    p(pow(2, 3) + pow(2, 1) + pow(2, 0))
   
アルゴリズムのイメージは、
ジャンプの飛び幅を徐々に小さくしながら目的地に到達するイメージとなる。
つまり、大きい方から範囲を徐々に狭めるイメージ。

.. warning:: bit演算の問題点は、負の数には対応できないので、注意すること。


rotate.scm
==============================



k-roteated increasing order array
---------------------------------------------------------------------------------------------------


-- A -- left -- B -- mid -- C -- right -- D --

本来 left <= mid <= rightが成立する
ただし、lotateしているため、その開始位置がmidの右か左か特定する必要がある。

a[left] < a[mid]のときは、左側が順番に並んでいるので、Cに開始位置がある.
leftとmidの間にtargetがあるか、ないかで区間を狭めることができる。


.. code-block:: c
   

    
    #include <stdio.h>
    int search(int *a, int left, int right, int target) {
      while (left <= right) {
        int mid = left + (right - left) / 2;
        if (a[mid] == target)
          return mid;
        else if (a[left] > a[mid]) {
          if (a[mid] <= target && target <= a[right])
            left = mid + 1;
          else
            right = mid - 1;
        } else {
          if (a[left] <= target && target <= a[mid])
            right = mid - 1;
          else
            left = mid + 1;
        }
      }
      return -1;
    }
    int main() {
      int A[] = {/* TEST-DATA */};
      int arr_size = sizeof(A)/sizeof(A[0]);
      for (int i = 0; i <= 9; i++)
        printf("%d, ", search(A, 0, arr_size - 1, i));
      return 0;
    }
    

TEST-DATA = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

.. code-block:: sh
   

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 

TEST-DATA = 1, 2, 3, 4, 5, 6, 7, 8, 9, 0

.. code-block:: sh
   

    9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 

TEST-DATA = 2, 3, 4, 5, 6, 7, 8, 9, 0, 1

.. code-block:: sh
   

    8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 

TEST-DATA = 2,2,2,2,2,2,2,3,2,2
linerでなくても求まる!

.. code-block:: sh
   

    -1, -1, 4, 7, -1, -1, -1, -1, -1, -1, 



zero.scm
========================

interspersedWithZero (0が途中に混ざった場合のbinary search)
CI 9.5

- 終了条件low<=high
- 更新mid+1,mid-1

の場合の探索は
区間[low, high]となるため、
0を無視するようmidを移動する。
lowは探索ずみなので、low<midの条件入れておく


.. code-block:: cpp
   

    
    #include <myutils.h>
    int find(vector<int> a, int target) {
      int lo=0, hi=a.size()-1;
      while (lo<=hi){
       int mi=(lo+hi)/2;
       while (a[mi] == 0 && lo < mi) mi--;  // ADD
       if (a[mi] == target) return mi;
       else if (a[mi] < target) lo=mi+1;
       else hi=mi-1;
      }
      return -1;
    }
    
    int main() {
      for (int i = 0; i <= 10; i++)
        //      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
        P(find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i));
    
    }
    

.. code-block:: sh
   

    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 0
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 1
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 4
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 6
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 14
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 19
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 20
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 22
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 25
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = 26
    find({0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 6, 0, 7, 0, 0, 8, 9, 0}, i) = -1
    

