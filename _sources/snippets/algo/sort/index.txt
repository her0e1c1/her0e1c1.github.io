
============
sort
============

.. contents::
    :depth: 2



bubble-sort.scm
=============================================


bubble sortは末尾からsortされる

- 1回目     : 0 <= j <= size - 1
- 2回目     : 0 <= j <= size - 2
- size-1回目: 0 <= j <= size - (size-1) = 1
- size回目  : 0 <= j <= size - size = 0 (meaningless)



.. code-block:: c
   

    #include <myc.h>
    void swap(int *x, int *y) { int t=*x; *x=*y; *y=t; }
    void sort(int *a, int size) {
      for (int end = size - 1; end >= 1 ; end--) {
        for (int j = 0; j < end ; j++) {
          if (a[j] > a[j + 1])
           swap(&a[j], &a[j+1]);
        }
      }
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8,1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6};
      sort(a, SIZE(a));
      PVI(a);
    }

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 



heap-sort.scm
=======================================



insert-sort.scm
=============================================

ソート済み配列を左端から構築。i順番をその配列の適した位置に挿入. 
0番目はそのままで良いので、1番目からソートする
挿入については、適した位置が見つかれば、その時点でi番目までソート済みになる。
そのため、ソート済み配列をソートする場合の計算量は、O(n)となる。

.. code-block:: c
   

    
    #include <myc.h>
    static inline void swap(int *x, int *y) { int t=*x; *x=*y; *y=t; }
    void sort(int *a, int len) {
     for (int i = 1; i < len; i++) {
      int j = i;
      while (j >= 1 && a[j-1] > a[j]) {
       swap(&a[j-1], &a[j]);
       j--;
      }
     }
    }
    int main() {
     int a[] = {14, -93, 64, -2, 6, -27, -7, -15, 84, 20, 45, -59, -20, -28, 32, -18, 2, -6, 8, -41};
     sort(a, SIZE(a));
     PVI(a);
    }
    

.. code-block:: sh
   

    -93, -59, -41, -28, -27, -20, -18, -15, -7, -6, -2, 2, 6, 8, 14, 20, 32, 45, 64, 84, 



msort.scm
===========================

O(2n)
O(nlogn) stable

.. code-block:: c
   

    #include <stdio.h>
    #include <string.h>
    
    void msort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int mid = left + (right - left) / 2;
      msort(a, left, mid);
      msort(a, mid + 1, right);
    
      int l = left, r = mid + 1, k = 0;
      int len = right - left + 1;
      int buff[len];  // O(n)のスペースが必要(VLA)
    
      // どちらか一方の配列を全て使い切るまでloop
      while (l <= mid && r <= right) {
        if (a[l] < a[r])
          buff[k++] = a[l++];
        else
          buff[k++] = a[r++];
      }
      // 残りの一方の配列をappend
      while (l <= mid)   buff[k++] = a[l++];
      while (r <= right) buff[k++] = a[r++];
    
      // sizeof忘れ、offsetのleft忘れ
      memcpy(a + left, buff,  sizeof(int) * len);
      /* for (int i = 0; i < len; i++) */
      /*   a[left + i] = buff[i]; */
    
    }
    
    int main() {
      int A[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8,1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6};
      int arr_size = sizeof(A)/sizeof(A[0]);
      msort(A, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", A[i]);
      return 0;
    }

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 



scheme
------------------


.. code-block:: gosh
   

    
    (define (merge-sort alist)
      (if (>= 1 (length alist))
          alist
          (let1 mid (div (length alist) 2)
                (merge (merge-sort (take alist mid)) (merge-sort (drop alist mid))))))
    (define (merge l r)
      (cond ((null? l) r)
            ((null? r) l)
            (else
             (let ((la (car l)) (ra (car r)))
               (if (< la ra)
                   (cons la (merge (cdr l) r))
                   (cons ra (merge l (cdr r))))))))
    (print (merge-sort '(1 4 1 5 2 3 1)))
    

.. code-block:: sh
   

    (1 1 1 2 3 4 5)
    



qsort.scm
===========================

O(nlogn)
O(n^2)


c
---


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int k = left;
      // items from left+1 to k are smaller than pivot
      for (int i = left + 1; i <= right; i++) {
        if (a[i] < pivot) {
          k++;
          swap(a, k, i);
        }
      }
      swap(a, left, k);
      // items from left to k-1 are smaller than pivot
      qsort(a, left, k-1);
      qsort(a, k+1, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int k = left;
      // items from left to k-1 are smaller than pivot
      for (int i = left + 1; i <= right; i++) {
        if (a[i] < pivot) {
          swap(a, k, i);
          k++;
        }
      }
      // ここでのkはpivot<=a[k]となる(つまり、右側に含める必要あり)
      // k = left の場合if条件が一度も満たされないとk == leftのままなので
      // qsort(a, k, right)だと、無限ループに陥る
      // qsort(a, k+1, right)とする必要がある
      qsort(a, left, k-1);
      if (k == left)
        qsort(a, k+1, right);
      else
        qsort(a, k, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        while(a[i] < pivot) i++;
        while(a[j] > pivot) j--;
        if (i <= j){
          swap(a, i, j); i++; j--;
        } else
          break;
      }
      // 無限ループにならないよう、必ず、2つに分割される必要がある
      // left ~ j (pivot以下)
      // i ~ right (pivot以上)
      qsort(a, left, j);
      qsort(a, i, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        while(a[i] < pivot) i++;  // ガード文と見るのがポイント!
        while(a[j] > pivot) j--;
        if (i <= j){
          // i-1番目までは、a[i]<pivotを満たす
          // i番目は、a[j](<=pivot)とswapすることで、
          // leftからi番目までが必ずpivot以下となる.
          swap(a, i, j); i++; j--;
    
          // （間違い）配列のそれぞれ一つ前は逆条件を満たす?
          // a[left ~ (i-1)] < pivot
          // a[(j+1) ~ right] > pivot
          // ただし、お互いにpivotをswapすると、双方にpivotが混ざる
        } else
          break;
      }
      // 3条件を満たしている
      // a[i] >= pivot
      // a[j] <= pivot
      // i > j
    
      // i-1==rightにはならない  
      // i==leftが必ずa[i]<pivotを満たすため、i==j==rightでswapすることはない(要素数2以上)
      qsort(a, left, i-1);
      qsort(a, i, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        while(a[i] < pivot) i++;
        while(a[j] > pivot) j--;
        if (i <= j){
          swap(a, i, j); i++; j--;
        } else
          break;
      }
      // pivotがmaxのときに、pivot以下・以上で分割すると、２分割できていない場合がある
      // minのときは、ソートされているので問題ない?
      // i == j == leftでswapする可能性あり!
      // if there is a sorted array, j == left-1 maybe occur
      // prevent calling qsort(left, right) again
      if (left <= j) {
        qsort(a, left, j);
        qsort(a, j+1, right);
      }
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        // この記述は危険. 必ずpivotが配列aの最大値のときにout of index
        // while(a[i] <= pivot) i++;
        while(a[i] <= pivot && i <= right) i++;
        while(a[j] >= pivot && j >= left ) j--;
        if (i <= j){
          swap(a, i, j); i++; j--;
        } else
          break;
      }
      if (i-1 < right)
        qsort(a, left, i-1);
      else {
        // pivotがmaxのため、これ一つと残りで２分割
        assert(i-1 == right);
        swap(a, left, right);
        qsort(a, left, right-1);
      }
      qsort(a, i, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 



scheme
------------------


.. code-block:: gosh
   

    
    (define (quick-sort alist)
      (if (null? alist)
          '()
          (let* ((pivot (car alist))
                 (rest (cdr alist))
                 (small (filter (lambda (x) (<= x pivot)) rest))
                 (large (filter (lambda (x) (> x pivot)) rest)))
            (append (quick-sort small) (list pivot) (quick-sort large)))))
    (print  (quick-sort '(1 4 45 3 7 6 7 7 7 10 8 8 8 8 1 10 -1 3 20 5 9 33 -1 4 5 3 6)))
    

.. code-block:: sh
   

    (-1 -1 1 1 3 3 3 4 4 5 5 6 6 7 7 7 7 8 8 8 8 9 10 10 20 33 45)
    



red-black-tree.scm
======================================================



selection-sort.scm
======================================================

左端から順番に小さいものを移動
i番目における現時点での最小値を決めたい. (常にa[i]と比較)

.. code-block:: c
   

    
    #include <myc.h>
    static inline void swap(int *x, int *y) { int t=*x; *x=*y; *y=t; }
    void sort(int *a, int len) {
     for (int i = 0; i < len; i++) {
      for (int j = i + 1; j < len; j++)
       if (a[i] > a[j]) swap(&a[i], &a[j]);
     }
    }
    int main() {
     int a[] = {3, 66, 50, -25, -89, 0, -18, -29, -51, 57, -13, -40, -68, -85, -28, -91, 33, -6, 82, 96};
     sort(a, SIZE(a));
     PVI(a);
    }
    

.. code-block:: sh
   

    -91, -89, -85, -68, -51, -40, -29, -28, -25, -18, -13, -6, 0, 3, 33, 50, 57, 66, 82, 96, 



shellsort.scm
=======================================

gap==1がinsert sort
分割したinsert sortというだけ
gap==1で最終的にソートされる

.. code-block:: c
   

    
    #include <stdio.h>
    void sort(int *a, int len) {
     for (int gap = len/2; gap >= 1; gap/=2) {
      for (int i = gap; i < len; i += gap) {
        int j = i;    
        while (j-gap >= 0 && a[j] < a[j-gap]) {
           int tmp = a[j];
           a[j] = a[j-gap];
           a[j-gap] = tmp;
           j -= gap;
        }
      }
     }
    }
    int main() {
     int a[] = {-21, 10, -10, 73, 3, -89, 61, -49, -16, 16, 85, 27, 98, 11, 92, -97, 90, -59, -42, 36};
     int len = sizeof(a)/sizeof(a[0]);
     sort(a, len);
     for (int i = 0; i < len; i++)
      printf("%d, ", a[i]);
    }
    

.. code-block:: sh
   

    -97, -89, -59, -49, -42, -21, -16, -10, 3, 10, 11, 16, 27, 36, 61, 73, 85, 90, 92, 98, 

An array is divided to k-groups. apply insert sort to each group

.. code-block:: c
   

    
    #include <stdio.h>
    void sort(int *a, int len) {
     for (int gap = len/2; gap >= 1; gap/=2) {
      for (int k = 0; k < gap; k++) {
        for (int i = k+gap; i < len; i += gap) {
        int j = i;
        while (j-gap >= 0 && a[j] < a[j-gap]) {
           int tmp = a[j];
           a[j] = a[j-gap];
           a[j-gap] = tmp;
           j -= gap;
        }
       }
      }
     }
    }
    int main() {
     int a[] = {-21, 10, -10, 73, 3, -89, 61, -49, -16, 16, 85, 27, 98, 11, 92, -97, 90, -59, -42, 36};
     int len = sizeof(a)/sizeof(a[0]);
     sort(a, len);
     for (int i = 0; i < len; i++) printf("%d, ", a[i]);
    }
    

.. code-block:: sh
   

    -97, -89, -59, -49, -42, -21, -16, -10, 3, 10, 11, 16, 27, 36, 61, 73, 85, 90, 92, 98, 



stable.scm
==============================


selection sortにて、以下をソート
- 2a 3 2b 1
- 1 3 2b 2a （1回目のループ終了時）
- 1 2b 3 2a （2回目のループ終了時）
- 1 2b 2a 3 （3回目のループ終了時）

2a, 2bの関係が逆順になっているので、不安定ソート
つまり、第一keyはソートされるが、それによって第二keyのソート順が保たれない
一般に、swapなどの破壊的な操作が必要なソートは不安定となる



topological-sort.scm
============================================================

