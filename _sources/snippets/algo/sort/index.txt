
============
sort
============

.. contents::
    :depth: 2



bubble-sort.scm
=============================================

bubble sortは末尾からsortされる ::

   1回目     : 0 <= j <= size - 1
   2回目     : 0 <= j <= size - 2
   size-1回目: 0 <= j <= size - (size-1) = 1
   size回目  : 0 <= j <= size - size = 0 (meaningless)


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\数列a_N = (a_1 a_2 ... a_N) = \hat{a}  \quad s.t. \quad 
    \\g(N) &=& \hat{a}
    \\g(i-1) &=& f(i, i)
    \\f(0, end) &=& g(end)
    \\f(j+1, end) &=& \begin{cases} swap(f(j, end), j, j+1) & (\mbox{if} \quad  a_j > a_{j+1})
    \\f(j, end) & (else \mbox{j >= endの場合、f(j, end) = f(j+n, end)なので、プログラム上はループ終了})
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    void swap(int *x, int *y) { int t=*x; *x=*y; *y=t; }
    void sort(int *a, int size) {
      for (int end = size - 1; end >= 1 ; end--) {
        for (int j = 0; j < end ; j++) {
          if (a[j] > a[j + 1])
           swap(&a[j], &a[j+1]);
        }
      }
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8,1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6};
      sort(a, SIZE(a));
      PVI(a);
    }

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: ghc
   

    f [] = []
    f xs = f (take (length ys - 1) ys) ++ [last ys] where
     ys = g xs
    g [x] = [x]
    g (x:y:zs)
     | x < y     = x:g (y:zs)
     | otherwise = y:g (x:zs)
    main = print $ f [3,1,2,5,4]

.. code-block:: sh
   

    [1,2,3,4,5]
    



find-kth-smallest.scm
===============================================================

O(n)でk番目に小さい要素を取得(重複OK?)

.. code-block:: c
   

    #include <myc.h>
    void swap(int *x, int *y) {int t=*x; *x=*y; *y=t;}
    int find(int *a, int left, int right, int pos) {
     int k = left;
     int pivot = a[left];
     for (int i = left + 1; i <= right; i++)
      if (a[i] < pivot) swap(&a[i], &a[++k]);
     swap(&a[left], &a[k]);
     if (k == pos) return a[k];
     else if (pos < k) return find(a, left, k-1, pos);
     else return find(a, k+1, right, pos);
    }
    int main() {
     // int a[] = {4,1,2,5,0,3};
     int a[] = {4,1,2,0,0,1,5,0,3};
     for (int i = 0; i < SIZE(a); i++)
      printf("%d\n", find(a, 0, SIZE(a) - 1, i));
    }

.. code-block:: sh
   

    0
    0
    0
    1
    1
    2
    3
    4
    5
    



heap-sort.scm
=======================================


Heap sort
=========

Introduction
============

頭からヒープ構造を構築し、その過程でソートする
作成したヒープ構造は、その末尾から配列に戻す作業を行う
配列 => ヒープ => 配列と構造を変化させる
heap構造とは、2分木のデータ構造で、子よりも親の方が大きい(あるいは小さい)データ構造

特徴
====
- ルートが最大(または最小)となる.
- 各親は、必ず子供よりも大きい(あるいは、小さい)
- 適したデータコンテナは、リストではなく配列
- in place
- 計算量はO(NlogN)であるが、quicksortに比べて、heapを構築する作業がある分、2倍程度遅いが最悪計算量もO(NlogN)と変わらず

.. warning::
   上記の性質上、どちらかに値が偏ることがある.
   (``[5, 4, 1, 3, 2, 0]`` はheap構造であるが、一方に偏っている)

priority query
--------------
2分ヒープを使って実装できる.

:参照: O(1)
:削除: O(logN)
:追加: O(logN)

子からみた親のindexは?
----------------------
Cの場合0始まりとする.

子供をnとすると、もう一方の子供はn+1

たとえば、 1と2の時は、0になることを考えると、 ::

    PARENT = (CHILD - 1) / 2

0はルートなので親がいないようにマイナスとなる。 ::

  PARENT = (CHILD + 1) / 2 - 1 が成立するので
  PARENT + 1 = (CHILD + 1) / 2 = CHILD/2 + 1/2 = CHILD/2 (if CHILD is even)
  PARENT + 1 = (CHILD + 1) / 2 (if CHILD is odd)
  よって２通りの親の表し方ができる
  CHILD = 2(PARENT + 1)
  CHILD = 2(PARENT + 1) - 1

参考文献
========
- http://www.maroontress.com/Heap/heap-realization.pdf



.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\parent >=0 \in N
    \\ \quad s.t. \quad  parent = \lfloor \frac{child-1}{2} \rfloor (\Rightarrow child \ne 0)
    \\
    \\left  &=& 2 \times parent + 1
    \\right &=& 2 \times parent + 2
    \\
    \\size &<=& left & \Rightarrow & \mbox{no children}
    \\size &==& right = (left+1)& \Rightarrow & \mbox{only left child}
    \\&& else & \Rightarrow & \mbox{two children}
    \\
    \\downHeap(parent, A) &=& downHeap(maxChild, swap(A,maxChild, parent)) & (*maxChild > *parent \bigwedge maxChild > 0)
    \\upHeap(child, A) &=& upHeap(parent, swap(A,child, parent)) & (*child > *parent and child > 0)
    \\heapify(i, A) &=& heapify(i+1, upHeap(i, A)) & (任意の配列を0から順番にheapを構築)
    \\sort(i, A) &=& sort(i-1, downHeap(0, swap(A, 0, i))) & (配列の末尾から昇順にソート)
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    
    #define PARENT(n) (((n) - 1) / 2)
    #define LEFT(n) (2 * (n) + 1)
    #define RIGHT(n) (2 * (n) + 2)
    #define VALUE(h, n) ((h)->array[(n)])
    #define data_type int
    
    static inline void swap(data_type *a, int i, int j) {data_type t=a[i];a[i]=a[j];a[j]=t;}
    
    // return a child index which is more than 0
    data_type maxChild(data_type *a, int parent, int size) {
      int left, right;
      if ((left = LEFT(parent)) >= size)
        return 0;
      else if ((right = RIGHT(parent)) == size) {
        return left;
      } else if (a[left] < a[right])
        return right;
      else
        return left;
    }
    void downHeap(data_type *a, int size) {
      int parent = 0;
      while (1) {
        int child = maxChild(a, parent, size);
        if (child > 0 && a[parent] < a[child]) {
          swap(a, parent, child);
          parent = child;
        } else
          break;
      }
    }
    void upHeap(data_type *a, int child) {
      while (1) {
        int parent = PARENT(child);
        if (child > 0 && a[parent] < a[child]) {
          swap(a, parent, child);
          child = parent;
        } else
          break;
      }
    }
    data_type *heapSort(data_type *array, int size) {
      for (int i = 0; i < size; i++)
        upHeap(array, i);
      for (int i = size - 1; i >= 0; i--) {
        swap(array, 0, i);  // sort from last to first
        downHeap(array, i);
      }
      return array;
    }
    int main() {
      int a[] = {5, 3, 1, 2, 4};
      heapSort(a, SIZE(a));
      PVI(a);
    }

.. code-block:: sh
   

    1, 2, 3, 4, 5, 



insert-sort.scm
=============================================

ソート済み配列を左端から構築。i順番をその配列の適した位置に挿入. 
0番目はそのままで良いので、1番目からソートする
挿入については、適した位置が見つかれば、その時点でi番目までソート済みになる。
そのため、ソート済み配列をソートする場合の計算量は、O(n)となる。


msort.scm
===========================

O(2n)
O(nlogn) stable

.. code-block:: c
   

    #include <stdio.h>
    #include <string.h>
    
    void msort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int mid = left + (right - left) / 2;
      msort(a, left, mid);
      msort(a, mid + 1, right);
    
      int l = left, r = mid + 1, k = 0;
      int len = right - left + 1;
      int buff[len];  // O(n)のスペースが必要(VLA)
    
      // どちらか一方の配列を全て使い切るまでloop
      while (l <= mid && r <= right) {
        if (a[l] < a[r])
          buff[k++] = a[l++];
        else
          buff[k++] = a[r++];
      }
      // 残りの一方の配列をappend
      while (l <= mid)   buff[k++] = a[l++];
      while (r <= right) buff[k++] = a[r++];
    
      // sizeof忘れ、offsetのleft忘れ
      memcpy(a + left, buff,  sizeof(int) * len);
      /* for (int i = 0; i < len; i++) */
      /*   a[left + i] = buff[i]; */
    
    }
    
    int main() {
      int A[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8,1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6};
      int arr_size = sizeof(A)/sizeof(A[0]);
      msort(A, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", A[i]);
      return 0;
    }

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 



scheme
------------------


.. code-block:: gosh
   

    
    (define (merge-sort alist)
      (if (>= 1 (length alist))
          alist
          (let1 mid (div (length alist) 2)
                (merge (merge-sort (take alist mid)) (merge-sort (drop alist mid))))))
    (define (merge l r)
      (cond ((null? l) r)
            ((null? r) l)
            (else
             (let ((la (car l)) (ra (car r)))
               (if (< la ra)
                   (cons la (merge (cdr l) r))
                   (cons ra (merge l (cdr r))))))))
    (print (merge-sort '(1 4 1 5 2 3 1)))
    

.. code-block:: sh
   

    (1 1 1 2 3 4 5)
    



quick-sort.scm
==========================================

再帰関数の呼び出しするときに、スタックに実引数を積む必要があるので、メモリスペースは、平均O(logN)必要
O(nlogn)
O(n^2)


c
---


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int k = left;
      // items from left+1 to k are smaller than pivot
      for (int i = left + 1; i <= right; i++)
        if (a[i] < pivot) swap(a, ++k, i);
      swap(a, left, k);
      // items from left to k-1 are smaller than pivot
      qsort(a, left, k-1);
      qsort(a, k+1, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int k = left;
      // items from left to k-1 are smaller than pivot
      for (int i = left + 1; i <= right; i++) {
        if (a[i] < pivot) {
          swap(a, k, i);
          k++;
        }
      }
      // ここでのkはpivot<=a[k]となる(つまり、右側に含める必要あり)
      // k = left の場合if条件が一度も満たされないとk == leftのままなので
      // qsort(a, k, right)だと、無限ループに陥る
      // qsort(a, k+1, right)とする必要がある
      qsort(a, left, k-1);
      if (k == left)
        qsort(a, k+1, right);
      else
        qsort(a, k, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        while(a[i] < pivot) i++;
        while(a[j] > pivot) j--;
        if (i <= j){
          swap(a, i, j); i++; j--;
        } else
          break;
      }
      // 無限ループにならないよう、必ず、2つに分割される必要がある
      // left ~ j (pivot以下)
      // i ~ right (pivot以上)
      qsort(a, left, j);
      qsort(a, i, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        while(a[i] < pivot) i++;  // ガード文と見るのがポイント!
        while(a[j] > pivot) j--;
        if (i <= j){
          // i-1番目までは、a[i]<pivotを満たす
          // i番目は、a[j](<=pivot)とswapすることで、
          // leftからi番目までが必ずpivot以下となる.
          swap(a, i, j); i++; j--;
    
          // （間違い）配列のそれぞれ一つ前は逆条件を満たす?
          // a[left ~ (i-1)] < pivot
          // a[(j+1) ~ right] > pivot
          // ただし、お互いにpivotをswapすると、双方にpivotが混ざる
        } else
          break;
      }
      // 3条件を満たしている
      // a[i] >= pivot
      // a[j] <= pivot
      // i > j
    
      // i-1==rightにはならない  
      // i==leftが必ずa[i]<pivotを満たすため、i==j==rightでswapすることはない(要素数2以上)
      qsort(a, left, i-1);
      qsort(a, i, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        while(a[i] < pivot) i++;
        while(a[j] > pivot) j--;
        if (i <= j){
          swap(a, i, j); i++; j--;
        } else
          break;
      }
      // pivotがmaxのときに、pivot以下・以上で分割すると、２分割できていない場合がある
      // minのときは、ソートされているので問題ない?
      // i == j == leftでswapする可能性あり!
      // if there is a sorted array, j == left-1 maybe occur
      // prevent calling qsort(left, right) again
      if (left <= j) {
        qsort(a, left, j);
        qsort(a, j+1, right);
      }
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 


.. code-block:: c
   

    
    #include <stdio.h>
    #include <assert.h>
    void swap(int *a, int x, int y) {
      int t = a[x];
      a[x] = a[y];
      a[y] = t;
    }
    void qsort(int *a, int left, int right) {
      if (left >= right)
        return;
    
      int pivot = a[left];
      int i = left, j = right;
      while (1) {
        // この記述は危険. 必ずpivotが配列aの最大値のときにout of index
        // while(a[i] <= pivot) i++;
        while(a[i] <= pivot && i <= right) i++;
        while(a[j] >= pivot && j >= left ) j--;
        if (i <= j){
          swap(a, i, j); i++; j--;
        } else
          break;
      }
      if (i-1 < right)
        qsort(a, left, i-1);
      else {
        // pivotがmaxのため、これ一つと残りで２分割
        assert(i-1 == right);
        swap(a, left, right);
        qsort(a, left, right-1);
      }
      qsort(a, i, right);
    
    }
    int main() {
      int a[] = {1, 4, 45, 3, 7, 6, 7, 7, 7, 10, 8, 8, 8, 8, 1, 10, -1, 3, 20, 5, 9, 33, -1, 4,5,3,6 };
      int arr_size = sizeof(a)/sizeof(a[0]);
      qsort(a, 0, arr_size - 1);
      for (int i = 0; i < arr_size; i++)
        printf("%d, ", a[i]);
      return 0;
    }
    

.. code-block:: sh
   

    -1, -1, 1, 1, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 10, 10, 20, 33, 45, 



scheme
------------------


.. code-block:: gosh
   

    
    (define (quick-sort alist)
      (if (null? alist)
          '()
          (let* ((pivot (car alist))
                 (rest (cdr alist))
                 (small (filter (lambda (x) (<= x pivot)) rest))
                 (large (filter (lambda (x) (> x pivot)) rest)))
            (append (quick-sort small) (list pivot) (quick-sort large)))))
    (print  (quick-sort '(1 4 45 3 7 6 7 7 7 10 8 8 8 8 1 10 -1 3 20 5 9 33 -1 4 5 3 6)))
    

.. code-block:: sh
   

    (-1 -1 1 1 3 3 3 4 4 5 5 6 6 7 7 7 7 8 8 8 8 9 10 10 20 33 45)
    



red-black-tree.scm
======================================================



selection-sort.scm
======================================================

左端から順番に小さいものを移動
i番目における現時点での最小値を決めたい. (常にa[i]と比較)

.. code-block:: c
   

    
    #include <myc.h>
    static inline void swap(int *x, int *y) { int t=*x; *x=*y; *y=t; }
    void sort(int *a, int len) {
     for (int i = 0; i < len; i++) {
      for (int j = i + 1; j < len; j++)
       if (a[i] > a[j]) swap(&a[i], &a[j]);
     }
    }
    int main() {
     int a[] = {-93, -33, 51, -47, 9, 51, -24, 21, -91, -25, 1, 22, -89, -5, 28, -16, 32, 0, -95, 52};
     sort(a, SIZE(a));
     PVI(a);
    }
    

.. code-block:: sh
   

    -95, -93, -91, -89, -47, -33, -25, -24, -16, -5, 0, 1, 9, 21, 22, 28, 32, 51, 51, 52, 



shellsort.scm
=======================================

gap==1がinsert sort
分割したinsert sortというだけ
gap==1で最終的にソートされる

.. code-block:: c
   

    
    #include <stdio.h>
    void sort(int *a, int len) {
     for (int gap = len/2; gap >= 1; gap/=2) {
      for (int i = gap; i < len; i += gap) {
        int j = i;    
        while (j-gap >= 0 && a[j] < a[j-gap]) {
           int tmp = a[j];
           a[j] = a[j-gap];
           a[j-gap] = tmp;
           j -= gap;
        }
      }
     }
    }
    int main() {
     int a[] = {-8, -93, -93, 2, -66, 78, 63, -34, 23, -36, -50, -79, 28, 34, -69, 60, 66, -47, -12, 60};
     int len = sizeof(a)/sizeof(a[0]);
     sort(a, len);
     for (int i = 0; i < len; i++)
      printf("%d, ", a[i]);
    }
    

.. code-block:: sh
   

    -93, -93, -79, -69, -66, -50, -47, -36, -34, -12, -8, 2, 23, 28, 34, 60, 60, 63, 66, 78, 

An array is divided to k-groups. apply insert sort to each group

.. code-block:: c
   

    
    #include <stdio.h>
    void sort(int *a, int len) {
     for (int gap = len/2; gap >= 1; gap/=2) {
      for (int k = 0; k < gap; k++) {
        for (int i = k+gap; i < len; i += gap) {
        int j = i;
        while (j-gap >= 0 && a[j] < a[j-gap]) {
           int tmp = a[j];
           a[j] = a[j-gap];
           a[j-gap] = tmp;
           j -= gap;
        }
       }
      }
     }
    }
    int main() {
     int a[] = {-8, -93, -93, 2, -66, 78, 63, -34, 23, -36, -50, -79, 28, 34, -69, 60, 66, -47, -12, 60};
     int len = sizeof(a)/sizeof(a[0]);
     sort(a, len);
     for (int i = 0; i < len; i++) printf("%d, ", a[i]);
    }
    

.. code-block:: sh
   

    -93, -93, -79, -69, -66, -50, -47, -36, -34, -12, -8, 2, 23, 28, 34, 60, 60, 63, 66, 78, 



stable.scm
==============================


selection sortにて、以下をソート
- 2a 3 2b 1
- 1 3 2b 2a （1回目のループ終了時）
- 1 2b 3 2a （2回目のループ終了時）
- 1 2b 2a 3 （3回目のループ終了時）

2a, 2bの関係が逆順になっているので、不安定ソート
つまり、第一keyはソートされるが、それによって第二keyのソート順が保たれない
一般に、swapなどの破壊的な操作が必要なソートは不安定となる

