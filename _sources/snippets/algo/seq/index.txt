
=========
seq
=========

.. contents::
    :depth: 2



atLeastOne.scm
==========================================



配列の要素が、少なくとも1回ずつ出現する数列のうち、最小のもの
---------------------------------------------------------------------------------------------

CO 

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\i \in S_N, 0 \le i \le I (\in N) s.t.
    \\
    \\f(a) = \begin{cases}
    \\1 & (a \in S_N)
    \\0 & (else)
    \\\end{cases}
    \\
    \\// ちょっと違うっぽい
    \\\min_x g(S_N) = \begin{cases}
    \\x  & (sum_{i}^x f(i) = I)
    \\-1 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int g(int *S, int N, int I) {
     // c[0] is dummy
     int buff[I];
     memset(buff, 0, sizeof(int)*I);
     int sum = 0;
     for (int i = 0; i < N; i++) {
      int a = S[i];
      // if (a > I) continue;
      buff[a]++;
      if (buff[a] == 1)
        sum++;  // first found
      if (sum == I)
       return i;
     }
      return -1;
    }

.. code-block:: sh
   

    /usr/lib/crt1.o: In function `_start':
    /usr/src/lib/csu/amd64/crt1.c:(.text+0x14b): undefined reference to `main'
    clang: error: linker command failed with exit code 1 (use -v to see invocation)
    



newton.scm
==============================



簡易証明
------------

収束しそうな点を探す必要あり

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x)のx_nにおける接戦は以下の通り
    \\y = f'(x_n)(x - x_n) + f(x_n)
    \\
    \\この接戦は、(x_{n+1}, 0)を通過するので
    \\0 = f'(x_n)(x_{n+1} - x_n) + f(x_n)
    \\
    \\すなわち
    \\x_{n+1} = x_n - \frac{f(x_nf)}{f'(x_n)}
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\|\frac{x_{n+1} - x_n}{x_n}| < \epsion
    \\
    \end{eqnarray}



solve x^2 = n by newton
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        x_{n+1} = x_n - \frac{x}{2}
    \end{eqnarray}


.. code-block:: c
   

    #include <stdio.h>
    double abs(double x) { return x >= 0 ? x : -x; }
    double f(double n, double x1, double e) {
     while (1) {
      double x2 = x1 - (x1 * x1 - n) / (2 * x1);
      if (abs(x2-x1) < e) return x2;
      x1 = x2;
     }
    }
    int main() {
      printf("%f\n", f(2, 5, 0.001));
      printf("%f\n", f(100, 100, 0.001));
    }

.. code-block:: sh
   

    1.414214
    10.000000
    

