
=========
seq
=========

.. contents::
    :depth: 2



atLeastOne.scm
==========================================



配列の要素が、少なくとも1回ずつ出現する数列のうち、最小のもの
---------------------------------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\exists I \in N, \forall a_i \in S_N, 0 \le a_i \le I s.t.
    \\
    \\\min_{x} g(S_x) = \begin{cases} x  & (\sum_{i==0}^I f(i) = I + 1)
    \\-1 & (else)
    \\\end{cases}
    \\
    \\f(a) = \begin{cases} 1 & (a \in S_x)
    \\0 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int g(int *S, int N, int I) {
     I++; // range is [0, I]
     int buff[I];
     memset(buff, 0, sizeof(int) * I);
     int sum = 0;
     for (int i = 0; i < N; i++) {
      int a = S[i];
      // if (a > I) continue;
      buff[a]++;
      if (buff[a] == 1)
        sum++;  // first found
      if (sum == I)
       return i;
     }
      return -1;
    }
    int main() {
     int S[] = {4,4,1,2,0,5,5,3,1,2};   // 7
     P("%d\n", g(S, SIZE(S), 5));
    }

.. code-block:: sh
   

    7
    



contiguous-subsequence.scm
==============================================================================

ある数列の連続した部分数列の和の最大値

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i) &=& (\mbox{iにおける最大}, \mbox{iにおける総和}) = (m_i, s_i)
    \\s_1 &=& a_1
    \\m_1 &=& a_1
    \\s_i &=& \max \{ a_i, s_{i-1} + a_i \}
    \\m_i &=& \max \{ m_{i-1}, s_i \}
    \\
    \end{eqnarray}

今までの総和よりも大きい数ならば、それを優先

.. code-block:: ghc
   

    f (x:xs) = go x x xs where
     go s m [] = m
     go s m (x:xs) = go si mi xs where
      si = max (s + x) x
      mi = max m si
    main = do
     print $ f [-10]
     print $ f [0,4,-6,2,3]
     print $ f [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    -10
    5
    6
    


.. code-block:: ghc
   

    s :: [Int] -> Int
    s [x] = x
    s (x:xs) = max x (x + s xs)
    m :: [Int] -> Int
    m [x] = x
    m (x:xs) = max (m xs) (s $ x:xs)
    main = do
     print $ m [-10]
     print $ m [0,4,-6,2,3]
     print $ m [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    -10
    5
    6
    

result of a list

.. code-block:: ghc
   

    import Data.List (maximumBy)
    c a b = compare (sum a) (sum b)
    s [x] = [x]
    s (x:xs) = maximumBy c [[x], (x:(s xs))]
    m [x] = [x]
    m (x:xs) = maximumBy c [(m xs), (s(x:xs))]
    main = do
     print $ m [-10]
     print $ m [0,4,-6,2,3]
     print $ m [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    [-10]
    [2,3]
    [1,3,2]
    


.. code-block:: cpp
   

    #include <myutils.h>
    int f(vector<int> a) {
     if (a.empty()) return 0;
     int m, s;
     m = s = a[0];
     for (int i = 1; i < a.size(); i++) {
      s = max(s + a[i], a[i]);
      m = max(m, s);
     }
     return m;
    }
    int main() {
     P(f({1,-2,1,3,2,-5,1,-4,-3,1,-2}));
    }

.. code-block:: sh
   

    f({1,-2,1,3,2,-5,1,-4,-3,1,-2}) = 6
    



dominator.scm
=======================================



ある数列における、半数超過を占める要素を求める
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i,stackSize,n) = \begin{cases} f(i+1,stackSize+1, n) & (a_i = n)
    \\f(i+1,stackSize-1, n) & (a_i \ne n, stackSize > 0)
    \\f(i+1, 1, a_i) & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(a):
     def g(i, size, n):
      if i == len(a):
       return n
      elif a[i] == n:
       return g(i+1, size+1, n)
      elif size > 0:
       return g(i+1, size-1, n)
      else:
       assert size == 0
       return g(i+1, 1, a[i])
     d = g(0, 0, None)
     # 過半数を超えているか確認
     if 2 * len([x for x in a if x == d]) > len(a):
      return d
    print(f([1,1,1,2,1,2,3]))
    print(f([1,1,1,1,2,2,2]))
    print(f([1,1,1,2,2,2]))
    print(f([1,1,2,2,3]))
    print(f([2,1,2,3,4,2,3,4,2,3,2,1,1]))

.. code-block:: sh
   

    1
    1
    None
    None
    None
    



equileader.scm
==========================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\{a_n\} \mbox{の半分超過の要素x}  \quad s.t. \quad 
    \\2集合 \{a_1, a_2 ... a_i\}, \{a_{i+1}, a_{i+2} ... a_n \} \mbox{が、それぞれxが超過要素となる場合の数}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i, n, s) &=& f(i+1, N, S)
    \\where
    \\num &=& \{a_n\}におけるxの要素数
    \\N   &=& n + 1 (\mbox{if}  a_i = x)
    \\S   &=& s + 1 (\mbox{if}  2n \gl i + 1 and 2(num - n) \gl length(a_n) - (i + 1))
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(A, x):
     num = len([a for a in A if a == x])
     # nは、i番目までにおけるxの要素数
     s = n = 0
     for i in range(len(A)):
      if A[i] == x:
       n += 1
      # 区間[0, i]にて、    xが半分超過すること
      # 区間[i+1, n-1]にて、xが半分超過すること
      if 2 * n > i + 1 and 2 * (num - n) > len(A) - (i + 1):
       s += 1
     return s
    print(f([4, 3, 4, 4, 4, 2], 4))  # ([4], [3,4,4,4,2]), ([4,3,4], [4,4,2])
    print(f([2, 4, 4, 4, 4, 4], 4))

.. code-block:: sh
   

    2
    3
    



fib-move.scm
====================================

fibの歩数で移動

.. code-block:: py
   

    
    MAX = 2 ** 30 
    def make(N):
        f = [1, 1]
        for i in range(N):
            a = f[i+1] + f[i]
            f.append(a)
            if a > N:
                return f
        return f
    
    def solution(A):
        N = len(A)
        fibs = make(N)
        dp = [MAX] * (N+1)
        for f in fibs:
            n = f - 1
            if n == N or (0<= n < N and A[n] == 1):
                dp[n] = 1
        for i in range(N+1):
            if i == N:
                pass
            elif A[i] == 0:
                continue
            for f in fibs:
                n = i + f
                if not (n <= N):
                    break
                elif n == N or A[n] == 1:
                    dp[n] = min(dp[n],  dp[i]+1)
        return -1 if dp[N] == MAX else dp[N]
    A = [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0] 
    print(solution(A))
    

.. code-block:: sh
   

    3
    



grep.scm
========================



if the pattern matches line, then print the line and the N previous and N next lines
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i, n, q) = \begin{cases} f(i+1, N, \{\}) & (match(a_i, pattern))
    \\f(i+1, n-1, \{\})  & (n > 0)
    \\f(i+1, 0, insert(a_i, q)) & (else)
    \\\mbox{ただし、qは最大Nまでのfifoデータ構造}
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(lines, pattern, N):
     queue = []
     n = 0
     for line in lines:    
      if pattern in line:
       while queue:
        print(queue.pop(0))
       print(line)
       n = N
      elif n > 0:
       print(line)
       n -= 1
      else:
       queue.append(line)
       if len(queue) > N:
        queue.pop(0)
    f("1 p 3 2 1 4 3 3 4".split(), "3", 1); print("")
    f("1 p 3 2 1 4 3 3 4".split(), "3", 2); print("")
    f("1 p 3 2 1 4 3 3 4".split(), "2", 2); print("")

.. code-block:: sh
   

    p
    3
    2
    4
    3
    3
    4
    
    1
    p
    3
    2
    1
    4
    3
    3
    4
    
    p
    3
    2
    1
    4
    
    



horner.scm
==============================


.. math::
    :nowrap:

    \begin{eqnarray}
        y = \sum_{i=0}^{n} a_i x^i
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\S_n &=& a_0 x^n + a_1 x^{n-1} + ... + a_{n-1} x + a_n
    \\    &=& \sum_{i=0}^{n} a_i x^{n-i}
    \\    &=& \sum_{i=0}^{n-1} a_i x^{n-i} + a_n
    \\    &=& x \sum_{i=0}^{n-1} a_i x^{(n-1)-i} + a_n
    \\    &=& x S_{n-1} + a_n
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int S(int *a, int n, int x) {
     assert(n > 0);
     int s = a[0];
     for (int i = 1; i < n; i++)
      s = s * x + a[i];
     return s;
    }
    int main() {
     int a[] = {3,2,1};  // 3x^2 + 2x + 1
     P("%d\n", S(a, SIZE(a), 2));
     P("%d\n", S(a, SIZE(a), 1));
     P("%d\n", S(a, SIZE(a), 0));
    }

.. code-block:: sh
   

    17
    6
    1
    



one byte offset
---------------------------------------------

last - first = n - 1

.. math::
    :nowrap:

    \begin{eqnarray}
        \sum_{i=1}^{n} a_i = \sum_{i=0}^{n-1} a_{i+1} = \sum_{i=2}^{n+1} a_{i-1}
    \end{eqnarray}



inner-product.scm
===================================================



knapsack.scm
====================================


n個の詰め物があり、サイズとその価値が決まっている。
このとき、ナップザックのサイズのmaxSizeとし、詰め物の価値を最大にする組は何か？
なお、総当たりの場合の場合の数は2^nとなる


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\{ (a_i, b_i) &=& (詰め物のサイズ, その価値) \}
    \\\sum_i^n a_i x_i &\le& maxSize (ただし、x_i \in {0, 1})
    \\ \quad s.t. \quad  \max_{x_i} \sum_i^n b_i x_i
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        f(i, size)=\begin{cases} \max \{f(i-1, size), f(i-1, size + a_i) + b_i (\mbox{if}  size + a_i \le maxSize)\} \end{cases}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        f(i, size)=\begin{cases} \max \{f(i-1, size), f(i-1, size - a_i) + b_i (\mbox{if}  size - a_i \ge 0)\} \end{cases}
    \end{eqnarray}


.. code-block:: ghc
   

    -- pairs = [(size, price)] (逆方向)
    knapsack :: (Ord a, Num a) => [(a, a)] -> a -> a
    knapsack pairs size = go pairs size where
        go [] size = 0
        go ((s,p):sps) size =
          let
            ssize = size - s
            cap1 = go sps size  -- 現在の(s, p)を使わない
            cap2 = if ssize >= 0 then p + go sps ssize else 0
          in maximum [cap1, cap2]
    main = print $ knapsack [(x, 6-x) |x <- [1..5]] 6

.. code-block:: sh
   

    12
    

dp

.. code-block:: cpp
   

    #include <myutils.h>
    int solve(vector<int> sizes, vector<int> prices, int capacity) {
      assert(sizes.size() == prices.size());
      int S = sizes.size();
      vector<vector<int>> dp(sizes.size() + 1, vector<int>(capacity + 1, 0));
      for (int s = 0; s < S; s++) {
        for (int c = 0; c <= capacity; c++) {  // =を忘れない(順方向)
          int c1 = c- sizes[s];
          if (c1 >= 0)
            dp[s+1][c] = max(dp[s][c], dp[s][c1] + prices[s]);
          else
            dp[s+1][c] = dp[s][c];
        }
      }
      return dp[S][capacity];
    }
    int main() {
      P(solve({1,2,3,4,5},
              {5,4,3,2,1},
              6));
    }

.. code-block:: sh
   

    solve({1,2,3,4,5}, {5,4,3,2,1}, 6) = 12
    

dp

.. code-block:: cpp
   

    #include <myutils.h>
    // 配列の再利用(正直、ループの順方向と逆方向で結果が変わる理由がよくわかってない！)
    int solve(vector<int> sizes, vector<int> prices, int capacity) {
      assert(sizes.size() == prices.size());
      int S = sizes.size();
      vector<int> dp(capacity + 1, 0);
      for (int s = 0; s < S; s++)
       for (int c = capacity; c >= sizes[s]; c--)
        dp[c] = max(dp[c], dp[c-sizes[s]] + prices[s]);
      return dp[capacity];
    }
    int main() {
      P(solve({1,2,3,4,5},
              {5,4,3,2,1},
              6));
    }

.. code-block:: sh
   

    solve({1,2,3,4,5}, {5,4,3,2,1}, 6) = 12
    

再利用ができるのは、i=>i+1へ単純に値を渡している場合.


local-maximun.scm
===================================================

極大値

.. math::
    :nowrap:

    \begin{eqnarray}
        x[i-1] < x[i] > x[i+1]  \quad s.t. \quad  i \in \[1, n-1\]
    \end{eqnarray}


.. code-block:: py
   

    
    A = [5,6,5,6,1,1,1,1,6,5,6,5]
    N = len(A)
    P = [False] * N  # 極大値ならTrue
    Q = []  # 極大値をとるxを順に格納
    for i in range(1, N-1):
        if A[i-1] < A[i] > A[i+1]:
            P[i] = True
            Q.append(i)
    print(P)
    print(Q)
    

.. code-block:: sh
   

    [False, True, False, True, False, False, False, False, True, False, True, False]
    [1, 3, 8, 10]
    



longest-common-sequence.scm
=================================================================================

２数列の最長共通部分数列(連続する必要なし)

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x, y) = \begin{cases} 0 & (x = 0 or y = 0)
    \\f(x-1, y-1) + 1 & (x = y)
    \\\max \{f(x-1,y), f(x, y-1) \} & (else)
    \\\end{cases}
    \\
    \end{eqnarray}

f(x-1, y-1)は、f(x-1,y)とf(x,y-1)の次の遷移に含まれるから考慮しなくてよい.
１変数のみ動かし、他の変数を固定して考えるのだと思うけど、まだよくわかってない.
ただ、単純に(x,y)の手前は(x-1,y)か(x,y-1)ということで良さそう.

.. code-block:: ghc
   

    import Data.List (maximumBy)
    c a b = compare (length a) (length b)
    f = g where
     g xss@(x:xs) yss@(y:ys)
      | x == y    = x : g xs ys
      | otherwise = maximumBy c [(g xss ys), (g xs yss)]
     g _ _ = ""
    main = do
     print $ f "abcdefg" "bde"
     print $ f "abcdefg" "ace"
     print $ f "abcdefg" "kakcke"
     print $ f "abcdefg"       "kakdkbkekcdf"
     print $ f "azbzczdzezfzg" "kakdkbkekcdf"

.. code-block:: sh
   

    "bde"
    "ace"
    "ace"
    "abcdf"
    "abcdf"
    


.. code-block:: cpp
   

    #include "myutils.h"
    string f(string a, string b) {
      vector<vector<string>> dp(a.size()+1, vector<string>(b.size()+1 , ""));
     for (int x=0; x<a.size(); x++) {
      for (int y=0; y<b.size(); y++) {
       if (a[x] == b[y]) dp[x+1][y+1] = dp[x][y] + a[x];
       else {
        string s1 = dp[x][y+1], s2 = dp[x+1][y];
        dp[x+1][y+1] = (s1.size() > s2.size()) ? s1 : s2;
       }
      }
     }
     return dp[a.size()][b.size()];
    }
    int main() {
      P(f("abcdefg", "ace"));
      P(f("abcdefg", "kakcke"));
      P(f("abcdefg", "kakdkbkekcdf"));
      P(f("azbzczdzezfzg", "kakdkbkekcdf"));
    }

.. code-block:: sh
   

    f("abcdefg", "ace") = ace
    f("abcdefg", "kakcke") = ace
    f("abcdefg", "kakdkbkekcdf") = abcdf
    f("azbzczdzezfzg", "kakdkbkekcdf") = abcdf
    



longest-increasing-subsequence.scm
======================================================================================================

数列{a_n}における、最長部分増加数列

.. math::
    :nowrap:

    \begin{eqnarray}
        f(n) = 1 + \max \{ f(k) \mid 1 \le k < n, a_k > a_n \} \cup \{ 0 \}
    \end{eqnarray}


.. code-block:: ghc
   

    
    import Data.List (maximumBy)
    f :: [Int] -> [Int]
    f = g where
     c a b = compare (length a) (length b)
     -- g [] = []
     g (x:xs) = x : maximumBy c (map (h . flip drop xs) [0..(length xs)]) where
      h [] = []
      h ys = if head ys > x then g ys else []
    main = print $ f [3,2,5,1,3,1,7,4]
    

.. code-block:: sh
   

    [3,5,7]
    

この方法では、計算量がO(n^2)となる。そこでbinary searchを使い、O(nlogn)に減らす

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f_i = \begin{cases} (f_{i-1}, a_i}) & (f_{i-1, last} \le a_i)
    \\f_{i-1, x} := a_i & (\min_{a_i < f_{i-1,x}} x) \mbox{配列f_iのx番目をa_iで更新したもの(f_{i-1,x}はa_i以下)}
    \\f_{i-1} & (else)
    \\\end{cases}
    \\
    \end{eqnarray}

最小値は、2分木で探すことでlognで探せる

.. code-block:: cpp
   

    
    #include <myutils.h>
    int f(vector<int> a) {
     vector<int> dp;
     for (int i = 0; i < a.size(); i++) {
      if (dp.empty() || dp.back() < a[i])
       dp.push_back(a[i]);
      else {
       // *lower_bound(dp.begin(), dp.end(), a[i]) = a[i]; continue;
       int lo = 0, hi = dp.size() - 1, rt = 0;
       while (lo <= hi) {
        int mi = lo + (hi - lo) / 2;
        if (a[i] <= dp[mi]) {
         hi = mi - 1;
         rt = mi;
        } else
         lo = mi + 1;
       }
       dp[rt] = a[i];
      }
     }
     return dp.size();
    }
    int main() {
     P(f({3,2,5,1,3,1,7,4}));
     P(f({4,2,3,1,5}));
    }
    

.. code-block:: sh
   

    f({3,2,5,1,3,1,7,4}) = 3
    f({4,2,3,1,5}) = 3
    



max-interval-of-local-maximuns.scm
======================================================================================================

極大値における最大一定間隔

.. math::
    :nowrap:

    \begin{eqnarray}
        0 \le j \le K, S_n \mbox{を極大値の数列としたとき} |a_{ij} - a_{i(j+1)}| \ge \max K
    \end{eqnarray}


K=1のとき、間隔1の区間が1つとれるようにする。
K=1のとき、間隔Kの区間がkつとれるようにする。
なお、Kの最大は2分探索で求める


.. code-block:: py
   

    
    # 極大値が間隔Kで取れる場合はTrue
    def f(K, S):
        i = 0  # 左端から貪欲に
        N = len(S)
        for _ in range(K-1):  # 2つ目の間隔が取れるか?から開始
            if (i == N): return False
            P = S[i]
            j = i + 1
            while j < N:
                Q = S[j]
                if Q - P >= K: break
                j += 1
            if j == N: return False
            i = j
        return True
    A = [1,3,5,10]
    print(f(2, A))
    print(f(3, A))
    print(f(4, A))
    

.. code-block:: sh
   

    True
    True
    False
    



max-length-seq.scm
======================================================


.. math::
    :nowrap:

    \begin{eqnarray}
        {a_n}の要素の数列で、a_{in} > a_{i(n-1)} ... > a{i1}を満たす数列で、要素数が最大のものは？(1<=ik<=n)
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        a_n > a_k  \quad s.t. \quad  \max \# \{ f(a_n) \} = \{ a_n \} \cup \max_{0<=k<n} \# \{ f(a_k) \}
    \end{eqnarray}

pointは、f(n)はnより大きいものには依存せず、n未満で決まる
また、全ての場合の数は、2^nとなる.
S4=[0..3]に対して、以下のように分割する必要あり
S3=[1,2,3]
S2=[2,3]
S1=[3]
S0=[] -- ここまで必ず分割すること(終了条件)


.. code-block:: ghc
   

    -- TODO: f に該当する関数は何?
    import Data.List (maximumBy)
    maxLengthSequence :: [Int] -> [Int]
    maxLengthSequence = go where
      go [] = []
      go (x:xs) = x : (maximumBy f $ map g [0..length xs]) where
        f a b = compare (length a) (length b)
        g = go . filter (> x) . flip drop xs
    main = print $ maxLengthSequence [1,3,2,5,4,5,6];

.. code-block:: sh
   

    [1,2,4,5,6]
    


.. code-block:: cpp
   

    #include <myutils.h>
    vector<int> solve(vector<int> A) {
      function <vector<int>(int)> dfs = [&] (int depth) {
        if (depth < 0) return vector<int>();
        vector<int> seq;  // 本来はintでいいが結果も表示させたいので配列とした
        for (int i = depth - 1; i >= 0; i--) {
          if (A[i] < A[depth]) {
            vector<int> s = dfs(i);
            if (s.size() > seq.size())
              seq = s;
          }
        }
        seq.push_back(A[depth]);
        return seq;
      };
      return dfs(A.size() - 1);
    }
    int main() {
     PE(solve({1,2,3,4,5}));
     PE(solve({1,3,2,5,4,5,6}));
    }

.. code-block:: sh
   

    1, 2, 3, 4, 5, 
    1, 2, 4, 5, 6, 
    



max-number-group-of-local-maximuns.scm
==================================================================================================================

各一定区間内に極大値をもつよう区分

.. code-block:: py
   

    
    def f(groups, S):
        N = len(S)
        assert N % groups == 0
        interval = N / groups
        for _ in range(groups):
            for i in range(0, N, interval):
                last = i + interval  # groupsでNを割り切れるなら、lastは常に区間の最後(端点は含まない)
                while i < last:
                    if S[i]: break
                    i += 1
                if i == last: return False
        return True
    A = [False, True, False, True, False, False, False, False, True, False, True, False]
    print(f(2, A))
    print(f(3, A))
    print(f(4, A))
    

.. code-block:: sh
   

    True
    False
    True
    



max-profit.scm
==========================================



株価の儲けの最大を求める
------------------------------------

差を求めて、それに対してKadane’s algorithを適用

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\d(i) = f(i+1) - f(i) (1 \le i \le n - 1)
    \\g(i) = (m_i, s_i)
    \\s_1 = m_1 = d(1)
    \\s_i = \max \{d(i), s_{i-1} + d(i) \}
    \\m_i = \max \{m_{i-1}, s_i\}
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f (x:y:xs)= g (x-y) (x-y) (y:xs) where
     g s m [x] = max m 0
     g s m (x:y:xs) = g ns nm (y:xs) where
      d  = x - y
      ns = max d (s + d)
      nm = max m ns
    main = do
     print $ f $ reverse [4,1,2,5,3]
     print $ f $ reverse [5,4,3,2,1]

.. code-block:: sh
   

    4
    0
    



newton.scm
==============================



簡易証明
------------

収束しそうな点を探す必要あり

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x)のx_nにおける接戦は以下の通り
    \\y = f'(x_n)(x - x_n) + f(x_n)
    \\
    \\この接戦は、(x_{n+1}, 0)を通過するので
    \\0 = f'(x_n)(x_{n+1} - x_n) + f(x_n)
    \\
    \\すなわち
    \\x_{n+1} = x_n - \frac{f(x_nf)}{f'(x_n)}
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\|\frac{x_{n+1} - x_n}{x_n}| < \epsilon
    \\
    \end{eqnarray}



solve x^2 = n by newton
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        x_{n+1} = x_n - \frac{x_n * x_n - 2}{2 * x_n}
    \end{eqnarray}


.. code-block:: c
   

    #include <stdio.h>
    double abs(double x) { return x >= 0 ? x : -x; }
    double f(double n, double x1, double e) {
     while (1) {
      double x2 = x1 - (x1 * x1 - n) / (2 * x1);
      if (abs(x2-x1) < e) return x2;
      x1 = x2;
     }
    }
    int main() {
      printf("%f\n", f(2, 5, 0.001));
      printf("%f\n", f(100, 100, 0.001));
    }

.. code-block:: sh
   

    1.414214
    10.000000
    



partition-function.scm
==================================================================



subset-sum.scm
==========================================


.. math::
    :nowrap:

    \begin{eqnarray}
        s \subseteq S s.t. \sum_{a_i \in s} a_i = 0
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(0, 0) &=& \{ \phi \}
    \\f(0, k) &=& \phi (k \neq 0)
    \\f(n, k) &=& \{ cons(a_n, x) \mid x \in f(n-1, k-a_n) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f x = go x 0 where
     go [] 0 = [[]]
     go [] _ = []
     go (x:xs) k = map (x:) (go xs (k-x)) ++ go xs k
    main = print $ f [1,2,-1,-2,3]

.. code-block:: sh
   

    [[1,2,-1,-2],[1,-1],[2,-2],[-1,-2,3],[]]
    


.. math::
    :nowrap:

    \begin{eqnarray}
        s \subseteq S, s \neq \phi s.t. \sum_{a_i \in s} a_i = 0
    \end{eqnarray}

.. todo:: 最後の要素を必ず使うようになってるのを修正

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(1, a_1) &=& \{ a_1 \}
    \\f(1, k) &=& \phi (k \neq a_1)
    \\f(n, k) &=& \{ cons(a_n, x) \mid x \in f(n-1, k-a_n) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f x = go x 0 where
     go [x] k = if x == k then [[x]] else []
     go (x:xs) k = map (x:) (go xs (k-x)) ++ go xs k
    main = print $ f [1,2,-1,-2,3]

.. code-block:: sh
   

    [[-1,-2,3]]
    



sum-n-coins.scm
=============================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\k_n * a_n + k_{n-1} * a_{n-1} + ... + k_1 * a_1 = SUM
    \\k_i >= 0, a_n > a_{n-1} > ... > a_1 > 0
    \\s.t. \quad \min \sum_{i=1}^n k_i
    \\
    \\使用するコインの集合を返す関数をfとおくと
    \\f(a_n, SUM) =  [an] * k_n \cup f(a_{n-1}, SUM - a_n \times k_n)
    \\f(a_0, X) = \phi
    \\ただし
    \\0 \le i \le \frac{SUM}{a_n}
    \\\sum f(a_n, SUM) == SUM
    \\
    \end{eqnarray}


この問題は、お釣りの問題に帰着できる
大きいお金を使えるだけ使って、その次にいく
ただし、失敗するかもしれない(最後が1でない場合で辻褄が合わせられない)


.. code-block:: ghc
   

    import Data.List
    
    solve :: [Int] -> Int -> [[Int]]
    solve [] sum = [[]]
    solve (c:coins) csum = concatMap (g . f) [0 .. (div csum c)]
      where
        -- xは、cにおける使用するコインの枚数
        -- fは、c:coinsにおける使用するコインのリストを返す
        f x = map ((take x (repeat c)) ++) (solve coins (csum - c * x))
        g = filter (\a-> sum a == csum)
    
    main = do
      -- mapM print $ solve [25, 10, 5, 1] 100
      print $ Data.List.minimumBy (\a b -> compare (length a) (length b)) $ solve [25, 10, 5, 1] 100

.. code-block:: sh
   

    [25,25,25,25]
    



totient.scm
=================================

