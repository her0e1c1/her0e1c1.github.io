
=========
seq
=========

.. contents::
    :depth: 2



atLeastOne.scm
==========================================



配列の要素が、少なくとも1回ずつ出現する数列のうち、最小のもの
---------------------------------------------------------------------------------------------

CO 

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\exists I \in N, \forall a_i \in S_N, 0 \le a_i \le I s.t.
    \\
    \\\min_{x} g(S_x) = \begin{cases}
    \\x  & (\sum_{i==0}^I f(i) = I + 1)
    \\-1 & (else)
    \\\end{cases}
    \\
    \\f(a) = \begin{cases}
    \\1 & (a \in S_x)
    \\0 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int g(int *S, int N, int I) {
     I++; // range is [0, I]
     int buff[I];
     memset(buff, 0, sizeof(int) * I);
     int sum = 0;
     for (int i = 0; i < N; i++) {
      int a = S[i];
      // if (a > I) continue;
      buff[a]++;
      if (buff[a] == 1)
        sum++;  // first found
      if (sum == I)
       return i;
     }
      return -1;
    }
    int main() {
     int S[] = {4,4,1,2,0,5,5,3,1,2};   // 7
     P("%d\n", g(S, SIZE(S), 5));
    }

.. code-block:: sh
   

    7
    



contiguous-subsequence.scm
==============================================================================


.. warning::

    ある数列の連続した部分数列の和の最大値


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i) = (\mbox{iにおける最大}, \mbox{iにおける総和}) = (m_i, s_i)
    \\s_1 = a_1
    \\m_1 = a_1
    \\s_i = \max \{ a_i, s_{i-1} + a_i \}
    \\m_i = \max \{ m_{i-1}, s_i \}
    \\
    \end{eqnarray}

大きい負の数が来たら、足さずに0から再度開始

.. code-block:: ghc
   

    f (x:xs) = go x x xs where
     go s m [] = m
     go s m (x:xs) = go y n xs where
      y = max (s + x) x
      n = max m y
    main = do
     print $ f [-10]
     print $ f [0,4,-6,2,3]
     print $ f [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    -10
    5
    6
    


.. code-block:: ghc
   

    s :: [Int] -> Int
    s [x] = x
    s (x:xs) = max x (x + s xs)
    m :: [Int] -> Int
    m [x] = x
    m (x:xs) = max (m xs) (s $ x:xs)
    main = do
     print $ m [-10]
     print $ m [0,4,-6,2,3]
     print $ m [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    -10
    5
    6
    

result of a list

.. code-block:: ghc
   

    import Data.List (maximumBy)
    c a b = compare (sum a) (sum b)
    s [x] = [x]
    s (x:xs) = maximumBy c [[x], (x:(s xs))]
    m [x] = [x]
    m (x:xs) = maximumBy c [(m xs), (s(x:xs))]
    main = do
     print $ m [-10]
     print $ m [0,4,-6,2,3]
     print $ m [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    [-10]
    [2,3]
    [1,3,2]
    



dominator.scm
=======================================



ある数列における、半数超過を占める要素を求める
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i,stack_size,n) = \begin{cases}
    \\f(i+1,stack_size+1, n) & (a_i = n)
    \\f(i+1,stack_size-1, n) & (a_i \ne n, stack_size > 0)
    \\f(i+1, 1, a_i) & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(a):
     def g(i, size, n):
      print(i, size, n)
      if i == len(a):
       return n
      elif a[i] == n:
       return g(i+1, size+1, n)
      elif size > 0:
       return g(i+1, size-1, n)
      else:
       return g(i+1, 1, a[i])
     return g(0, 0, None)
     # return g(0, 1, a[0])  # こっちだと半分以上になる?
    print(f([2,1,2,3,4,2,3,4,2,3,2]))
    print(f([1,1,1,2,1,2,3]))
    print(f([1,1,1,2,2,2]))
    print(f([1,1,2,2,3]))  # 候補がない場合のバリデーションも別途必要そう

.. code-block:: sh
   

    (0, 0, None)
    (1, 1, 2)
    (2, 0, 2)
    (3, 1, 2)
    (4, 0, 2)
    (5, 1, 4)
    (6, 0, 4)
    (7, 1, 3)
    (8, 0, 3)
    (9, 1, 2)
    (10, 0, 2)
    (11, 1, 2)
    2
    (0, 0, None)
    (1, 1, 1)
    (2, 2, 1)
    (3, 3, 1)
    (4, 2, 1)
    (5, 3, 1)
    (6, 2, 1)
    (7, 1, 1)
    1
    (0, 0, None)
    (1, 1, 1)
    (2, 2, 1)
    (3, 3, 1)
    (4, 2, 1)
    (5, 1, 1)
    (6, 0, 1)
    1
    (0, 0, None)
    (1, 1, 1)
    (2, 2, 1)
    (3, 1, 1)
    (4, 0, 1)
    (5, 1, 3)
    3
    



equileader.scm
==========================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\{a_n\} \mbox{の半分超過の要素x}  \quad s.t. \quad  2集合 \{a_1, a_2 ... a_k\}, \{a_{k+1}, a_{k+2} ... a_n \}
    \\\mbox{が、それぞれxが超過要素となる場合の数}
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i, n, s) = f(i+1, N, S)
    \\where
    \\num = \mbox{\{a_n\}におけるxの要素数}
    \\N = n + 1 (if a_i = x)
    \\S = s + 1 (if 2n > i + 1, 2(num - n) > length(a_n) - (i + 1))
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(A, d):
     num = len([a for a in A if a == d])
     s = 0
     n = 0
     for i in range(len(A)):
      if A[i] == d:
       n += 1
      if 2 * n > i + 1 and 2 * (num - n) > len(A) - (i + 1):
       s += 1
     return s
    print(f([4, 3, 4, 4, 4, 2], 4))

.. code-block:: sh
   

    2
    



grep.scm
========================



if the pattern matches line, then print the line and the N previous and N next lines
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i, n, q) = \begin{cases}
    \\f(i+1, N, \{\}) & (match(a_i, pattern))
    \\f(i+1, n-1, \{\})  & (n > 0)
    \\f(i+1, 0, insert(a_1, q)) & (else)
    \\\mbox{ただし、qは最大NまでのF\mbox{if} \quad Oデータ構造}
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: py
   

    def f(lines, pattern, N):
     queue = []
     n = 0
     for line in lines:    
      if pattern in line:
       while queue:
        print(queue.pop(0))
       print(line)
       n = N
      elif n > 0:
       print(line)
       n =- 1
      else:
       queue.append(line)
      if len(queue) > N:
       queue.pop(0)
    f("1 p 3 2 1 4 3 3 4".split(), "3", 2)

.. code-block:: sh
   

    1
    p
    3
    2
    1
    4
    3
    3
    4
    



horner.scm
==============================


.. math::
    :nowrap:

    \begin{eqnarray}
        y = \sum_{i=0}^{n} a_i x^i
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\S_0 & = & a_n
    \\S_1 & = & a_n x + a_{n-1} & = & S_0 * x + a_{n-1}
    \\S_2 & = & a_n x^2 + a_{n-1} x + a_{n-2} & = & S_1 * x + a_{n-2}
    \\...
    \\S_i & = & S_{i-1} * x + a_{n-i}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int S(int *a, int n, int x) {
     int y = a[n - 1];
     for (int i = n - 2; i >= 0; i--)
      y = y * x + a[i];
     return y;
    }
    int main() {
     int a[] = {3,2,1};
     P("%d", S(a, SIZE(a), 2));
    }

.. code-block:: sh
   

    11



inner-product.scm
===================================================



knapsack.scm
====================================


n個の詰め物があり、サイズとその価値が決まっている。
このとき、ナップザックのサイズのmaxSizeとし、詰め物の価値を最大にする組は何か？
なお、総当たりの場合の場合の数は2^nとなる


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\{ (a_i, b_i) &=& (詰め物のサイズ, その価値) \}
    \\\sum_i^n a_i x_i &\le& maxSize (ただし、x_i \in {0, 1})
    \\ \quad s.t. \quad  \max_{x_i} \sum_i^n b_i x_i
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(i, size) = \begin{cases} \max \{f(i-1, size), f(i-1, size+a_i) + b_i (\mbox{if} \quad  size + a_i \le maxSize) \}
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    -- pairs = [(size, price)]
    knapsack :: (Ord a, Num a) => [(a, a)] -> a -> a
    knapsack pairs max_size = go pairs 0 where
        go [] size = 0
        go ((s,p):sps) size =
          let
            ssize = s + size
            cap1 = go sps size  -- 現在の(s, p)を使わない
            cap2 = if ssize <= max_size then p + go sps ssize else 0
          in maximum [cap1, cap2]
    main = print $ knapsack [(x, 6-x) |x <- [1..5]] 6

.. code-block:: sh
   

    12
    


.. code-block:: cpp
   

    #include <myutils.h>
    int solve(vector<int> sizes, vector<int> prices, int capacity) {
      assert(sizes.size() == prices.size());
    
      vector<vector<int>> memo(sizes.size() + 1, vector<int>(capacity + 1, -1));
    
      function <int(int, int)> dfs = [&] (int depth, int size) {
        if (memo[depth][size] != -1)
          return memo[depth][size];
    
        if (depth == sizes.size())
          return 0;
    
        // 使用しない場合
        int price = dfs(depth + 1, size);
    
        // 使用する場合(容量を超えないようにする)
        int s = sizes[depth];
        if (s + size <= capacity)
          price = max(price, prices[depth] + dfs(depth + 1, s + size));
    
        return memo[depth][size] = price;
      };
      return dfs(0, 0);
    }
    
    int main() {
      P(solve({1,2,3,4,5},
              {5,4,3,2,1},
              6));
    }

.. code-block:: sh
   

    solve({1,2,3,4,5}, {5,4,3,2,1}, 6) = 12
    



longest-common-sequence.scm
=================================================================================

２数列の最長共通部分数列

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x, y) = \begin{cases} 0 (x = 0 or y = 0)
    \\f(x-1, y-1) (x = y)
    \\max{f(x-1,y), f(x, y-1)}
    \\\end{cases}
    \\
    \end{eqnarray}

１変数のみ動かし、他の変数を固定して考えるのだと思うけど、まだよくわかってない


longest-increasing-subsequence.scm
======================================================================================================

数列{a_n}における、最長部分増加数列

.. math::
    :nowrap:

    \begin{eqnarray}
        f(n) = 1 + \max \{ f(k) \mid 1 \le k < n, a_k > a_n \} \cup \{ 0 \}
    \end{eqnarray}


.. code-block:: ghc
   

    import Data.List (maximumBy)
    f :: [Int] -> [Int]
    f = g where
     c a b = compare (length a) (length b)
     -- g [] = []
     g (x:xs) = x : maximumBy c (map (h . flip drop xs) [0..(length xs)]) where
      h [] = []
      h ys = if head ys > x then g ys else []
    main = print $ f [3,2,5,1,3,1,7,4]

.. code-block:: sh
   

    [3,5,7]
    

この方法では、計算量がO(n^2)となる。そこでbinary searchを使い、O(nlogn)に減らす

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f_{i+1} = \begin{cases} (f_i, a_{i+1}) & (f_{i, last} =< a_{i+1})
    \\f_{i, x} := a_{i+1} & (\min_{a_{i+1} < f_{i,x}} x)
    \\f_{i} & (else)
    \\\end{cases}
    \\
    \end{eqnarray}

最小値は、2分木で探すことでlognで探せる


max-length-seq.scm
======================================================


.. math::
    :nowrap:

    \begin{eqnarray}
        {a_n}の要素の数列で、a_{in} > a_{i(n-1)} ... > a{i1}を満たす数列で、要素数が最大のものは？(1<=ik<=n)
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        a_n > a_k  \quad s.t. \quad  \max \# \{ f(a_n) \} = \{ a_n \} \cup \max_{0<=k<n} \# \{ f(a_k) \}
    \end{eqnarray}

pointは、f(n)はnより大きいものには依存せず、n未満で決まる
また、全ての場合の数は、2^nとなる.
S4=[0..3]に対して、以下のように分割する必要あり
S3=[1,2,3]
S2=[2,3]
S1=[3]
S0=[] -- ここまで必ず分割すること(終了条件)


.. code-block:: ghc
   

    -- TODO: f に該当する関数は何?
    import Data.List (maximumBy)
    maxLengthSequence :: [Int] -> [Int]
    maxLengthSequence = go where
      go [] = []
      go (x:xs) = x : (maximumBy f $ map g [0..length xs]) where
        f a b = compare (length a) (length b)
        g = go . filter (> x) . flip drop xs
    main = print $ maxLengthSequence [1,3,2,5,4,5,6];

.. code-block:: sh
   

    [1,2,4,5,6]
    


.. code-block:: cpp
   

    #include <myutils.h>
    vector<int> solve(vector<int> A) {
      function <vector<int>(int)> dfs = [&] (int depth) {
        if (depth < 0) return vector<int>();
        vector<int> seq;  // 本来はintでいいが結果も表示させたいので配列とした
        for (int i = depth - 1; i >= 0; i--) {
          if (A[i] < A[depth]) {
            vector<int> s = dfs(i);
            if (s.size() > seq.size())
              seq = s;
          }
        }
        seq.push_back(A[depth]);
        return seq;
      };
      return dfs(A.size() - 1);
    }
    int main() {
     PE(solve({1,2,3,4,5}));
     PE(solve({1,3,2,5,4,5,6}));
    }

.. code-block:: sh
   

    1, 2, 3, 4, 5, 
    1, 2, 4, 5, 6, 
    



max-profit.scm
==========================================



株価の儲けの最大を求める
------------------------------------

差を求めて、それに対してKadane’s algorithを適用

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\d(i) = f(i+1) - f(i) (1 \le i \le n - 1)
    \\g(i) = (m_i, s_i)
    \\s_1 = m_1 = d(1)
    \\s_i = \max \{d(i), s_{i-1} + d(i) \}
    \\m_i = \max \{m_{i-1}, s_i\}
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f (x:y:xs)= g (x-y) (x-y) (y:xs) where
     g s m [x] = max m 0
     g s m (x:y:xs) = g ns nm (y:xs) where
      d  = x - y
      ns = max d (s + d)
      nm = max m ns
    main = do
     print $ f $ reverse [4,1,2,5,3]
     print $ f $ reverse [5,4,3,2,1]

.. code-block:: sh
   

    4
    0
    



newton.scm
==============================



簡易証明
------------

収束しそうな点を探す必要あり

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x)のx_nにおける接戦は以下の通り
    \\y = f'(x_n)(x - x_n) + f(x_n)
    \\
    \\この接戦は、(x_{n+1}, 0)を通過するので
    \\0 = f'(x_n)(x_{n+1} - x_n) + f(x_n)
    \\
    \\すなわち
    \\x_{n+1} = x_n - \frac{f(x_nf)}{f'(x_n)}
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\|\frac{x_{n+1} - x_n}{x_n}| < \epsilon
    \\
    \end{eqnarray}



solve x^2 = n by newton
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        x_{n+1} = x_n - \frac{x_n * x_n - 2}{2 * x_n}
    \end{eqnarray}


.. code-block:: c
   

    #include <stdio.h>
    double abs(double x) { return x >= 0 ? x : -x; }
    double f(double n, double x1, double e) {
     while (1) {
      double x2 = x1 - (x1 * x1 - n) / (2 * x1);
      if (abs(x2-x1) < e) return x2;
      x1 = x2;
     }
    }
    int main() {
      printf("%f\n", f(2, 5, 0.001));
      printf("%f\n", f(100, 100, 0.001));
    }

.. code-block:: sh
   

    1.414214
    10.000000
    



subset-sum.scm
==========================================


.. math::
    :nowrap:

    \begin{eqnarray}
        s \subseteq S s.t. \sum_{a_i \in s} a_i = 0
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(0, 0) &=& \{ \phi \}
    \\f(0, k) &=& \phi (k \neq 0)
    \\f(n, k) &=& \{ cons(a_n, x) \mid x \in f(n-1, k-a_n) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f x = go x 0 where
     go [] 0 = [[]]
     go [] _ = []
     go (x:xs) k = map (x:) (go xs (k-x)) ++ go xs k
    main = print $ f [1,2,-1,-2,3]

.. code-block:: sh
   

    [[1,2,-1,-2],[1,-1],[2,-2],[-1,-2,3],[]]
    


.. math::
    :nowrap:

    \begin{eqnarray}
        s \subseteq S, s \neq \phi s.t. \sum_{a_i \in s} a_i = 0
    \end{eqnarray}

.. todo:: 最後の要素を必ず使うようになってるのを修正

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(1, a_1) &=& \{ a_1 \}
    \\f(1, k) &=& \phi (k \neq a_1)
    \\f(n, k) &=& \{ cons(a_n, x) \mid x \in f(n-1, k-a_n) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f x = go x 0 where
     go [x] k = if x == k then [[x]] else []
     go (x:xs) k = map (x:) (go xs (k-x)) ++ go xs k
    main = print $ f [1,2,-1,-2,3]

.. code-block:: sh
   

    [[-1,-2,3]]
    



sum-n-coins.scm
=============================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\k_n * a_n + k_{n-1} * a_{n-1} + ... + k_1 * a_1 = SUM
    \\k_i >= 0, a_n > a_{n-1} > ... > a_1 > 0
    \\s.t. \quad \min \sum_{i=1}^n k_i
    \\
    \\使用するコインの集合を返す関数をfとおくと
    \\f(a_n, SUM) =  [an] * k_n \cup f(a_{n-1}, SUM - a_n \times k_n)
    \\f(a_0, X) = \phi
    \\ただし
    \\0 \le i \le \frac{SUM}{a_n}
    \\\sum f(a_n, SUM) == SUM
    \\
    \end{eqnarray}


この問題は、お釣りの問題に帰着できる
大きいお金を使えるだけ使って、その次にいく
ただし、失敗するかもしれない(最後が1でない場合で辻褄が合わせられない)


.. code-block:: ghc
   

    import Data.List
    
    solve :: [Int] -> Int -> [[Int]]
    solve [] sum = [[]]
    solve (c:coins) csum = concatMap (g . f) [0 .. (div csum c)]
      where
        -- xは、cにおける使用するコインの枚数
        -- fは、c:coinsにおける使用するコインのリストを返す
        f x = map ((take x (repeat c)) ++) (solve coins (csum - c * x))
        g = filter (\a-> sum a == csum)
    
    main = do
      -- mapM print $ solve [25, 10, 5, 1] 100
      print $ Data.List.minimumBy (\a b -> compare (length a) (length b)) $ solve [25, 10, 5, 1] 100

.. code-block:: sh
   

    [25,25,25,25]
    



totient.scm
=================================

