
=========
seq
=========

.. contents::
    :depth: 2



atLeastOne.scm
==========================================



配列の要素が、少なくとも1回ずつ出現する数列のうち、最小のもの
---------------------------------------------------------------------------------------------

CO 

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\\exists I \in N, \forall a_i \in S_N, 0 \le a_i \le I s.t.
    \\
    \\\min_{x} g(S_x) = \begin{cases}
    \\x  & (\sum_{i==0}^I f(i) = I + 1)
    \\-1 & (else)
    \\\end{cases}
    \\
    \\f(a) = \begin{cases}
    \\1 & (a \in S_x)
    \\0 & (else)
    \\\end{cases}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int g(int *S, int N, int I) {
     I++; // range is [0, I]
     int buff[I];
     memset(buff, 0, sizeof(int) * I);
     int sum = 0;
     for (int i = 0; i < N; i++) {
      int a = S[i];
      // if (a > I) continue;
      buff[a]++;
      if (buff[a] == 1)
        sum++;  // first found
      if (sum == I)
       return i;
     }
      return -1;
    }
    int main() {
     int S[] = {4,4,1,2,0,5,5,3,1,2};   // 7
     P("%d\n", g(S, SIZE(S), 5));
    }

.. code-block:: sh
   

    7
    



contiguous-subseq.scm
===============================================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(1) = \{ a_1 \}
    \\f(n) = \max {f(n-1) + a_n, a_n}
    \\
    \end{eqnarray}

ある数列の連続した部分数列の和の最大値

.. code-block:: ghc
   

    f = go where
     go [x] = x
     go (x:xs) = max x ((go xs) + x)
    main = print $ f [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    5
    

result of a list

.. code-block:: ghc
   

    import Data.List (maximumBy)
    f :: [Int] -> [Int]
    f = go where
     go [x] = [x]
     go (x:xs) = maximumBy cmp [[x], (x:go xs)]
     cmp a b = compare (sum a) (sum b)
    main = print $ f [1,-2,1,3,2,-5,1,-4,-3,1,-2]

.. code-block:: sh
   

    [1,-2,1,3,2]
    



horner.scm
==============================


.. math::
    :nowrap:

    \begin{eqnarray}
        y = \sum_{i=0}^{n} a_i x^i
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\S_0 & = & a_n
    \\S_1 & = & a_n x + a_{n-1} & = & S_0 * x + a_{n-1}
    \\S_2 & = & a_n x^2 + a_{n-1} x + a_{n-2} & = & S_1 * x + a_{n-2}
    \\...
    \\S_i & = & S_{i-1} * x + a_{n-i}
    \\
    \end{eqnarray}


.. code-block:: c
   

    #include <myc.h>
    int S(int *a, int n, int x) {
     int y = a[n - 1];
     for (int i = n - 2; i >= 0; i--)
      y = y * x + a[i];
     return y;
    }
    int main() {
     int a[] = {3,2,1};
     P("%d", S(a, SIZE(a), 2));
    }

.. code-block:: sh
   

    11



inner-product.scm
===================================================



knapsack.scm
====================================



longest-common-sequence.scm
=================================================================================

２数列の最長共通部分数列

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x, y) = \begin{cases} 0 (x = 0 or y = 0)
    \\f(x-1, y-1) (x = y)
    \\max{f(x-1,y), f(x, y-1)}
    \\\end{cases}
    \\
    \end{eqnarray}

１変数のみ動かし、他の変数を固定して考えるのだと思うけど、まだよくわかってない


longest-increasing-subsequence.scm
======================================================================================================

数列{a_n}における、最長部分増加数列

.. math::
    :nowrap:

    \begin{eqnarray}
        f(n) = 1 + \max \{ f(k) \mid 1 \le k < n, a_k > a_n \} \cup \{ 0 \}
    \end{eqnarray}


.. code-block:: ghc
   

    import Data.List (maximumBy)
    f :: [Int] -> [Int]
    f = g where
     c a b = compare (length a) (length b)
     -- g [] = []
     g (x:xs) = x : maximumBy c (map (h . flip drop xs) [0..(length xs)]) where
      h [] = []
      h ys = if head ys > x then g ys else []
    main = print $ f [3,2,5,1,3,1,7,4]

.. code-block:: sh
   

    [3,5,7]
    

この方法では、計算量がO(n^2)となる。そこでbinary searchを使い、O(nlogn)に減らす

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f_{i+1} = \begin{cases} (f_i, a_{i+1}) & (f_{i, last} =< a_{i+1})
    \\f_{i, x} := a_{i+1} & (\min_{a_{i+1} < f_{i,x}} x)
    \\f_{i} & (else)
    \\\end{cases}
    \\
    \end{eqnarray}

最小値は、2分木で探すことでlognで探せる


max-length-seq.scm
======================================================


.. math::
    :nowrap:

    \begin{eqnarray}
        {a_n}の要素の数列で、a_{in} > a_{i(n-1)} ... > a{i1}を満たす数列で、要素数が最大のものは？(1<=ik<=n)
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        a_n > a_k \quad s.t \quad \max \# \{ f(a_n) \} = \{ a_n \} \cup \max_{0<=k<n} \# \{ f(a_k) \}
    \end{eqnarray}

pointは、f(n)はnより大きいものには依存せず、n未満で決まる
また、全ての場合の数は、2^nとなる.
S4=[0..3]に対して、以下のように分割する必要あり
S3=[1,2,3]
S2=[2,3]
S1=[3]
S0=[] -- ここまで必ず分割すること(終了条件)


.. code-block:: ghc
   

    -- TODO: f に該当する関数は何?
    import Data.List (maximumBy)
    maxLengthSequence :: [Int] -> [Int]
    maxLengthSequence = go where
      go [] = []
      go (x:xs) = x : (maximumBy f $ map g [0..length xs]) where
        f a b = compare (length a) (length b)
        g = go . filter (> x) . flip drop xs
    main = print $ maxLengthSequence [1,3,2,5,4,5,6];

.. code-block:: sh
   

    [1,2,4,5,6]
    


.. code-block:: cpp
   

    #include <myutils.h>
    vector<int> solve(vector<int> A) {
      function <vector<int>(int)> dfs = [&] (int depth) {
        if (depth < 0) return vector<int>();
        vector<int> seq;  // 本来はintでいいが結果も表示させたいので配列とした
        for (int i = depth - 1; i >= 0; i--) {
          if (A[i] < A[depth]) {
            vector<int> s = dfs(i);
            if (s.size() > seq.size())
              seq = s;
          }
        }
        seq.push_back(A[depth]);
        return seq;
      };
      return dfs(A.size() - 1);
    }
    int main() {
     PE(solve({1,2,3,4,5}));
     PE(solve({1,3,2,5,4,5,6}));
    }

.. code-block:: sh
   

    1, 2, 3, 4, 5, 
    1, 2, 4, 5, 6, 
    



newton.scm
==============================



簡易証明
------------

収束しそうな点を探す必要あり

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(x)のx_nにおける接戦は以下の通り
    \\y = f'(x_n)(x - x_n) + f(x_n)
    \\
    \\この接戦は、(x_{n+1}, 0)を通過するので
    \\0 = f'(x_n)(x_{n+1} - x_n) + f(x_n)
    \\
    \\すなわち
    \\x_{n+1} = x_n - \frac{f(x_nf)}{f'(x_n)}
    \\
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\|\frac{x_{n+1} - x_n}{x_n}| < \epsilon
    \\
    \end{eqnarray}



solve x^2 = n by newton
---------------------------------------------------------------------


.. math::
    :nowrap:

    \begin{eqnarray}
        x_{n+1} = x_n - \frac{x_n * x_n - 2}{2 * x_n}
    \end{eqnarray}


.. code-block:: c
   

    #include <stdio.h>
    double abs(double x) { return x >= 0 ? x : -x; }
    double f(double n, double x1, double e) {
     while (1) {
      double x2 = x1 - (x1 * x1 - n) / (2 * x1);
      if (abs(x2-x1) < e) return x2;
      x1 = x2;
     }
    }
    int main() {
      printf("%f\n", f(2, 5, 0.001));
      printf("%f\n", f(100, 100, 0.001));
    }

.. code-block:: sh
   

    1.414214
    10.000000
    



subset-sum.scm
==========================================


.. math::
    :nowrap:

    \begin{eqnarray}
        s \subseteq S s.t. \sum_{a_i \in s} a_i = 0
    \end{eqnarray}


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(0, 0) &=& \{ \phi \}
    \\f(0, k) &=& \phi (k \neq 0)
    \\f(n, k) &=& \{ cons(a_n, x) \mid x \in f(n-1, k-a_n) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f x = go x 0 where
     go [] 0 = [[]]
     go [] _ = []
     go (x:xs) k = map (x:) (go xs (k-x)) ++ go xs k
    main = print $ f [1,2,-1,-2,3]

.. code-block:: sh
   

    [[1,2,-1,-2],[1,-1],[2,-2],[-1,-2,3],[]]
    


.. math::
    :nowrap:

    \begin{eqnarray}
        s \subseteq S, s \neq \phi s.t. \sum_{a_i \in s} a_i = 0
    \end{eqnarray}

.. todo:: 最後の要素を必ず使うようになってるのを修正

.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\f(1, a_1) &=& \{ a_1 \}
    \\f(1, k) &=& \phi (k \neq a_1)
    \\f(n, k) &=& \{ cons(a_n, x) \mid x \in f(n-1, k-a_n) \} \cup f(n-1, k)
    \\
    \end{eqnarray}


.. code-block:: ghc
   

    f x = go x 0 where
     go [x] k = if x == k then [[x]] else []
     go (x:xs) k = map (x:) (go xs (k-x)) ++ go xs k
    main = print $ f [1,2,-1,-2,3]

.. code-block:: sh
   

    [[-1,-2,3]]
    



sum-n-coins.scm
=============================================


.. math::
    :nowrap:

    \begin{eqnarray}
        
    \\k_n * a_n + k_{n-1} * a_{n-1} + ... + k_1 * a_1 = SUM
    \\k_i >= 0, a_n > a_{n-1} > ... > a_1 > 0
    \\s.t. \quad \min \sum_{i=1}^n k_i
    \\
    \\使用するコインの集合を返す関数をfとおくと
    \\f(a_n, SUM) =  [an] * k_n \cup f(a_{n-1}, SUM - a_n \times k_n)
    \\f(a_0, X) = \phi
    \\ただし
    \\0 \le i \le \frac{SUM}{a_n}
    \\\sum f(a_n, SUM) == SUM
    \\
    \end{eqnarray}


この問題は、お釣りの問題に帰着できる
大きいお金を使えるだけ使って、その次にいく
ただし、失敗するかもしれない(最後が1でない場合で辻褄が合わせられない)


.. code-block:: ghc
   

    import Data.List
    
    solve :: [Int] -> Int -> [[Int]]
    solve [] sum = [[]]
    solve (c:coins) csum = concatMap (g . f) [0 .. (div csum c)]
      where
        -- xは、cにおける使用するコインの枚数
        -- fは、c:coinsにおける使用するコインのリストを返す
        f x = map ((take x (repeat c)) ++) (solve coins (csum - c * x))
        g = filter (\a-> sum a == csum)
    
    main = do
      -- mapM print $ solve [25, 10, 5, 1] 100
      print $ Data.List.minimumBy (\a b -> compare (length a) (length b)) $ solve [25, 10, 5, 1] 100

.. code-block:: sh
   

    [25,25,25,25]
    



totient.scm
=================================

