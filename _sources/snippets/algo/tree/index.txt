
============
tree
============

.. contents::
    :depth: 2



flatten.scm
=================================

(a b c d e f g h)
(a b c d e f g h)


index.scm
===========================



isBalanced.scm
==========================================



check the tree is balanced
------------------------------------------------------------------------------

balanced means any two leaf have the same length form root

.. code-block:: c
   

    #include <mystruct.h>
    int maxDepth(btree *node) {
     if (node == NULL) return 0;
     return 1 + MAX(maxDepth(node->left), maxDepth(node->right));
    }
    int minDepth(btree *node) {
     if (node == NULL) return 0;
     return 1 + MIN(minDepth(node->left), minDepth(node->right));
    }
    int isBalanced(btree *root) {
      return (maxDepth(root) - minDepth(root)) == 0;
    }
    int main() {
     #define i btree_init
     #define a btree_append
     #define b(x,y,z) a(i(x), i(y), i(z))
     #define E(n) btree_print(n, 0); printf("=> %s\n", isBalanced(n) ? "OK" : "NO");
     E(a(i(1), b(1,2,3), b(1,2,3)));
     E(a(i(1), b(1,2,3), a(i(1),i(2),b(3,4,5))));
     E(i(1));
    }

.. code-block:: sh
   

    1
     1
      2
      3
     1
      2
      3
    => OK
    1
     1
      2
      3
     1
      2
      3
       4
       5
    => NO
    1
    => OK
    



lowest-common-ancestor.scm
==============================================================================



Lowest Common Ancestor (ORDER=O(n))
---------------------------------------------------------------------------------------------------------

pathをキャッシュする

.. code-block:: cpp
   

    #include <mystruct.h>
    #include <myutils.h>
    btree *traverse(btree *DUMMY, btree *a, btree *b) {
      vector<btree*>paths;
      while(a) {
        paths.push_back(a);
        a = a->parent;
      }
      while (b) {
        if (find(paths.begin(), paths.end(), b) == paths.end())
          b = b->parent;
        else
          return b;
      }
      return NULL;
    }
    int main(){
     #define i(a) btree *n ## a = btree_init(a);
     #define a btree_append
     #define E(a, b) printf("%d, %d => %d\n", a->data, b->data, (traverse(n1, a, b) == NULL) ? -1 : traverse(n1, a, b)->data);
     i(1); i(2); i(3); i(4); i(5); i(6);
     a(n1, a(n2, n4, n5), a(n3,n6, NULL));
     btree_print(n1, 0); 
     E(n4, n5);
     E(n4, n6);
     E(n2, n6);
    }

.. code-block:: sh
   

    1
     2
      4
      5
     3
      6
    4, 5 => 2
    4, 6 => 1
    2, 6 => 1
    



Lowest Common Ancestor Without Addtional Memory (CI tree.6)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

rootから順にa,bを持つかどうか調べる

.. code-block:: cpp
   

    #include <mystruct.h>
    #include <myutils.h>
    int hasNode(btree *tree, btree *target) {
      if (tree == NULL)
        return FALSE;
      if (tree == target)
        return TRUE;
      return hasNode(tree->left, target) || hasNode(tree->right, target);
    }
    btree *traverse(btree *tree, btree *a, btree *b) {
      if (tree == NULL)
        return NULL;
      if (hasNode(tree->left, a) && hasNode(tree->left, b))
        return traverse(tree->left, a, b);
      else if (hasNode(tree->right, a) && hasNode(tree->right, b))
        return traverse(tree->right, a, b);
      return tree;
    }
    int main(){
     #define i(a) btree *n ## a = btree_init(a);
     #define a btree_append
     #define E(a, b) printf("%d, %d => %d\n", a->data, b->data, (traverse(n1, a, b) == NULL) ? -1 : traverse(n1, a, b)->data);
     i(1); i(2); i(3); i(4); i(5); i(6);
     a(n1, a(n2, n4, n5), a(n3,n6, NULL));
     btree_print(n1, 0); 
     E(n4, n5);
     E(n4, n6);
     E(n2, n6);
    }

.. code-block:: sh
   

    1
     2
      4
      5
     3
      6
    4, 5 => 2
    4, 6 => 1
    2, 6 => 1
    



traverse-order.scm
======================================================



in-order traversalにおける次のnodeの求め方 (CI tree.5)
------------------------------------------------------------------------------------------------------------------------------------


in-orderにおける次を求めたい :: 

    def traverse(tree):
        if tree.left:
            traverse(tree.left)
        # do something
        if tree.right:
            traverse(tree.right)

コードから読み取れること (#doした後、次どこか考える)
すでに#doしているので、rightがあれば、
次のnodeは traverse(tree.right) ではじめに# doするnodeとなる
(#do以外は同じコードを流用できるのがミソ、
ただし一つ目だけわかればよいので、if tree.rightなどは不要) ::

    def traverse(tree):
        if tree.left:
            traverse(tree.left)
        return tree  # do return!

rightがない場合は、親をたどるが、以下のいずれかから関数が返る
- traverse(tree.left)
- traverse(tree.right)
leftから戻ってきた場合は#doをするので、親が次のnodeとなる
rightから戻った場合、再度親をたどる(再帰)

rightから常に戻ってくる場合は、次のnodeがないことになる

in-orderの場合, left mid rightの順
mid => rightと評価されているので、親をたどるときに、
right側であれば、それはすでにmidで評価されているものになる
left側からの場合は、すぐにmidを評価してよい(l => m => rの順だからね)

コードから判断は、なんかよくわかんないけど
図にすれば、in-orderのpreバージョンも条件逆にするだけってのがよくわかる
とにかく、左子供から帰ってきたら、次親の真ん中だね


.. code-block:: c
   

    #include <mystruct.h>
    btree *traverse(btree *tree) {
      if (tree == NULL)
        return NULL;
      if (tree->right) {
        btree *n = tree->right;
        while (n->left)
          n = n->left;
        return n;
      } else {
        btree *n = tree;
        while (n->parent && n->parent->left != n)
          n = n->parent;
        return n->parent;
      }
    }
    
    int main(){
     #define i(a) btree *n ## a = btree_init(a);
     #define a btree_append
     #define E(n) printf("%d => %d\n", n->data, (traverse(n) == NULL) ? -1 : traverse(n)->data);
     i(1); i(2); i(3); i(4); i(5); i(6);
     a(n1, a(n2, n4, n5), a(n3,n6, NULL));
     btree_print(n1, 0); 
     E(n4); E(n2); E(n5); E(n1); E(n6); E(n3);
    }

.. code-block:: sh
   

    1
     2
      4
      5
     3
      6
    4 => 2
    2 => 5
    5 => 1
    1 => 6
    6 => 3
    3 => -1
    



in-order traversalにおける前のnodeの求め方
------------------------------------------------------------------------------------------------


.. code-block:: c
   

    #include <mystruct.h>
    btree *traverse(btree *tree) {
      if (tree->left) {
        btree *child = tree->left;
        while (child->right)
          child = child->right;
        return child;
      } else {
        btree *n = tree;
        while (n->parent && n->parent->right != n)
         n = n->parent;
        return n->parent;
      }
    }
    int main() {
     #define i(a) btree *n ## a = btree_init(a);
     #define a btree_append
     #define E(n) printf("%d => %d\n", n->data, (traverse(n) == NULL) ? -1 : traverse(n)->data);
     i(1); i(2); i(3); i(4); i(5); i(6);
     a(n1, a(n2, n4, n5), a(n3,n6, NULL));
     btree_print(n1, 0); 
     E(n3); E(n6); E(n1); E(n5); E(n2); E(n4);
    }

.. code-block:: sh
   

    1
     2
      4
      5
     3
      6
    3 => 6
    6 => 1
    1 => 5
    5 => 2
    2 => 4
    4 => -1
    

