
===============
monad
===============

.. contents::
    :depth: 2



applicative.scm
=============================================


- ``fmap == <$>``
- ``fmap f x == f <$> x == pure f <*> x``
- ``f <$> m1 <*> m2`` <=> ``do {a1 <- m1; a2 <-m2; return (f a1 a2)}``
- ``(<$) :: Functor f => a -> f b -> f a``
- ``(<*>) :: Applicative f => f (a -> b) -> f a -> f b``
- ``pure :: Applicative f => a -> f a`` (return似ているが、monadoでなくapplicativeを返す)
- ``(*>) :: Applicative f => f a -> f b -> f b`` ((*>) は (>>) と同じで左の値は捨てて右の値だけ活かす。(<*) はその逆)
- ``(<*) :: Applicative f => f a -> f b -> f a``

失敗してもよい。失敗したら次

.. code-block:: sh
   

    $ he 'Nothing <|> Just 2' 
    Just 2
    


.. code-block:: sh
   

    $ he 'Just 1 <|> Just 2' 
    Just 1
    


.. code-block:: sh
   

    $ he 'Nothing <|> Nothing :: Maybe Int' 
    Nothing
    


.. code-block:: sh
   

    $ he '(+2) <$> (Just 1)' 
    Just 3
    


.. code-block:: sh
   

    $ he '(+) <$> (Just 1) <*> (Just 2)' 
    Just 3
    


.. code-block:: sh
   

    $ he 'let f = (+) <$> (Just 1) in f <*> (Just 2)' 
    Just 3
    


.. code-block:: sh
   

    $ he '(\x y z-> x + y + z) <$> Just 1 <*> Just 2 <*> Just 3' 
    Just 6
    


.. code-block:: sh
   

    $ he '(\x y z-> x + y + z) <$> Just 1 <*> Nothing <*> Just 3' 
    Nothing
    

全ての関数に引数1を渡す(+1自体も実行される)

.. code-block:: sh
   

    $ he '((\x y z w->x + y + z + w) <*> (+3) <*> (+2) <*> (+1)) 1' 
    10
    

apply only (*2)

.. code-block:: sh
   

    $ he '((+2) *> (*2) <* (/2)) 10' 
    20.0
    

pure=constなので無視される

.. code-block:: sh
   

    $ he '((pure (+1)) <*> (*2)) 2' 
    5
    


.. code-block:: sh
   

    $ he '(\x y z -> x + y + z) <$> Just 1 <*> Just 2 <*> Just 3' 
    Just 6
    


.. code-block:: sh
   

    $ he 'do
       x <- Just 1
       y <- Just 2
       z <- Just 3
       return (x + y + z)' 
    Just 6
    


.. code-block:: sh
   

    $ he 'do {a1<-(Just 1); a2<-(Just 2); a3<- (Just 3); return (a1 + a2 + a3)}' 
    Just 6
    


.. code-block:: sh
   

    $ he 'pure (+1) <*> (Just 1)' 
    Just 2
    


.. code-block:: sh
   

    $ he 'liftA (+1) (Just 1)' 
    Just 2
    


.. code-block:: sh
   

    $ he 'liftA2 (*) (Just 5) (Just 3)' 
    Just 15
    


.. code-block:: sh
   

    $ he '1 <$ ["a"]' 
    [1]
    

モナドの値に対してモナドの値を適用する. 文脈の関数を適用

.. code-block:: sh
   

    $ he 'Just (*5) <*> Just 3' 
    Just 15
    


.. code-block:: sh
   

    $ he 'liftA2 (*) (Just 5) (Just 3)' 
    Just 15
    


.. code-block:: sh
   

    $ he '[(*2), (+3)] <*> [1, 2, 3]' 
    [2,4,6,4,5,6]
    


.. code-block:: sh
   

    $ he 'Just 1 *> Just 2' 
    Just 2
    


.. code-block:: sh
   

    $ he 'Just 1 <* Just 2' 
    Just 1
    


.. code-block:: sh
   

    $ he 'Just 1 *> Just 2 *> Just 3 *> Just 4 <* Just 5 <* Just 6' 
    Just 4
    



functor.scm
=================================

関数の場合 fmap = (.)

.. code-block:: sh
   

    $ he '((+1) <$> (*2) <$> (*3)) 1' 
    7
    


.. code-block:: sh
   

    $ he '((+1) . (*2)) <$> Just 1' 
    Just 3
    


.. code-block:: sh
   

    $ he '(+1) <$> (*2) <$> (+9) <$> (Just 1)' 
    Just 21
    


.. code-block:: sh
   

    $ he '((+1) . (*2) . (+9)) <$> (Just 1)' 
    Just 21
    

モナドな値を普通の関数の引数にはできない。 そういうときは、functorを利用する
関数の適用

.. code-block:: sh
   

    $ he '(2+) 3' 
    5
    

ラッパに入った値に対しては関数は適用できない

.. code-block:: sh
   

    $ he '(2+) (Just 3)' 
    
    /tmp/tmp.hTurBTX2:7:8:
        No instance for (Show a0) arising from a use of ‘print’
        The type variable ‘a0’ is ambiguous
        Note: there are several potential instances:
          instance Show a => Show (Const a b)
            -- Defined in ‘Control.Applicative’
          instance Show a => Show (ZipList a)
            -- Defined in ‘Control.Applicative’
          instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
          ...plus 33 others
        In the expression: print ((2 +) (Just 3))
        In an equation for ‘main’: main = print ((2 +) (Just 3))
    
    /tmp/tmp.hTurBTX2:7:17:
        No instance for (Num (Maybe a0)) arising from a use of ‘+’
        In the expression: 2 +
        In the first argument of ‘print’, namely ‘((2 +) (Just 3))’
        In the expression: print ((2 +) (Just 3))
    
    /tmp/tmp.hTurBTX2:7:26:
        No instance for (Num a0) arising from the literal ‘3’
        The type variable ‘a0’ is ambiguous
        Note: there are several potential instances:
          instance Num Integer -- Defined in ‘GHC.Num’
          instance Num time-1.5.0.1:Data.Time.Clock.UTC.NominalDiffTime
            -- Defined in ‘time-1.5.0.1:Data.Time.Clock.UTC’
          instance Num Double -- Defined in ‘GHC.Float’
          ...plus three others
        In the first argument of ‘Just’, namely ‘3’
        In the first argument of ‘2 +’, namely ‘(Just 3)’
        In the first argument of ‘print’, namely ‘((2 +) (Just 3))’
    

fmap:: (a -> b) -> f a -> f b (このfがモナドつまりラッパ)

.. code-block:: sh
   

    $ he 'fmap (2+) (Just 3)' 
    Just 5
    

<$ == fmap . const

.. code-block:: sh
   

    $ he '1 <$ (Just "abc")' 
    Just 1
    


.. code-block:: sh
   

    $ he '(fmap . const) 1 (Just "abc")' 
    Just 1
    

>> == (. const) . (>>=)

.. code-block:: sh
   

    $ he '((. const) . (>>=)) (Just 1) (Just 2)' 
    Just 2
    


.. warning::

    文脈をもつ関数の合成は.でなく<$>


.. code-block:: ghc
   

    main = (print <$> (+1)) 1

.. code-block:: sh
   

    2
    


.. code-block:: ghc
   

    main = print $ (+1) <$> Just 1

.. code-block:: sh
   

    Just 2
    


.. warning::

    合成は引数１つの関数に限る


.. code-block:: ghc
   

    
    import Control.Monad
    p = print <$> (+)
    main = return ()
    

.. code-block:: sh
   

    
    /tmp/tmp.u5ZqrUlo.hs:3:5:
        No instance for (Show (a0 -> a0))
          (maybe you haven't applied enough arguments to a function?)
          arising from a use of ‘print’
        In the first argument of ‘(<$>)’, namely ‘print’
        In the expression: print <$> (+)
        In an equation for ‘p’: p = print <$> (+)
    
    /tmp/tmp.u5ZqrUlo.hs:3:15:
        No instance for (Num a0) arising from a use of ‘+’
        The type variable ‘a0’ is ambiguous
        Relevant bindings include
          p :: a0 -> IO () (bound at /tmp/tmp.u5ZqrUlo.hs:3:1)
        Note: there are several potential instances:
          instance Num Integer -- Defined in ‘GHC.Num’
          instance Num Double -- Defined in ‘GHC.Float’
          instance Num Float -- Defined in ‘GHC.Float’
          ...plus two others
        In the second argument of ‘(<$>)’, namely ‘(+)’
        In the expression: print <$> (+)
        In an equation for ‘p’: p = print <$> (+)
    



index.scm
===========================



mapM.scm
========================


.. code-block:: ghc
   

    
    mapM' :: (Applicative m) => (a -> m b) -> [a] -> m [b]
    mapM' f [] = pure []
    mapM' f (x:xs) = (:) <$> f x <*> mapM' f xs
    main = mapM' print [1..5] >> return ()
    

.. code-block:: sh
   

    1
    2
    3
    4
    5
    


.. code-block:: ghc
   

    mapM' :: (Monad m) => (a -> m b) -> [a] -> m [b]
    mapM' f = foldr (\a acc->do{x<-f a; xs<-acc; return (x:xs)}) $ return []
    main = mapM' print [1..5] >> return ()

.. code-block:: sh
   

    1
    2
    3
    4
    5
    


.. code-block:: ghc
   

    mapM'_ :: (Applicative m) => (a -> m b) -> [a] -> m ()
    mapM'_ f [] = pure ()
    mapM'_ f (x:xs) = f x *> mapM'_ f xs
    main = mapM'_ print [1..5]

.. code-block:: sh
   

    1
    2
    3
    4
    5
    


.. code-block:: ghc
   

    mapM'_ :: (Monad m) => (a -> m b) -> [a] -> m ()
    mapM'_ f = foldr (\a acc->do{f a >> acc}) $ return ()
    main = mapM'_ print [1..5]

.. code-block:: sh
   

    1
    2
    3
    4
    5
    



monad.scm
===========================


.. code-block:: ghc
   

    import Control.Monad (guard)
    ptriples = do
        a <- [1..]
        b <- [1..a]     -- b <= a
        c <- [a..a+b]   -- 直角三角形c を斜辺とすれば a <= c かつ三角不等式より c <= a+b
        guard (a*a + b*b == c*c)
        return (b,a,c)  -- 小さい数から並べる
    main = mapM_ print $ take 5 ptriples

.. code-block:: sh
   

    (3,4,5)
    (6,8,10)
    (5,12,13)
    (9,12,15)
    (8,15,17)
    



monoid.scm
==============================



state.scm
===========================



transfer.scm
====================================


- lift . return == return
- lift (m >>= k) == lift m >>= (lift . k)

