
(ps "基本的な考え方")

;; (p "中点を取る際に、以下の２通りが考えられる(k $ge 0)")
;; (math "
;; high & = & low + 2k
;; high & = & low + 2k + 1
;; ")

;; (p "中点について")
;; (math "
;; mid & = & (low + high) / 2
;; ")

(math "
区間[low, high]を探索

中点を取る際に、以下の２通りが考えられる(k $ge 0)
high & = & low + 2k
high & = & low + 2k + 1

中点について
mid & = & (low + high) / 2
より、いずれの場合も、以下となる
mid & = & low + k

midが解でない場合は、区間を狭める必要がある. 
midは解ではないので、区間に含めない.

以下の範囲に狭めて探索を続ける
区間[low, mid - 1] (midよりも左側)
区間[mid + 1, high] (else)
")

;; 区間の幅は、以下のいずれか
;; (high - low + 1) = 2k + 1
;; (high - low + 1) = 2k + 1 + 1

(ps "終了条件をlow<highにすることの問題点")
(p "
k=0のとき、以下のいずれかとなる

- high = low (探索終了)
- high = low + 1 (ループ続ける)

しかし、ループを続けても、ともに終了条件となる

- [low, low+1] => [low+1, low+1] (右側探索)
- [low, low+1] => [low, low-1] (左側探索)

双方の場合、mid = lowなので、lowの探索はするが、low+1の探索はしない.
つまり、low<highの終了条件の場合、[low, low+1)の範囲しか探索しない.
")
(ptodo "ここから、1bit目が0のもの全てが探索されないといいたい")


(ps "midで更新することの問題点")
(p "
k = 0 かつ、終了条件がlow<=high のとき、mid = lowなので、

右側探索で更新する時、mid+1せず、midで更新すると、以下のように無限ループになる.

- [low, low]   => 右側探索 => [mid, low]   = [low, low]
- [low, low+1] => 右側探索 => [mid, low+1] = [low, low+1]

左側探索で更新する時、mid-1せず、midで更新すると、同様に無限ループになる.

- [low, low]   => 左側探索 => [low, mid] = [low, low]
- [low, low+1] => 左側探索 => [low, mid] = [low, low]

つまり、解ではないことが判明したmidを区間に含めないように、mid+1, mid-1して区間を狭める必要がある。
")

(ptodo "minを取得する場合は、若干工夫する必要あり")

(p #!Q
ビット演算でのイメージ
======================
``f(x) = -x^2 + 10*x + 1`` の ``max x in N st f(x) > 0`` を考える。
答えは、 ``f(10) = 1, f(11) = -10`` よりx=10である。

``f(2^4) < 0`` なので、4乗は境界線を超えている(当然f(2^5)なども、この関数では同様)。
これは、 ``x < 16`` と値域が狭まったことを意味している。
2進数で言うと、0b0XXXXと5桁目以降が0bitであることを意味している。

``f(2^3) >= 0`` なので、 ``8 <= x < 16`` となり、
2進数で言うと、0b01XXXと4桁目が1bitを意味する。

``f(2^3 + 2^2) < 0`` なので、 ``8 <= x < 12`` となり、 0b010XXとなる。
xは8以上なので、ここで ``f(2^2)`` などを計算することに意味はない。

同様に
``f(2^3 + 2^1) >= 0`` なので、 ``10 <= x < 12`` となり、 0b0101Xとなる。

``f(2^3 + 2^1 + 2^0) < 0`` なので、 ``10 <= x < 11`` となり、 0b01010が答えとなる。

::

    f = lambda x: -(x * x) + 10 * x + 1

    def p(n):
        print("f(%s) = %s" % (n, f(n)))

    p(pow(2, 5))  # f() < 0
    p(pow(2, 4))  # f() < 0
    p(pow(2, 3))  # f() >= 0
    p(pow(2, 3) + pow(2, 2))
    p(pow(2, 3) + pow(2, 1))
    p(pow(2, 3) + pow(2, 1) + pow(2, 0))
   
アルゴリズムのイメージは、
ジャンプの飛び幅を徐々に小さくしながら目的地に到達するイメージとなる。
つまり、大きい方から範囲を徐々に狭めるイメージ。

.. warning:: bit演算の問題点は、負の数には対応できないので、注意すること。
Q)


(ps "使えない場合の例")
(p "[5,6,5,6,1,1,1,1,6,5,6,5]の数列の極大値を各グループごとに含むようにして、できるだけ多く分割したい場合
n=3で失敗するからといって、n=4も失敗するとは限らない")
