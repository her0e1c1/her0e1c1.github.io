# Longest Increasing Subsequence

`a < b < c ...` を満たすような配列のうち最も長いものを求める

binary searchを使うことで、O(nlogn)に計算量を減らすことが可能 (ただし長さだけ)

{4,2,3,3,1,5}を例にすると、dpは以下のように更新されていく
```
4     (空なので4)
2     (4より小さい2で更新)
2,3   (最後が2より大きい)
2,3   (重複した3はdpを更新しない)
1,3   (最後の要素より小さいので、minで更新)
1,3,5 (最も大きい5は、最後に追加)
```

答えは 2,3,5だけれども、
各要素をそれよりも小さい値で更新しても問題ないことを利用している.

`dp[current] <= dp[i]` を満たす最小のiを求める.
