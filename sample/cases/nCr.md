# 異なるn個からr個取り出す組み合わせ(nCr)

## 式
(ある１つを除いた中からr個の組み合わせ) + (その１つを必ず用いて残りのr-1個による組み合わせ)
```
nCr = n-1Cr + n-1Cr-1
nC0 = nCn = 1
```

## dpの更新例
式の通り、n-1からnが求められるのでn-1の結果だけを記憶していれば良い.
rとr-1からrを算出するため、順方向のループだと結果を上書きしてしまうので、
逆方向にループする必要がある.

例えば
```
a b c d
x y z w
```
z=b+cでc=>zに更新.
この状態だと、w=c+dとはならずw=z+dとなってしまう
このため順方向には計算できない。
逆方向ではy=a+bでb=>yに更新するので前の計算の影響を受けない

```
nCr(4, 2) == 6
[1 0 0 0 0]
[1 1 0 0 0]
[1 2 1 0 0]
[1 3 3 1 0]  // (ex) 3+3=6で右側の3が6に上書き. 逆方向1+3=4は可能
[1 4 6 4 1]
```

```
nCr(5, 3) == 10
[1 0 0 0 0 0]
[1 1 0 0 0 0]
[1 2 1 0 0 0]
[1 3 3 1 0 0]
[1 4 6 4 1 0]
[1 5 10 10 5 1]
```

なお、nCn==1は1+0=1で計算している

## dpと再帰
多分nCrの全ての要素を算出する場合はdpは使えないと思う. (quick sortでdpができなさそうなのと同じ理由)

考えられる理由
1. 結果をキャッシュできない???
2. ノードによって値がバラバラ
3. fib(3)はキャッシュしやすいし、再帰ではキャッシュできる => dpでもできる
4. listはキャッシュしにくい => 破壊的? 毎回コピー面倒?
5. 多分、リーフの結果がそれぞれ異なるとキャッシュできないのでdp使えない.
6. dpはボトムアップだけど、そもそもリーフがわからないので初期値決まらない
7. 分割問題は再帰が適しているっぽい (多分、並列化できる. けど全てのノードまで到達したかをどう待つ?)
8. 親からの遷移と子からの遷移は、対象操作が原則
9. 子供の値を利用して、現在のノードの値を算出する場合はdp

暫定的結論: リーフの値が異なる場合は、キャッシュできないため、dp不可
